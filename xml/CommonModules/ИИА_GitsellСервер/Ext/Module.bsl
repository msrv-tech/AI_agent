// Серверная интеграция с Gitsell

#Область Integration_Gitsell

// Начинает процесс Device Flow авторизации
Функция Gitsell_НачатьDeviceFlow(InstanceLabel = "1C Agent", UserAgent = "1C-Enterprise") Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Успех", Ложь);
	Результат.Вставить("Ошибка", "");
	Результат.Вставить("device_code", "");
	Результат.Вставить("user_code", "");
	Результат.Вставить("verification_uri_complete", "");
	Результат.Вставить("expires_in", 0);
	Результат.Вставить("interval", 5);
	
	Попытка
		// Генерируем новый UUID для каждой сессии авторизации
		InstanceId = Строка(Новый УникальныйИдентификатор);
		
		Соединение = Новый HTTPСоединение("gitsell.ru", 443, , , , , Новый ЗащищенноеСоединениеOpenSSL());
		
		Заголовки = Новый Соответствие;
		Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
		Заголовки.Вставить("Accept", "application/json");
		If НЕ ПустаяСтрока(UserAgent) Тогда
			Заголовки.Вставить("User-Agent", UserAgent);
		КонецЕсли;
		
		// Параметры запроса
		ПараметрыСтрока = "client_id=1c-agent" +
			"&scope=agent:read agent:write profile:read" +
			"&instance_id=" + КодироватьСтроку(InstanceId, СпособКодированияСтроки.URLВКодировкеURL) +
			"&instance_label=" + КодироватьСтроку(InstanceLabel, СпособКодированияСтроки.URLВКодировкеURL);
			
		Запрос = Новый HTTPЗапрос("/api/oauth/device_authorization", Заголовки);
		Запрос.УстановитьТелоИзСтроки(ПараметрыСтрока);
		
		Ответ = Соединение.ОтправитьДляОбработки(Запрос);
		ТекстОтвета = Ответ.ПолучитьТелоКакСтроку();
		
		Если Ответ.КодСостояния = 200 Тогда
			Попытка
				ЧтениеJSON = Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(ТекстОтвета);
				Данные = ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				
				Результат.Успех = Истина;
				Результат.device_code = Данные.device_code;
				Результат.user_code = Данные.user_code;
				Результат.verification_uri_complete = Данные.verification_uri_complete;
				Результат.expires_in = Данные.expires_in;
				Результат.interval = Данные.interval;
			Исключение
				Результат.Ошибка = "Ошибка парсинга ответа: " + ОписаниеОшибки();
			КонецПопытки;
		Иначе
			Результат.Ошибка = "Ошибка сервера (" + Ответ.КодСостояния + "): " + ТекстОтвета;
		КонецЕсли;
		
	Исключение
		Результат.Ошибка = "Ошибка соединения: " + ОписаниеОшибки();
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Опрашивает статус токена
Функция Gitsell_ОпросТокена(DeviceCode) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Статус", "error");
	Результат.Вставить("Токен", "");
	Результат.Вставить("Ошибка", "");
	
	Попытка
		Соединение = Новый HTTPСоединение("gitsell.ru", 443, , , , , Новый ЗащищенноеСоединениеOpenSSL());
		
		Заголовки = Новый Соответствие;
		Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
		Заголовки.Вставить("Accept", "application/json");
		
		ПараметрыСтрока = "client_id=1c-agent" +
			"&grant_type=urn:ietf:params:oauth:grant-type:device_code" +
			"&device_code=" + КодироватьСтроку(DeviceCode, СпособКодированияСтроки.URLВКодировкеURL);
			
		Запрос = Новый HTTPЗапрос("/api/oauth/token", Заголовки);
		Запрос.УстановитьТелоИзСтроки(ПараметрыСтрока);
		
		Ответ = Соединение.ОтправитьДляОбработки(Запрос);
		ТекстОтвета = Ответ.ПолучитьТелоКакСтроку();
		
		// Пытаемся распарсить JSON
		Данные = Неопределено;
		Попытка
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ТекстОтвета);
			Данные = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
		Исключение
			// Ошибка парсинга - оставляем Данные = Неопределено
		КонецПопытки;
		
		Если Ответ.КодСостояния = 200 Тогда
			Если Данные <> Неопределено И Данные.Свойство("ai_proxy_token") Тогда
				Результат.Статус = "success";
				Результат.Токен = Данные.ai_proxy_token;
				
				// Получаем email, если access_token есть в ответе
				Если Данные.Свойство("access_token") Тогда
					Попытка
						СоединениеAPI = Новый HTTPСоединение("gitsell.ru", 443, , , , , Новый ЗащищенноеСоединениеOpenSSL());
						ЗаголовкиAPI = Новый Соответствие;
						ЗаголовкиAPI.Вставить("Authorization", "Bearer " + Данные.access_token);
						ЗапросAPI = Новый HTTPЗапрос("/api/me", ЗаголовкиAPI);
						ОтветAPI = СоединениеAPI.Получить(ЗапросAPI);
						
						Если ОтветAPI.КодСостояния = 200 Тогда
							ЧтениеJSON_API = Новый ЧтениеJSON;
							ЧтениеJSON_API.УстановитьСтроку(ОтветAPI.ПолучитьТелоКакСтроку());
							ДанныеAPI = ПрочитатьJSON(ЧтениеJSON_API);
							ЧтениеJSON_API.Закрыть();
							
							Если ДанныеAPI.Свойство("email") Тогда
								Результат.Вставить("Email", ДанныеAPI.email);
							КонецЕсли;
						КонецЕсли;
					Исключение
						// Игнорируем ошибки получения email
					КонецПопытки;
				КонецЕсли;
				
			Иначе
				Результат.Ошибка = "В ответе нет ai_proxy_token" + ?(Данные = Неопределено, " (JSON не распознан)", "");
			КонецЕсли;
		Иначе
			// Обработка ошибок OAuth
			Если Данные <> Неопределено И Данные.Свойство("error") Тогда
				КодОшибки = Данные.error;
				Если КодОшибки = "authorization_pending" Тогда
					Результат.Статус = "pending";
				ИначеЕсли КодОшибки = "slow_down" Тогда
					Результат.Статус = "slow_down";
				ИначеЕсли КодОшибки = "expired_token" Тогда
					Результат.Статус = "expired";
				ИначеЕсли КодОшибки = "access_denied" Тогда
					Результат.Статус = "denied";
				Иначе
					Результат.Статус = "error";
					Результат.Ошибка = "Ошибка OAuth: " + КодОшибки;
				КонецЕсли;
			Иначе
				Результат.Ошибка = "Ошибка сервера (" + Ответ.КодСостояния + "): " + ТекстОтвета;
			КонецЕсли;
		КонецЕсли;
		
	Исключение
		Результат.Ошибка = "Ошибка соединения: " + ОписаниеОшибки();
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Сохраняет токен Gitsell в настройки
Процедура Gitsell_СохранитьAiProxyToken(Токен, Email = "") Экспорт
	
	Пользователь = ИИА_Сервер.ИмяТекущегоПользователя();
	
	НаборЗаписей = РегистрыСведений.ИИА_НастройкиПользователей.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Пользователь.Установить(Пользователь);
	НаборЗаписей.Прочитать();
	
	Если НаборЗаписей.Количество() = 0 Тогда
		Запись = НаборЗаписей.Добавить();
		Запись.Пользователь = Пользователь;
	Иначе
		Запись = НаборЗаписей[0];
	КонецЕсли;
	
	Запись.Provider_ApiKey = Токен;
	Запись.Provider_BaseUrl = "https://gitsell.ru/api/v1"; // Стандартный URL
	Запись.Модель = "auto";
	
	Если ЗначениеЗаполнено(Email) Тогда
		Запись.email = Email;
	КонецЕсли;
	
	НаборЗаписей.Записать();
	
КонецПроцедуры

// Проверяет наличие настроек пользователя (любого пользователя в регистре)
//
// Возвращаемое значение:
//  Булево - Истина, если есть хотя бы одна настройка
//
Функция ЕстьНастройкиПользователя() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Настройки.Пользователь
	|ИЗ
	|	РегистрСведений.ИИА_НастройкиПользователей КАК Настройки";
	
	Результат = Запрос.Выполнить();
	Возврат НЕ Результат.Пустой();
	
КонецФункции

// Проверяет работу токена (GET /models)
Функция Gitsell_ПроверитьModels() Экспорт
	
	Результат = Новый Структура("Успех, Ошибка", Ложь, "");
	
	Попытка
		Настройки = ИИА_Сервер.ПолучитьНастройкиПользователя();
		Токен = Настройки.Provider_ApiKey;
		Если ПустаяСтрока(Токен) Тогда
			Токен = Настройки.Токен;
		КонецЕсли;
		
		Если ПустаяСтрока(Токен) Тогда
			Результат.Ошибка = "Токен не найден в настройках";
			Возврат Результат;
		КонецЕсли;
		
		Соединение = Новый HTTPСоединение("gitsell.ru", 443, , , , , Новый ЗащищенноеСоединениеOpenSSL());
		
		Заголовки = Новый Соответствие;
		Заголовки.Вставить("Authorization", "Bearer " + Токен);
		Заголовки.Вставить("X-Gitsell-Repo", "msrv-tech/1c-ai-autofill");
		
		Запрос = Новый HTTPЗапрос("/api/v1/models", Заголовки);
		Ответ = Соединение.Получить(Запрос);
		
		Если Ответ.КодСостояния = 200 Тогда
			Результат.Успех = Истина;
		Иначе
			Результат.Ошибка = "Ошибка проверки токена (" + Ответ.КодСостояния + "): " + Ответ.ПолучитьТелоКакСтроку();
		КонецЕсли;
		
	Исключение
		Результат.Ошибка = "Ошибка соединения: " + ОписаниеОшибки();
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Возвращает список доступных моделей ИИ
Функция Gitsell_СписокМоделей() Экспорт
	
	Модели = Новый Массив;
	Модели.Добавить(Новый Структура("id, name", "auto", "AUTO (виртуальная)"));
	
	// OpenAI
	Модели.Добавить(Новый Структура("id, name", "gpt-4", "openai/gpt-4"));
	Модели.Добавить(Новый Структура("id, name", "gpt-4-turbo", "openai/gpt-4-turbo"));
	Модели.Добавить(Новый Структура("id, name", "gpt-4o", "openai/gpt-4o"));
	Модели.Добавить(Новый Структура("id, name", "gpt-3.5-turbo", "openai/gpt-3.5-turbo"));
	Модели.Добавить(Новый Структура("id, name", "gpt-3.5-turbo-16k", "openai/gpt-3.5-turbo-16k"));
	Модели.Добавить(Новый Структура("id, name", "gpt-image-1", "openai/gpt-image-1"));
	Модели.Добавить(Новый Структура("id, name", "gpt-image-1-mini", "openai/gpt-image-1-mini"));
	
	// Anthropic
	Модели.Добавить(Новый Структура("id, name", "claude-3-opus", "anthropic/claude-3-opus"));
	Модели.Добавить(Новый Структура("id, name", "claude-3-sonnet", "anthropic/claude-3-sonnet"));
	Модели.Добавить(Новый Структура("id, name", "claude-3-haiku", "anthropic/claude-3-haiku"));
	Модели.Добавить(Новый Структура("id, name", "claude-3-5-sonnet", "anthropic/claude-3-5-sonnet"));
	
	// DeepSeek
	Модели.Добавить(Новый Структура("id, name", "deepseek-chat", "deepseek/deepseek-chat"));
	Модели.Добавить(Новый Структура("id, name", "deepseek-coder", "deepseek/deepseek-coder"));
	
	// GigaChat
	Модели.Добавить(Новый Структура("id, name", "GigaChat-2-Max", "gigachat/GigaChat-2-Max"));
	Модели.Добавить(Новый Структура("id, name", "GigaChat-2-Pro", "gigachat/GigaChat-2-Pro"));
	Модели.Добавить(Новый Структура("id, name", "GigaChat-2", "gigachat/GigaChat-2"));
	
	// YandexGPT
	Модели.Добавить(Новый Структура("id, name", "yandexgpt", "yandex/yandexgpt"));
	Модели.Добавить(Новый Структура("id, name", "yandexgpt-lite", "yandex/yandexgpt-lite"));
	
	// Google Gemini
	Модели.Добавить(Новый Структура("id, name", "gemini-2.0-flash", "google/gemini-2.0-flash"));
	Модели.Добавить(Новый Структура("id, name", "gemini-2.0-flash-001", "google/gemini-2.0-flash-001"));
	Модели.Добавить(Новый Структура("id, name", "gemini-2.0-flash-lite", "google/gemini-2.0-flash-lite"));
	Модели.Добавить(Новый Структура("id, name", "gemini-2.0-flash-lite-001", "google/gemini-2.0-flash-lite-001"));
	Модели.Добавить(Новый Структура("id, name", "gemini-2.5-flash", "google/gemini-2.5-flash"));
	Модели.Добавить(Новый Структура("id, name", "gemini-2.5-flash-lite", "google/gemini-2.5-flash-lite"));
	Модели.Добавить(Новый Структура("id, name", "gemini-2.5-pro", "google/gemini-2.5-pro"));
	Модели.Добавить(Новый Структура("id, name", "gemini-2.5-flash-image", "google/gemini-2.5-flash-image"));
	Модели.Добавить(Новый Структура("id, name", "gemini-3-pro-image-preview", "google/gemini-3-pro-image-preview"));
	
	Возврат Модели;
	
КонецФункции

#КонецОбласти

#Область GitHub_Updater

Функция GitHub_ПолучитьИмяРасширения()
	// Имя расширения (используется и для проверки обновлений, и для установки)
	Возврат "ИИ_Агент";
КонецФункции

// Проверяет наличие обновления на GitHub
// Возвращает Структуру:
// - Доступно (Булево)
// - НоваяВерсия (Строка)
// - Описание (Строка)
// - СсылкаНаРелиз (Строка)
// - СсылкаНаСкачивание (Строка)
// - Ошибка (Строка)
Функция GitHub_ПроверитьОбновление() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Доступно", Ложь);
	Результат.Вставить("НоваяВерсия", "");
	Результат.Вставить("Описание", "");
	Результат.Вставить("СсылкаНаРелиз", "");
	Результат.Вставить("СсылкаНаСкачивание", "");
	Результат.Вставить("Ошибка", "");
	
	Попытка
		// 1. Определяем префикс
		Префикс = GitHub_ПолучитьПрефиксТега();
		
		// 2. Текущая версия
		ИмяРасширения = GitHub_ПолучитьИмяРасширения();
		МассивРасширений = РасширенияКонфигурации.Получить(Новый Структура("Имя", ИмяРасширения));
		Если МассивРасширений.Количество() = 0 Тогда
			Результат.Ошибка = "Не найдено расширение '" + ИмяРасширения + "' в списке расширений конфигурации";
			Возврат Результат;
		КонецЕсли;
		
		ТекущаяВерсия = МассивРасширений[0].Версия;
		Если НЕ ЗначениеЗаполнено(ТекущаяВерсия) Тогда
			Результат.Ошибка = "Не определена текущая версия расширения '" + ИмяРасширения + "'";
			Возврат Результат;
		КонецЕсли;
		
		// 3. Запрос к GitHub API
		Соединение = Новый HTTPСоединение("api.github.com", 443, , , , , Новый ЗащищенноеСоединениеOpenSSL());
		Заголовки = Новый Соответствие;
		Заголовки.Вставить("Accept", "application/vnd.github.v3+json");
		Заголовки.Вставить("User-Agent", "1C-Client");
		
		Запрос = Новый HTTPЗапрос("/repos/msrv-tech/1c-ai-autofill/releases", Заголовки);
		Ответ = Соединение.Получить(Запрос);
		
		Если Ответ.КодСостояния <> 200 Тогда
			Результат.Ошибка = "Ошибка GitHub API (" + Ответ.КодСостояния + "): " + Ответ.ПолучитьТелоКакСтроку();
			Возврат Результат;
		КонецЕсли;
		
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(Ответ.ПолучитьТелоКакСтроку());
		Релизы = ПрочитатьJSON(ЧтениеJSON);
		ЧтениеJSON.Закрыть();
		
		// 4. Поиск подходящего релиза
		Для Каждого Релиз Из Релизы Цикл
			
			// Пропускаем черновики и пререлизы
			Если Релиз.draft ИЛИ Релиз.prerelease Тогда
				Продолжить;
			КонецЕсли;
			
			TagName = Релиз.tag_name;
			
			// Проверяем префикс
			Если СтрНайти(TagName, Префикс) <> 1 Тогда
				Продолжить;
			КонецЕсли;
			
			// Извлекаем версию (удаляем префикс)
			ВерсияРелиза = Сред(TagName, СтрДлина(Префикс) + 1);
			
			// Сравниваем версии
			Если GitHub_СравнитьВерсии(ВерсияРелиза, ТекущаяВерсия) > 0 Тогда
				
				// Нашли обновление. Ищем asset
				Assets = Релиз.assets;
				НайденоAssets = 0;
				UrlСкачивания = "";
				
				Для Каждого Asset Из Assets Цикл
					ИмяФайла = Asset.name;
					Если Прав(НРег(ИмяФайла), 4) = ".cfe" Тогда
						НайденоAssets = НайденоAssets + 1;
						UrlСкачивания = Asset.browser_download_url;
					КонецЕсли;
				КонецЦикла;
				
				Если НайденоAssets = 0 Тогда
					Результат.Ошибка = "В релизе " + TagName + " нет файла .cfe";
					Возврат Результат;
				ИначеЕсли НайденоAssets > 1 Тогда
					Результат.Ошибка = "В релизе " + TagName + " найдено более одного файла .cfe";
					Возврат Результат;
				КонецЕсли;
				
				Результат.Доступно = Истина;
				Результат.НоваяВерсия = ВерсияРелиза;
				Результат.Описание = Релиз.body;
				Результат.СсылкаНаРелиз = Релиз.html_url;
				Результат.СсылкаНаСкачивание = UrlСкачивания;
				
				Прервать; // Берем первый подходящий (самый свежий)
			КонецЕсли;
			
		КонецЦикла;
		
	Исключение
		Результат.Ошибка = "Ошибка проверки обновления: " + ОписаниеОшибки();
	КонецПопытки;
	
	Возврат Результат;

КонецФункции

Функция GitHub_ПолучитьПрефиксТега()
	
	//
	//	Возврат "UNF_Rozn_";
	//Иначе
	//	Возврат "UT_KA_ERP_";
	//КонецЕсли;  
	Возврат "";
	
КонецФункции

// Возвращает: 1 если В1 > В2, -1 если В1 < В2, 0 если равны
Функция GitHub_СравнитьВерсии(Версия1, Версия2)
	
	В1 = СтрЗаменить(Версия1, ".", Символы.ПС);
	В2 = СтрЗаменить(Версия2, ".", Символы.ПС);
	
	// Приводим к 4 частям (стандарт 1С)
	Массив1 = СтрРазделить(В1, Символы.ПС);
	Массив2 = СтрРазделить(В2, Символы.ПС);
	
	Кол = Макс(Массив1.Количество(), Массив2.Количество());
	
	Для Сч = 0 По Кол - 1 Цикл
		Ч1 = ?(Сч < Массив1.Количество(), Число(Массив1[Сч]), 0);
		Ч2 = ?(Сч < Массив2.Количество(), Число(Массив2[Сч]), 0);
		
		Если Ч1 > Ч2 Тогда
			Возврат 1;
		ИначеЕсли Ч1 < Ч2 Тогда
			Возврат -1;
		КонецЕсли;
	КонецЦикла;
	
	Возврат 0;

КонецФункции

Функция GitHub_СкачатьФайл(Url) Экспорт
	
	// Разбираем URL
	ПозПротокола = СтрНайти(Url, "://");
	Если ПозПротокола > 0 Тогда
		ОстатокURL = Сред(Url, ПозПротокола + 3);
	Иначе
		ОстатокURL = Url;
	КонецЕсли;
	
	ПозСлэша = СтрНайти(ОстатокURL, "/");
	Если ПозСлэша > 0 Тогда
		Сервер = Лев(ОстатокURL, ПозСлэша - 1);
		Путь = Сред(ОстатокURL, ПозСлэша);
	Иначе
		Сервер = ОстатокURL;
		Путь = "/";
	КонецЕсли;
	
	Соединение = Новый HTTPСоединение(Сервер, 443, , , , , Новый ЗащищенноеСоединениеOpenSSL());
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("User-Agent", "1C-Client");
	
	Запрос = Новый HTTPЗапрос(Путь, Заголовки);
	Ответ = Соединение.Получить(Запрос);
	
	Если Ответ.КодСостояния = 200 Тогда
		Возврат Ответ.ПолучитьТелоКакДвоичныеДанные();
		
	ИначеЕсли Ответ.КодСостояния = 302 ИЛИ Ответ.КодСостояния = 301 ИЛИ Ответ.КодСостояния = 307 Тогда
		
		Location = Ответ.Заголовки.Получить("Location");
		Если ЗначениеЗаполнено(Location) Тогда
			// Рекурсивно скачиваем по новому адресу
			Возврат GitHub_СкачатьФайл(Location);
		Иначе
			ВызватьИсключение "Ошибка редиректа: не указан Location";
		КонецЕсли;
		
	Иначе
		ВызватьИсключение "Ошибка скачивания (" + Ответ.КодСостояния + "): " + Ответ.ПолучитьТелоКакСтроку();
	КонецЕсли;
	
КонецФункции

// Устанавливает расширение из двоичных данных
Процедура УстановитьРасширение(ДвоичныеДанные) Экспорт
	
	// Имя расширения берем из метаданных текущей конфигурации (если это расширение)
	ИмяРасширения = GitHub_ПолучитьИмяРасширения(); 
	
	// Пытаемся найти существующее
	Отбор = Новый Структура("Имя", ИмяРасширения);
	Найденные = РасширенияКонфигурации.Получить(Отбор);
	
	Расширение = Неопределено;
	
	Если Найденные.Количество() > 0 Тогда
		Расширение = Найденные[0];
	Иначе
		
	КонецЕсли;
	
	Расширение.Записать(ДвоичныеДанные);
	
КонецПроцедуры

#КонецОбласти
