// Модуль для обработки текста: нормализация, токенизация, CamelCase

// Функция нормализует текст: приводит к нижнему регистру и заменяет разделители на пробелы
//
// Параметры:
//  Текст - Строка - Исходный текст
//
// Возвращаемое значение:
//  Строка - Нормализованный текст
Функция Нормализовать(Знач Текст) Экспорт
	
	Если Текст = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	// Сначала обрабатываем CamelCase, пока у нас есть заглавные буквы
	Текст = РазрезатьCamelCase(Текст);
	
	Текст = НРег(Текст);
	
	// Заменить разделители на пробел
	Разделители = ".,:;()[]{}\/-_""'`|!?";
	Для Поз = 1 По СтрДлина(Разделители) Цикл
		Символ = Сред(Разделители, Поз, 1);
		Текст = СтрЗаменить(Текст, Символ, " ");
	КонецЦикла;
	
	// Удаляем лишние пробелы
	Текст = СокрЛП(Текст);
	Пока Найти(Текст, "  ") > 0 Цикл
		Текст = СтрЗаменить(Текст, "  ", " ");
	КонецЦикла;
	
	Возврат Текст;
	
КонецФункции

// Функция разрезает CamelCase: РеализацияТоваров -> Реализация Товаров
//
// Параметры:
//  Текст - Строка - Исходный текст
//
// Возвращаемое значение:
//  Строка - Текст с пробелами перед заглавными буквами
Функция РазрезатьCamelCase(Знач Текст) Экспорт
	
	Если СтрДлина(Текст) < 2 Тогда
		Возврат Текст;
	КонецЕсли;
	
	Результат = "";
	ПредыдущийСимвол = "";
	
	Для Поз = 1 По СтрДлина(Текст) Цикл
		
		ТекущийСимвол = Сред(Текст, Поз, 1);
		
		// Если текущий символ заглавный, а предыдущий строчный или цифра - вставляем пробел
		Если Поз > 1 Тогда
			Если ВРег(ТекущийСимвол) = ТекущийСимвол 
				И НРег(ТекущийСимвол) <> ТекущийСимвол // Это буква
				И (НРег(ПредыдущийСимвол) = ПредыдущийСимвол Или Найти("0123456789", ПредыдущийСимвол) > 0) Тогда
				Результат = Результат + " ";
			КонецЕсли;
		КонецЕсли;
		
		Результат = Результат + ТекущийСимвол;
		ПредыдущийСимвол = ТекущийСимвол;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Функция разбивает текст на токены
//
// Параметры:
//  Текст - Строка - Нормализованный текст
//  СтопСлова - Массив - Список стоп-слов
//
// Возвращаемое значение:
//  Массив - Список токенов
Функция Токенизировать(Знач Текст, СтопСлова = Неопределено) Экспорт
	
	Результат = Новый Массив;
	
	Если ПустаяСтрока(Текст) Тогда
		Возврат Результат;
	КонецЕсли;
	
	Части = СтрРазделить(Текст, " ", Ложь);
	
	Для каждого Часть Из Части Цикл
		
		Токен = СокрЛП(Часть);
		
		// Фильтр по длине
		Если СтрДлина(Токен) < 2 Или СтрДлина(Токен) > 64 Тогда
			Продолжить;
		КонецЕсли;
		
		// Фильтр по стоп-словам
		Если СтопСлова <> Неопределено Тогда
			Если СтопСлова.Найти(Токен) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		Результат.Добавить(Токен);
		
		// Добавляем Stem-lite для русских слов
		Стем = Стеммировать(Токен);
		Если НЕ ПустаяСтрока(Стем) И Стем <> Токен Тогда
			Результат.Добавить("s:" + Стем);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Функция выполняет эвристический стемминг для русского языка (Stem-lite)
//
// Параметры:
//  Слово - Строка - Исходное слово
//
// Возвращаемое значение:
//  Строка - Основа слова
Функция Стеммировать(Знач Слово) Экспорт
	
	Слово = НРег(Слово);
	
	// Ограничения: длина >= 5, только кириллица
	Если СтрДлина(Слово) < 5 Тогда
		Возврат Слово;
	КонецЕсли;
	
	// Проверка на кириллицу (упрощенно)
	Для Поз = 1 По СтрДлина(Слово) Цикл
		Код = КодСимвола(Сред(Слово, Поз, 1));
		Если НЕ ((Код >= 1040 И Код <= 1103) Или Код = 1105 Или Код = 1025) Тогда
			Возврат Слово; // Содержит не кириллицу
		КонецЕсли;
	КонецЦикла;
	
	// Список окончаний для отрезания (от длинных к коротким)
	// 4-5 букв
	Окончания5 = "иями,ями,иями,ющего,ующему,остью";
	// 3 буквы
	Окончания3 = "ами,ями,ого,ему,ыми,ими,ать,ять,ией,иям,иях,июю,яющ";
	// 2 буквы
	Окончания2 = "ой,ый,ая,ое,ые,ам,ям,ов,ев,ом,ем,ах,ях,ую,юю,ия,ие,ий,ть,ти,ят,ат,ет,ит,ых,их";
	
	// Пробуем отрезать
	Для каждого Окончание Из СтрРазделить(Окончания5, ",") Цикл
		Если Прав(Слово, СтрДлина(Окончание)) = Окончание Тогда
			Возврат Лев(Слово, СтрДлина(Слово) - СтрДлина(Окончание));
		КонецЕсли;
	КонецЦикла;
	
	Для каждого Окончание Из СтрРазделить(Окончания3, ",") Цикл
		Если Прав(Слово, СтрДлина(Окончание)) = Окончание Тогда
			Возврат Лев(Слово, СтрДлина(Слово) - СтрДлина(Окончание));
		КонецЕсли;
	КонецЦикла;
	
	Для каждого Окончание Из СтрРазделить(Окончания2, ",") Цикл
		Если Прав(Слово, СтрДлина(Окончание)) = Окончание Тогда
			Возврат Лев(Слово, СтрДлина(Слово) - СтрДлина(Окончание));
		КонецЕсли;
	КонецЦикла;
	
	Возврат Слово;
	
КонецФункции

// Функция вычисляет простой хэш для строки (аналог SHA1 не требуется для MVP, используем простой вариант)
//
// Параметры:
//  Текст - Строка - Текст для хэширования
//
// Возвращаемое значение:
//  Строка - Хэш
Функция ПолучитьХэш(Текст) Экспорт
	
	// Для 1С простейший способ получить уникальный хэш без внешних компонент - это использование ХешированиеДанных
	Хеширование = Новый ХешированиеДанных(ХешФункция.SHA1);
	Хеширование.Добавить(Текст);
	Возврат Строка(Хеширование.ХешСумма);
	
КонецФункции
