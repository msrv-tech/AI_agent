#Область ПрограммныйИнтерфейс

Функция РежимОтладкиJSON(Знач Пользователь = "") Экспорт
	// В этом общем модуле нельзя использовать Перем на уровне модуля,
	// поэтому режим отладки читаем из настроек пользователя.
	Настройки = ПолучитьНастройкиПользователя(Пользователь);
	Если Настройки <> Неопределено И Настройки.Свойство("РежимОтладки") Тогда
		Возврат Настройки.РежимОтладки;
	КонецЕсли;
	Возврат Ложь;
КонецФункции

// Возвращает имя текущего пользователя ИБ или "Администратор" по умолчанию
Функция ИмяТекущегоПользователя() Экспорт
	
	Пользователь = "";
	Попытка
		Пользователь = ПользователиИнформационнойБазы.ТекущийПользователь().Имя;
	Исключение
	КонецПопытки;
	
	Если ПустаяСтрока(Пользователь) Тогда
		Пользователь = "Администратор";
	КонецЕсли;
	
	Возврат Пользователь;
	
КонецФункции

// Получает настройки пользователя из регистра сведений
//
// Параметры:
//  Пользователь - Строка - имя пользователя, для которого получить настройки
	//
	// Возвращаемое значение:
	//  Структура - структура с настройками:
	//   * Provider_BaseURL - Строка
	//   * Provider_ApiKey - Строка
	//   * ЛимитТокеновНаДиалог - Число
	//   * Модель - Строка
	//   * email - Строка
	//
	Функция ПолучитьНастройкиПользователя(Знач Пользователь = "") Экспорт 
		
		Если ПустаяСтрока(Пользователь) Тогда
			Пользователь = ИмяТекущегоПользователя();
		КонецЕсли;
		
		Результат = Новый Структура;
		Результат.Вставить("Provider_BaseUrl", "");
		Результат.Вставить("Provider_ApiKey", "");
		Результат.Вставить("ЛимитТокеновНаДиалог", 0);
		Результат.Вставить("Модель", "");
		Результат.Вставить("email", "");
	Результат.Вставить("РежимОтладки", Ложь);
	// По умолчанию запись разрешена (чтобы не ломать существующее поведение)
	Результат.Вставить("ДоступнаЗапись", Истина);
		
		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ
		|	НастройкиПользователя.Provider_BaseUrl,
		|	НастройкиПользователя.Provider_ApiKey,
		|	НастройкиПользователя.ЛимитТокеновНаДиалог,
		|	НастройкиПользователя.Модель,
	|	НастройкиПользователя.email,
	|	НастройкиПользователя.РежимОтладки,
	|	НастройкиПользователя.ДоступнаЗапись
		|ИЗ
		|	РегистрСведений.ИИА_НастройкиПользователей КАК НастройкиПользователя
		|ГДЕ
		|	НастройкиПользователя.Пользователь = &Пользователь";
		
		Запрос.УстановитьПараметр("Пользователь", Пользователь);
		
		РезультатЗапроса = Запрос.Выполнить();
		
		Если РезультатЗапроса.Пустой() Тогда
			Возврат Результат;
		КонецЕсли;
		
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		
		Результат.Provider_BaseUrl = Выборка.Provider_BaseUrl;
		Результат.Provider_ApiKey = Выборка.Provider_ApiKey;
		Результат.ЛимитТокеновНаДиалог = Выборка.ЛимитТокеновНаДиалог;
		Результат.Модель = Выборка.Модель;
		Результат.email = Выборка.email;
		
		// Выборка результата запроса не поддерживает метод Свойство().
		// Читаем новые поля через Попытка/Исключение для совместимости со старыми версиями регистра.
		Попытка
			Результат.РежимОтладки = Выборка.РежимОтладки;
		Исключение
			Результат.РежимОтладки = Ложь;
		КонецПопытки;
		
		Попытка
			Результат.ДоступнаЗапись = Выборка.ДоступнаЗапись;
		Исключение
			Результат.ДоступнаЗапись = Истина;
		КонецПопытки;
		
		Возврат Результат;
		
	КонецФункции

// Функции для работы с Гигачат перенесены в модуль ИИА_Гигачат

// Находит активный диалог пользователя или создает новый
//
// Параметры:
//  Пользователь - СправочникСсылка.Пользователи - пользователь
//
// Возвращаемое значение:
//  СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
Функция НайтиИлиСоздатьДиалогПользователя(Пользователь) Экспорт
	
	// Ищем активный диалог
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Диалоги.Ссылка
	|ИЗ
	|	Справочник.ИИА_Диалоги КАК Диалоги
	|ГДЕ
	|	Диалоги.Пользователь = &Пользователь
	|	И Диалоги.Активный = ИСТИНА
	|УПОРЯДОЧИТЬ ПО
	|	Диалоги.ДатаСоздания УБЫВ";
	
	Запрос.УстановитьПараметр("Пользователь", Пользователь);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат Выборка.Ссылка;
	КонецЕсли;
	
	// Создаем новый диалог
	НовыйДиалог = Справочники.ИИА_Диалоги.СоздатьЭлемент();
	НовыйДиалог.Пользователь = Пользователь;
	ИмяДиалога = "Диалог ИИ от " + Формат(ТекущаяДата(), "ДФ=dd.MM.yyyy HH:mm:ss");
	НовыйДиалог.Имя = ИмяДиалога;
	НовыйДиалог.Наименование = ИмяДиалога; // Заполняем Наименование для корректного отображения
	НовыйДиалог.ДатаСоздания = ТекущаяДата();
	НовыйДиалог.Активный = Истина;
	НовыйДиалог.ТипДиалога = Перечисления.ИИА_ТипДиалога.Агент;
	НовыйДиалог.Записать();
	
	Возврат НовыйДиалог.Ссылка;
	
КонецФункции

// Деактивирует диалог
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
Процедура ДеактивироватьДиалог(СсылкаДиалога) Экспорт
	
	Попытка
		ДиалогОбъект = СсылкаДиалога.ПолучитьОбъект();
		ДиалогОбъект.Активный = Ложь;
		ДиалогОбъект.Записать();
	Исключение
		// Игнорируем ошибки деактивации
	КонецПопытки;
	
КонецПроцедуры

// Создает новый диалог для текущего пользователя
//
// Возвращаемое значение:
//  СправочникСсылка.ИИА_Диалоги - ссылка на новый диалог
//
Функция СоздатьНовыйДиалог(Пользователь, ТипДиалога = Неопределено) Экспорт
	
	// Деактивируем все активные диалоги пользователя
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	Диалоги.Ссылка
	|ИЗ
	|	Справочник.ИИА_Диалоги КАК Диалоги
	|ГДЕ
	|	Диалоги.Пользователь = &Пользователь
	|	И Диалоги.Активный = ИСТИНА";
	
	Запрос.УстановитьПараметр("Пользователь", Пользователь);
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		Выборка = РезультатЗапроса.Выбрать();
		Пока Выборка.Следующий() Цикл
			ДеактивироватьДиалог(Выборка.Ссылка);
		КонецЦикла;
	КонецЕсли;
	
	// Создаем новый диалог
	НовыйДиалог = Справочники.ИИА_Диалоги.СоздатьЭлемент();
	НовыйДиалог.Пользователь = Пользователь;
	ИмяДиалога = "Диалог ИИ от " + Формат(ТекущаяДата(), "ДФ=dd.MM.yyyy HH:mm:ss");
	НовыйДиалог.Имя = ИмяДиалога;
	НовыйДиалог.Наименование = ИмяДиалога; // Заполняем Наименование
	НовыйДиалог.ДатаСоздания = ТекущаяДата();
	НовыйДиалог.Активный = Истина;
	
	// Устанавливаем тип диалога
	Если ТипДиалога <> Неопределено Тогда
		НовыйДиалог.ТипДиалога = ТипДиалога;
	Иначе
		// По умолчанию - Агент
		НовыйДиалог.ТипДиалога = Перечисления.ИИА_ТипДиалога.Агент;
	КонецЕсли;
	
	НовыйДиалог.Записать();
	
	Возврат НовыйДиалог.Ссылка;
	
КонецФункции

// Получает сообщения диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  Количество - Число - количество последних сообщений (0 - все сообщения)
//
// Возвращаемое значение:
//  Массив - массив структур с сообщениями
//
Функция ПолучитьСообщенияДиалога(СсылкаДиалога, Количество = 0) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	МассивСообщений = Новый Массив;
	
	ИндексНачала = 0;
	Если Количество > 0 Тогда
		ИндексНачала = Макс(0, Диалог.Сообщения.Количество() - Количество);
	КонецЕсли;
	
	Для Индекс = ИндексНачала По Диалог.Сообщения.Количество() - 1 Цикл
		
		Строка = Диалог.Сообщения[Индекс];
		
		СтруктураСообщения = Новый Структура;
		СтруктураСообщения.Вставить("Время", Строка.Время);
		СтруктураСообщения.Вставить("Автор", Строка.Автор);
		СтруктураСообщения.Вставить("ТипСообщения", Строка.ТипСообщения);
		СтруктураСообщения.Вставить("Текст", Строка.Текст);
		СтруктураСообщения.Вставить("ТекстКода", Строка.ТекстКода);
		СтруктураСообщения.Вставить("Статус", Строка.Статус);
		СтруктураСообщения.Вставить("UsageTokens", Строка.UsageTokens);
		СтруктураСообщения.Вставить("СтатусDSL", Строка.СтатусDSL);
		
		МассивСообщений.Добавить(СтруктураСообщения);
		
	КонецЦикла;
	
	Возврат МассивСообщений;
	
КонецФункции

// Получает первое сообщение пользователя из диалога (исходную задачу)
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Структура - структура с информацией о первом сообщении пользователя:
//   * Найдено - Булево - найдено ли сообщение
//   * Текст - Строка - текст сообщения
//
Функция ПолучитьПервоеСообщениеПользователя(СсылкаДиалога) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Найдено", Ложь);
	Результат.Вставить("Текст", "");
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	Если Диалог.Сообщения.Количество() = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Ищем первое сообщение пользователя (исходную задачу)
	Для Индекс = 0 По Диалог.Сообщения.Количество() - 1 Цикл
		
		СтрокаСообщения = Диалог.Сообщения[Индекс];
		
		Если СтрокаСообщения.Автор = Перечисления.ИИА_АвторСообщения.Пользователь Тогда
			Результат.Найдено = Истина;
			Результат.Текст = СтрокаСообщения.Текст;
			Возврат Результат;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Получает последнее сообщение пользователя из диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Структура - структура с информацией о последнем сообщении пользователя:
//   * Найдено - Булево - найдено ли сообщение
//   * Текст - Строка - текст сообщения
//
Функция ПолучитьПоследнееСообщениеПользователя(СсылкаДиалога) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Найдено", Ложь);
	Результат.Вставить("Текст", "");
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	Если Диалог.Сообщения.Количество() = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Ищем последнее сообщение пользователя
	Индекс = Диалог.Сообщения.Количество() - 1;
	Пока Индекс >= 0 Цикл
		
		СтрокаСообщения = Диалог.Сообщения[Индекс];
		
		Если СтрокаСообщения.Автор = Перечисления.ИИА_АвторСообщения.Пользователь Тогда
			Результат.Найдено = Истина;
			Результат.Текст = СтрокаСообщения.Текст;
			Возврат Результат;
		КонецЕсли;
		
		Индекс = Индекс - 1;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Инициализирует план выполнения задачи в диалоге
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Булево - Истина, если план успешно создан
//
Функция ИнициализироватьПлан(СсылкаДиалога) Экспорт
	
	// Получаем исходную задачу
	РезультатЗадачи = ПолучитьПервоеСообщениеПользователя(СсылкаДиалога);
	Если НЕ РезультатЗадачи.Найдено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ТекстЗадачи = РезультатЗадачи.Текст;
	
	// Формируем промпт для создания плана
	ПромптПлана = ИИА_Промты.ПолучитьПромптСозданияПлана(ТекстЗадачи);
	
	// Вызываем ИИ (через системное сообщение)
	ОтветИИ = ВызватьИИССистемнымСообщением(СсылкаДиалога, "Чат", ПромптПлана);
	
	Если ПустаяСтрока(ОтветИИ.Текст) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Парсим JSON массив строк
	Попытка
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ОтветИИ.Текст);
		МассивПланов = ПрочитатьJSON(ЧтениеJSON);
		ЧтениеJSON.Закрыть();
		
		Если ТипЗнч(МассивПланов) <> Тип("Массив") Тогда
			Возврат Ложь;
		КонецЕсли;
		
		// Сохраняем план в диалог
		Диалог = СсылкаДиалога.ПолучитьОбъект();
		Диалог.План.Очистить();
		
		Для Каждого Пункт Из МассивПланов Цикл
			НоваяСтрока = Диалог.План.Добавить();
			НоваяСтрока.Задача = Пункт;
			НоваяСтрока.Выполнена = Ложь;
		КонецЦикла;
		
		Диалог.Записать();
		Возврат Истина;
		
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

// Возвращает массив структур с пунктами плана
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Массив - массив структур (Задача, Выполнена, Результат)
//
Функция ПолучитьПланДиалога(СсылкаДиалога) Экспорт
	
	Результат = Новый Массив;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	План.Задача КАК Задача,
	|	План.Выполнена КАК Выполнена,
	|	План.Результат КАК Результат
	|ИЗ
	|	Справочник.ИИА_Диалоги.План КАК План
	|ГДЕ
	|	План.Ссылка = &Ссылка
	|УПОРЯДОЧИТЬ ПО
	|	План.НомерСтроки";
	
	Запрос.УстановитьПараметр("Ссылка", СсылкаДиалога);
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Результат.Добавить(Новый Структура("Задача, Выполнена, Результат", Выборка.Задача, Выборка.Выполнена, Выборка.Результат));
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Обновляет состояние плана на основе результатов последних действий
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Булево - Истина, если план успешно обновлен
//
Функция ОбновитьПланПоРезультатам(СсылкаДиалога) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	Если Диалог.План.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Преобразуем текущий план в JSON
	МассивПлана = Новый Массив;
	Для Каждого СтрокаПлана Из Диалог.План Цикл
		СтруктураПункта = Новый Структура("Задача, Выполнена, Результат", СтрокаПлана.Задача, СтрокаПлана.Выполнена, СтрокаПлана.Результат);
		МассивПлана.Добавить(СтруктураПункта);
	КонецЦикла;
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, МассивПлана);
	ПланJSON = ЗаписьJSON.Закрыть();
	
	// Собираем результаты последних действий (системные сообщения)
	ТекстРезультатов = "";
	КоличествоСообщений = Диалог.Сообщения.Количество();
	Для Индекс = Макс(0, КоличествоСообщений - 10) По КоличествоСообщений - 1 Цикл
		СтрокаСообщения = Диалог.Сообщения[Индекс];
		Если СтрокаСообщения.Автор = Перечисления.ИИА_АвторСообщения.Система Тогда
			ТекстРезультатов = ТекстРезультатов + Символы.ПС + СтрокаСообщения.Текст;
		ИначеЕсли СтрокаСообщения.Автор = Перечисления.ИИА_АвторСообщения.ИИ И НЕ ПустаяСтрока(СтрокаСообщения.ТекстКода) Тогда
			ТекстРезультатов = ТекстРезультатов + Символы.ПС + "Выполнен DSL: " + СтрокаСообщения.ТекстКода;
		КонецЕсли;
	КонецЦикла;
	
	// Формируем промпт для обновления плана
	ПромптОбновления = ИИА_Промты.ПолучитьПромптОбновленияПлана(ПланJSON, ТекстРезультатов);
	
	// Вызываем ИИ
	ОтветИИ = ВызватьИИССистемнымСообщением(СсылкаДиалога, "Чат", ПромптОбновления);
	
	// Парсим ответ ИИ
	Попытка
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ОтветИИ.Текст);
		ОбновленныйПлан = ПрочитатьJSON(ЧтениеJSON);
		ЧтениеJSON.Закрыть();
		
		Если ТипЗнч(ОбновленныйПлан) <> Тип("Массив") Тогда
			Возврат Ложь;
		КонецЕсли;
		
		// Обновляем ТЧ План в диалоге
		Диалог = СсылкаДиалога.ПолучитьОбъект();
		
		Для Каждого ПунктОбновления Из ОбновленныйПлан Цикл
			// Ищем соответствующий пункт в оригинальном плане по тексту задачи
			Для Каждого СтрокаПлана Из Диалог.План Цикл
				Если СтрокаПлана.Задача = ПунктОбновления.Задача Тогда
					СтрокаПлана.Выполнена = ПунктОбновления.Выполнена;
					СтрокаПлана.Результат = ПунктОбновления.Результат;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		
		Диалог.Записать();
		Возврат Истина;
		
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

// Получает описание следующего невыполненного пункта плана
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Строка - текст задачи или пустая строка
//
Функция ПолучитьСледующийПунктПлана(СсылкаДиалога) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	Для Каждого СтрокаПлана Из Диалог.План Цикл
		Если НЕ СтрокаПлана.Выполнена Тогда
			Возврат СтрокаПлана.Задача;
		КонецЕсли;
	КонецЦикла;
	
	Возврат "";
	
КонецФункции

// Проверяет, завершен ли план
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Булево - Истина, если все пункты выполнены
//
Функция ПланЗавершен(СсылкаДиалога) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	Если Диалог.План.Количество() = 0 Тогда
		Возврат Ложь; // План еще не создан
	КонецЕсли;
	
	Для Каждого СтрокаПлана Из Диалог.План Цикл
		Если НЕ СтрокаПлана.Выполнена Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Получает все невыполненные задачи и уточнения пользователя из диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Структура - структура с информацией о невыполненных задачах:
//   * Найдено - Булево - найдены ли невыполненные задачи
//   * ТекстЗадач - Строка - объединенный текст всех невыполненных задач
//   * КоличествоЗадач - Число - количество невыполненных задач
//
Функция ПолучитьНевыполненныеЗадачиПользователя(СсылкаДиалога) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Найдено", Ложь);
	Результат.Вставить("ТекстЗадач", "");
	Результат.Вставить("КоличествоЗадач", 0);
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	Если Диалог.Сообщения.Количество() = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	МассивЗадач = Новый Массив;
	
	// Проходим по всем сообщениям и собираем задачи пользователя
	Для Каждого СтрокаСообщения Из Диалог.Сообщения Цикл
		
		Если СтрокаСообщения.Автор = Перечисления.ИИА_АвторСообщения.Пользователь Тогда
			// Добавляем задачу в список
			ТекстЗадачи = СокрЛП(СтрокаСообщения.Текст);
			Если НЕ ПустаяСтрока(ТекстЗадачи) Тогда
				МассивЗадач.Добавить(ТекстЗадачи);
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	Если МассивЗадач.Количество() > 0 Тогда
		Результат.Найдено = Истина;
		Результат.КоличествоЗадач = МассивЗадач.Количество();
		
		// Объединяем все задачи в один текст
		ТекстЗадач = "";
		Для Индекс = 0 По МассивЗадач.Количество() - 1 Цикл
			Если Индекс > 0 Тогда
				ТекстЗадач = ТекстЗадач + Символы.ПС;
			КонецЕсли;
			ТекстЗадач = ТекстЗадач + МассивЗадач[Индекс];
		КонецЦикла;
		
		Результат.ТекстЗадач = ТекстЗадач;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Получает последнее DSL сообщение и его статус
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Структура - структура с информацией о последнем DSL сообщении:
//   * Найдено - Булево - найдено ли сообщение
//   * СтатусDSL - ПеречислениеСсылка.ИИА_СтатусDSL - статус DSL
//   * ТекстКода - Строка - текст DSL
//
Функция ПолучитьПоследнееDSLСообщение(СсылкаДиалога) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Найдено", Ложь);
	Результат.Вставить("СтатусDSL", Неопределено);
	Результат.Вставить("ТекстКода", "");
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	Если Диалог.Сообщения.Количество() = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Ищем последнее сообщение с DSL (тип Код)
	Индекс = Диалог.Сообщения.Количество() - 1;
	Пока Индекс >= 0 Цикл
		
		СтрокаСообщения = Диалог.Сообщения[Индекс];
		
		Если СтрокаСообщения.ТипСообщения = Перечисления.ИИА_ТипСообщения.Код 
			И НЕ ПустаяСтрока(СтрокаСообщения.ТекстКода) Тогда
			Результат.Найдено = Истина;
			Результат.СтатусDSL = СтрокаСообщения.СтатусDSL;
			Результат.ТекстКода = СтрокаСообщения.ТекстКода;
			Возврат Результат;
		КонецЕсли;
		
		Индекс = Индекс - 1;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Получает общее количество использованных токенов в диалоге
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Число - общее количество использованных токенов
//
Функция ПолучитьОбщееКоличествоТокенов(СсылкаДиалога) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	ОбщееКоличествоТокенов = 0;
	
	Для Каждого СтрокаСообщения Из Диалог.Сообщения Цикл
		Если ЗначениеЗаполнено(СтрокаСообщения.UsageTokens) Тогда
			ОбщееКоличествоТокенов = ОбщееКоличествоТокенов + СтрокаСообщения.UsageTokens;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ОбщееКоличествоТокенов;
	
КонецФункции

// Получает список ключей из хранилища значений диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Массив - массив строк с ключами хранилища
//
Функция ПолучитьКлючиХранилища(СсылкаДиалога) Экспорт
	
	Результат = Новый Массив;
	
	Попытка
		Диалог = СсылкаДиалога.ПолучитьОбъект();
		
		// Проверяем наличие хранилища
		Если НЕ ЗначениеЗаполнено(Диалог.ХранилищеЗначения) Тогда
			Возврат Результат;
		КонецЕсли;
		
		Хранилище = Диалог.ХранилищеЗначения;
		
		// Получаем структуру из хранилища
		СтруктураДанных = Хранилище.Получить();
		Если ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
			Возврат Результат;
		КонецЕсли;
		
		// Получаем все ключи из структуры
		Для Каждого КлючЗначение Из СтруктураДанных Цикл
			Результат.Добавить(КлючЗначение.Ключ);
		КонецЦикла;
		
	Исключение
		// В случае ошибки возвращаем пустой массив
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Сохраняет результат проверки задачи в хранилище диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  Успех - Булево - результат проверки
//  Причина - Строка - пояснение
//
Процедура УстановитьРезультатПроверкиВХранилище(СсылкаДиалога, Успех, Причина = "") Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	СтруктураПроверки = Новый Структура;
	
	Если ЗначениеЗаполнено(Диалог.ХранилищеЗначения) Тогда
		Попытка
			СтруктураПроверки = Диалог.ХранилищеЗначения.Получить();
		Исключение
			СтруктураПроверки = Новый Структура;
		КонецПопытки;
		Если ТипЗнч(СтруктураПроверки) <> Тип("Структура") Тогда
			СтруктураПроверки = Новый Структура;
		КонецЕсли;
	КонецЕсли;
	
	СтруктураПроверки.Вставить("ПроверкаВыполнена", Истина);
	СтруктураПроверки.Вставить("СтатусПроверкиЗадачи", ?(Успех, "Успешно", "Неудачно"));
	СтруктураПроверки.Вставить("ПричинаПроверки", ?(ПустаяСтрока(Причина), "", Причина));
	
	ХранилищеЗначения = Новый ХранилищеЗначения(СтруктураПроверки);
	Диалог.ХранилищеЗначения = ХранилищеЗначения;
	Диалог.Записать();
	
КонецПроцедуры

// Возвращает структуру с результатам проверки из хранилища диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Структура с полями ПроверкаВыполнена, СтатусПроверкиЗадачи, ПричинаПроверки
//
Функция ПолучитьРезультатПроверкиИзХранилища(СсылкаДиалога) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	Если НЕ ЗначениеЗаполнено(Диалог.ХранилищеЗначения) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Диалог.ХранилищеЗначения.Получить();
	Если ТипЗнч(Результат) <> Тип("Структура") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если НЕ Результат.Свойство("ПроверкаВыполнена") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Добавляет ссылки на объекты в табличную часть ИзмененныеОбъекты диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  МассивСсылок - Массив - массив ссылок на объекты
//
Процедура ДобавитьИзмененныеОбъекты(СсылкаДиалога, МассивСсылок) Экспорт
	
	Если МассивСсылок = Неопределено ИЛИ МассивСсылок.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	// Добавляем каждую ссылку, если её еще нет в табличной части
	Для Каждого СсылкаОбъекта Из МассивСсылок Цикл
		
		Если НЕ ЗначениеЗаполнено(СсылкаОбъекта) Тогда
			Продолжить;
		КонецЕсли;
		
		// Проверяем, есть ли уже такая ссылка в табличной части
		Найдено = Ложь;
		Для Каждого СтрокаИзмененныхОбъектов Из Диалог.ИзмененныеОбъекты Цикл
			Если ЗначениеЗаполнено(СтрокаИзмененныхОбъектов.СсылкаНаОбъект) Тогда
				Попытка
					Если СтрокаИзмененныхОбъектов.СсылкаНаОбъект = СсылкаОбъекта Тогда
						Найдено = Истина;
						Прервать;
					КонецЕсли;
				Исключение
					// Игнорируем ошибки сравнения
				КонецПопытки;
			КонецЕсли;
		КонецЦикла;
		
		// Если ссылки еще нет, добавляем её
		Если НЕ Найдено Тогда
			НоваяСтрока = Диалог.ИзмененныеОбъекты.Добавить();
			НоваяСтрока.СсылкаНаОбъект = СсылкаОбъекта;
		КонецЕсли;
		
	КонецЦикла;
	
	Диалог.Записать();
	
КонецПроцедуры

// Преобразует массив сообщений в таблицу значений для передачи в ИИ
//
// Параметры:
//  МассивСообщений - Массив - массив структур с сообщениями
//
// Возвращаемое значение:
//  ТаблицаЗначений - таблица значений с историей сообщений
//
Функция ПреобразоватьМассивСообщенийВТаблицу(МассивСообщений)
	
	История = Новый ТаблицаЗначений;
	История.Колонки.Добавить("Время", Новый ОписаниеТипов("Дата"));
	История.Колонки.Добавить("Автор", Новый ОписаниеТипов("ПеречислениеСсылка.ИИА_АвторСообщения"));
	История.Колонки.Добавить("ТипСообщения", Новый ОписаниеТипов("ПеречислениеСсылка.ИИА_ТипСообщения"));
	История.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка"));
	История.Колонки.Добавить("ТекстКода", Новый ОписаниеТипов("Строка"));
	
	Для Каждого СтруктураСообщения Из МассивСообщений Цикл
		
		НоваяСтрока = История.Добавить();
		НоваяСтрока.Время = СтруктураСообщения.Время;
		НоваяСтрока.Автор = СтруктураСообщения.Автор;
		НоваяСтрока.ТипСообщения = СтруктураСообщения.ТипСообщения;
		НоваяСтрока.Текст = СтруктураСообщения.Текст;
		
	КонецЦикла;
	
	Возврат История;
	
КонецФункции

// Добавляет сообщение в диалог
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  Автор - ПеречислениеСсылка.ИИА_АвторСообщения - автор сообщения
//  ТипСообщения - ПеречислениеСсылка.ИИА_ТипСообщения - тип сообщения
//  Текст - Строка - текст сообщения
//  ТекстКода - Строка - текст кода (для запросов)
//  Статус - Строка - статус сообщения
//  UsageTokens - Число - количество использованных токенов
//  СтатусDSL - ПеречислениеСсылка.ИИА_СтатусDSL - статус DSL
//
Процедура ДобавитьСообщениеВДиалог(СсылкаДиалога, Автор, ТипСообщения, Текст, ТекстКода = "", Статус = "", UsageTokens = 0, СтатусDSL = Неопределено) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	НоваяСтрока = Диалог.Сообщения.Добавить();
	НоваяСтрока.Время = ТекущаяДата();
	НоваяСтрока.Автор = Автор;
	НоваяСтрока.ТипСообщения = ТипСообщения;
	НоваяСтрока.Текст = Текст;
	НоваяСтрока.ТекстКода = ТекстКода;
	НоваяСтрока.Статус = Статус;
	НоваяСтрока.UsageTokens = UsageTokens;
	
	// Устанавливаем статус DSL
	Если СтатусDSL = Неопределено Тогда
		// Если есть ТекстКода и это DSL, устанавливаем "ВОчереди", иначе оставляем пустым
		Если НЕ ПустаяСтрока(ТекстКода) И ТипСообщения = Перечисления.ИИА_ТипСообщения.Код Тогда
			НоваяСтрока.СтатусDSL = Перечисления.ИИА_СтатусDSL.ВОчереди;
		Иначе
			// Для не-DSL сообщений статус не устанавливаем (остается пустым)
			НоваяСтрока.СтатусDSL = Неопределено;
		КонецЕсли;
	Иначе
		НоваяСтрока.СтатусDSL = СтатусDSL;
	КонецЕсли;
	
	Диалог.Записать();
	
	// ДУБЛИРУЕМ В ЛОГ
	ЗаписьЛога = "[" + Формат(НоваяСтрока.Время, "ДЛФ=DT") + "] [" + Строка(Автор) + "]";
	Если НЕ ПустаяСтрока(Текст) Тогда
		ЗаписьЛога = ЗаписьЛога + Символы.ПС + Текст;
	КонецЕсли;
	Если НЕ ПустаяСтрока(ТекстКода) Тогда
		ЗаписьЛога = ЗаписьЛога + Символы.ПС + "Код:" + Символы.ПС + ТекстКода;
	КонецЕсли;
	ЗаписьЛога = ЗаписьЛога + Символы.ПС + "---";
	
	ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, ЗаписьЛога);
	
КонецПроцедуры

// Функции для вызова ИИ перенесены в модуль ИИА_Провайдеры
// Функции для работы с Гигачат перенесены в модуль ИИА_Гигачат

// Функции СформироватьПромптДляИИ и РаспознатьОтветИИ перенесены в модуль ИИА_Провайдеры

Функция ПолучитьСправкуЗапросовПоОшибке(ТекстОшибки)
	
	ТекстВРег = ВРег(Строка(ТекстОшибки));
	Справка = "";
	
	// Минимальный «якорь», чтобы у модели всегда был контекст базового синтаксиса
	Справка = Справка + ИИА_СправкаЗапросы1С.ПолучитьСправкуОсновныеКонструкции() + Символы.ПС + Символы.ПС;
	
	Если СтрНайти(ТекстВРег, "СОЕДИНЕНИ") > 0 ИЛИ СтрНайти(ТекстВРег, "JOIN") > 0 Тогда
		Справка = Справка + ИИА_СправкаЗапросы1С.ПолучитьСправкуОператорыСоединения() + Символы.ПС + Символы.ПС;
	КонецЕсли;
	
	Если СтрНайти(ТекстВРег, "ПОДОБНО") > 0 
		ИЛИ СтрНайти(ТекстВРег, "LIKE") > 0
		ИЛИ СтрНайти(ТекстВРег, "СТРНАЙТИ") > 0
		ИЛИ СтрНайти(ТекстВРег, "НАЙТИ(") > 0 Тогда
		Справка = Справка + ИИА_СправкаЗапросы1С.ПолучитьСправкуФункцииСтрок() + Символы.ПС + Символы.ПС;
		Справка = Справка + ИИА_СправкаЗапросы1С.ПолучитьСправкуОператорыСравнения() + Символы.ПС + Символы.ПС;
	КонецЕсли;
	
	Если СтрНайти(ТекстВРег, "ПАРАМЕТР") > 0 ИЛИ СтрНайти(ТекстВРег, "&") > 0 Тогда
		Справка = Справка + ИИА_СправкаЗапросы1С.ПолучитьСправкуПараметры() + Символы.ПС + Символы.ПС;
	КонецЕсли;
	
	Если СтрНайти(ТекстВРег, "ДАТА") > 0 ИЛИ СтрНайти(ТекстВРег, "ПЕРИОД") > 0 Тогда
		Справка = Справка + ИИА_СправкаЗапросы1С.ПолучитьСправкуФункцииДаты() + Символы.ПС + Символы.ПС;
	КонецЕсли;
	
	Справка = Справка + ИИА_СправкаЗапросы1С.ПолучитьСправкуВажныеПравила();
	
	Возврат Справка;
	
КонецФункции

// Исправляет DSL-сценарий через ИИ при ошибке выполнения (использует обычную функцию ВызватьИИ)
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  ТекстОшибки - Строка - текст ошибки
//  ИсходныйDSL - Строка - исходный DSL-сценарий
//
// Возвращаемое значение:
//  Структура - структура ответа от ВызватьИИ (содержит DSL в поле DSL или Текст)
//
Функция ИсправитьDSLЧерезИИ(СсылкаДиалога, ТекстОшибки, ИсходныйDSL) Экспорт
	
	// Дополняем текст ошибки справкой, если это ошибка запроса
	ТекстОшибкиСКонтекстом = ТекстОшибки;
	
	// Если ошибка связана с запросом или синтаксисом
	Если СтрНайти(ТекстОшибки, "RunQuery") > 0 
		ИЛИ СтрНайти(ТекстОшибки, "Запрос") > 0 
		ИЛИ СтрНайти(ТекстОшибки, "Синтаксическая ошибка") > 0 Тогда
		
		// Если ошибка "Поле не найдено" - подсказываем получить метаданные
		Если СтрНайти(ТекстОшибки, "Поле не найдено") > 0 Тогда
			ТекстОшибкиСКонтекстом = ТекстОшибкиСКонтекстом + Символы.ПС +
			"СОВЕТ: Возможно, ты используешь неверные имена полей. Сначала выполни GetObjectFields, чтобы узнать точную структуру.";
		Иначе
			// Иначе подмешиваем релевантную справку по синтаксису (не всю целиком)
			ТекстОшибкиСКонтекстом = ТекстОшибкиСКонтекстом + Символы.ПС + Символы.ПС +
			"ДЛЯ ИСПРАВЛЕНИЯ ОШИБКИ ИСПОЛЬЗУЙ ОФИЦИАЛЬНУЮ СПРАВКУ ПО ЯЗЫКУ ЗАПРОСОВ 1С:" + Символы.ПС +
			ПолучитьСправкуЗапросовПоОшибке(ТекстОшибки);
		КонецЕсли;
		
	КонецЕсли;
	
	// Формируем промпт для исправления
	ПромптИсправления = ИИА_Промты.СформироватьПромптИсправленияDSL(ТекстОшибкиСКонтекстом, ИсходныйDSL);
	
	// Вызываем ИИ с системным сообщением (не от пользователя)
	Возврат ВызватьИИССистемнымСообщением(СсылкаДиалога, "Чат", ПромптИсправления);
	
КонецФункции

// Вызывает ИИ с системным сообщением (не от пользователя)
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстСистемногоСообщения - Строка - текст системного сообщения
//  СистемныйПромпт - Строка - (опционально) переопределение системного промпта
//
// Возвращаемое значение:
//  Структура - структура ответа от ВызватьИИ
//
Функция ВызватьИИССистемнымСообщением(СсылкаДиалога, ТипСообщения, ТекстСистемногоСообщения, СистемныйПромпт = "") Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	Пользователь = Диалог.Пользователь;
	
	// Получаем настройки пользователя
	Настройки = ПолучитьНастройкиПользователя(Пользователь);
	Настройки.Вставить("Пользователь", Пользователь);
	Настройки.Вставить("ТипДиалога", Диалог.ТипДиалога);
	
	// Ожидаемый формат ответа зависит от типа системного сообщения (планирование vs DSL)
	// По умолчанию: hard DSL mode
	Настройки.Вставить("ExpectedResponseFormat", "dsl");
	// ВАЖНО: комбинированный формат проверяем ПЕРВЫМ, иначе он может ошибочно
	// сработать как "массив строк" из-за подстрок в примерах/контексте.
	Если СтрНайти(ТекстСистемногоСообщения, """updated_plan""") > 0 И СтрНайти(ТекстСистемногоСообщения, """next_step_dsl""") > 0 Тогда
		Настройки.ExpectedResponseFormat = "plan_and_next_dsl";
	ИначеЕсли СтрНайти(ТекстСистемногоСообщения, "ИСКЛЮЧИТЕЛЬНО валидным JSON массивом строк") > 0 Тогда
		Настройки.ExpectedResponseFormat = "plan_json_array";
	КонецЕсли;
	
	// Загружаем историю диалога
	МассивИстории = ПолучитьСообщенияДиалога(СсылкаДиалога, 10);
	
	// Преобразуем массив в таблицу значений для функции ВызватьИИ
	История = ПреобразоватьМассивСообщенийВТаблицу(МассивИстории);
	
	// Добавляем системное сообщение (не от пользователя)
	ДобавитьСообщениеВДиалог(
		СсылкаДиалога,
		Перечисления.ИИА_АвторСообщения.Система,
		Перечисления.ИИА_ТипСообщения.Текст,
		ТекстСистемногоСообщения
	);
	
	// Вызываем ИИ (передаем системное сообщение как текст пользователя для ИИ, но в диалоге оно сохранено как системное)
	ОтветИИ = ИИА_Провайдеры.ВызватьИИ(ТипСообщения, ТекстСистемногоСообщения, История, Настройки, СистемныйПромпт);
	
	// Добавляем промпт в ответ для вывода в лог на клиенте
	Если ОтветИИ.Свойство("Промпт") Тогда
		// Промпт уже добавлен в ответ от ИИ
	Иначе
		ОтветИИ.Вставить("Промпт", "");
	КонецЕсли;
	
	// Определяем тип ответа для хранения
	Если ОтветИИ.ТипОтвета = "Ошибка" ИЛИ ОтветИИ.ТипОтвета = "ОшибкаКонтракта" Тогда
		
		// В лог диалога пишем сырой ответ модели (если есть), даже если он не DSL
		Если ОтветИИ.Свойство("RawModelText") И НЕ ПустаяСтрока(Строка(ОтветИИ.RawModelText)) Тогда
			ДобавитьСообщениеВДиалог(
				СсылкаДиалога,
				Перечисления.ИИА_АвторСообщения.ИИ,
				Перечисления.ИИА_ТипСообщения.Текст,
				Строка(ОтветИИ.RawModelText)
			);
		КонецЕсли;
		
		// Ошибку контракта/провайдера пишем как системную ошибку (чтобы не путать «что ответила модель» и «что мы не приняли»)
		ТекстОшибкиСообщение = ОтветИИ.Текст;
		Если ОтветИИ.Свойство("Ошибки") И НЕ ПустаяСтрока(Строка(ОтветИИ.Ошибки)) Тогда
			ТекстОшибкиСообщение = ТекстОшибкиСообщение + Символы.ПС + "Детали: " + Строка(ОтветИИ.Ошибки);
		КонецЕсли;
		ДобавитьСообщениеВДиалог(
			СсылкаДиалога,
			Перечисления.ИИА_АвторСообщения.Система,
			Перечисления.ИИА_ТипСообщения.Ошибка,
			ТекстОшибкиСообщение
		);
		
		Возврат ОтветИИ;
	ИначеЕсли ОтветИИ.ТипОтвета = "Запрос" Тогда
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Запрос;
		ТекстОтвета = ОтветИИ.Текст;
		ТекстКодаОтвета = ОтветИИ.Запрос;
	ИначеЕсли ОтветИИ.ТипОтвета = "DSL" Тогда
		// Обрабатываем DSL-сценарий
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Код;
		ТекстОтвета = ОтветИИ.Текст;
		// Получаем DSL из ответа
		Если ОтветИИ.Свойство("DSL") И НЕ ПустаяСтрока(ОтветИИ.DSL) Тогда
			ТекстКодаОтвета = ОтветИИ.DSL;
		Иначе
			ТекстКодаОтвета = "";
		КонецЕсли;
		
	Иначе
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Текст;
		ТекстОтвета = ОтветИИ.Текст;
		ТекстКодаОтвета = "";
	КонецЕсли;
	
	// Получаем UsageTokens
	UsageTokens = 0;
	Если ОтветИИ.Свойство("Usage") И ОтветИИ.Usage <> Неопределено Тогда
		Если ТипЗнч(ОтветИИ.Usage) = Тип("Структура") И ОтветИИ.Usage.Свойство("TotalTokens") Тогда
			UsageTokens = ОтветИИ.Usage.TotalTokens;
		КонецЕсли;
	КонецЕсли;
	
	// Определяем статус DSL для сообщения (пока ставим "ВОчереди", потом обновим после выполнения)
	СтатусDSLСообщения = Неопределено;
	Если ОтветИИ.ТипОтвета = "DSL" И (НЕ ПустаяСтрока(ТекстКодаОтвета) ИЛИ НЕ ПустаяСтрока(ОтветИИ.DSL)) Тогда
		СтатусDSLСообщения = Перечисления.ИИА_СтатусDSL.ВОчереди;
	КонецЕсли;
	
	// Добавляем ответ ИИ
	ДобавитьСообщениеВДиалог(
		СсылкаДиалога,
		Перечисления.ИИА_АвторСообщения.ИИ,
		ТипСообщенияОтвета,
		ТекстОтвета,
		ТекстКодаОтвета,
		"",
		UsageTokens,
		СтатусDSLСообщения
	);
	
	// Обрабатываем DSL-сценарий (если это DSL)
	Если ОтветИИ.ТипОтвета = "DSL" И НЕ ПустаяСтрока(ОтветИИ.DSL) Тогда
		
		// Выполняем DSL (сообщения уже добавлены в диалог)
		ТолькоЧтение = (СсылкаДиалога.ТипДиалога = Перечисления.ИИА_ТипДиалога.Запрос1С);
		Если Настройки.Свойство("ДоступнаЗапись") И НЕ Настройки.ДоступнаЗапись Тогда
			ТолькоЧтение = Истина;
		КонецЕсли;
		РезультатDSL = ИИА_DSL.ВыполнитьDSL(ОтветИИ.DSL, СсылкаДиалога, ТолькоЧтение);
		
		Если РезультатDSL.Успех Тогда
			ОбновитьСтатусDSLВПоследнемСообщении(СсылкаДиалога, Перечисления.ИИА_СтатусDSL.ОбработанУспешно);
			
			// Формируем системный ответ для ИИ (JSON)
			Если РезультатDSL.Свойство("СистемныйОтвет") И НЕ ПустаяСтрока(РезультатDSL.СистемныйОтвет) Тогда
				ТекстСистемногоСообщения = РезультатDSL.СистемныйОтвет;
			Иначе
				ТекстСистемногоСообщения = "{""kind"":""dsl_system_result"",""schema_version"":1,""success"":false,""error"":""Системный ответ DSL пуст""}";
			КонецЕсли;
			
			ДобавитьСообщениеВДиалог(
				СсылкаДиалога,
				Перечисления.ИИА_АвторСообщения.Система,
				Перечисления.ИИА_ТипСообщения.Текст,
				СокрЛП(ТекстСистемногоСообщения),
				"",
				"",
				0
			);
			
			// Добавляем ссылки на объекты
			Если РезультатDSL.Свойство("СсылкиОбъектов") И РезультатDSL.СсылкиОбъектов.Количество() > 0 Тогда
				МассивСсылок = РезультатDSL.СсылкиОбъектов;
				
				// Сохраняем ссылки в табличную часть ИзмененныеОбъекты
				ДобавитьИзмененныеОбъекты(СсылкаДиалога, МассивСсылок);
				
				ТекстСсылок = "";
				Если МассивСсылок.Количество() = 1 Тогда
					ТекстСсылок = "Объект: " + МассивСсылок[0];
				Иначе
					ТекстСсылок = "Создано/изменено объектов: " + Формат(МассивСсылок.Количество(), "ЧН=0");
					Для Каждого СсылкаОбъекта Из МассивСсылок Цикл
						ТекстСсылок = ТекстСсылок + Символы.ПС + "- " + СсылкаОбъекта;
					КонецЦикла;
				КонецЕсли;
				
				ДобавитьСообщениеВДиалог(
					СсылкаДиалога,
					Перечисления.ИИА_АвторСообщения.Система,
					Перечисления.ИИА_ТипСообщения.Текст,
					ТекстСсылок,
					"",
					"",
					0
				);
			КонецЕсли;
			
		Иначе
			ОбновитьСтатусDSLВПоследнемСообщении(СсылкаДиалога, Перечисления.ИИА_СтатусDSL.ОбработанСОшибкой);
			
			Если РезультатDSL.Свойство("СистемныйОтвет") И НЕ ПустаяСтрока(РезультатDSL.СистемныйОтвет) Тогда
				ТекстОшибки = РезультатDSL.СистемныйОтвет;
			Иначе
				ТекстОшибки = "{""kind"":""dsl_system_result"",""schema_version"":1,""success"":false,""error"":""Ошибка выполнения DSL: " + РезультатDSL.Сообщение + """}";
			КонецЕсли;
			ДобавитьСообщениеВДиалог(
				СсылкаДиалога,
				Перечисления.ИИА_АвторСообщения.Система,
				Перечисления.ИИА_ТипСообщения.Ошибка,
				ТекстОшибки,
				"",
				"",
				0
			);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ОтветИИ;
	
КонецФункции

// Получает пример DSL-сценария (заглушка для демонстрации)
//
// Параметры:
//  ТекстПользователя - Строка - текст команды пользователя
//
// Возвращаемое значение:
//  Строка - JSON с DSL-сценарием
//
Функция ПолучитьПримерDSLСценария(ТекстПользователя)
	
	// Это заглушка - в реальной реализации ИИ должен генерировать DSL на основе команды пользователя
	// и метаданных конфигурации
	
	ПримерСценария = Новый Структура;
	ПримерСценария.Вставить("dsl_version", 1);
	
	Шаги = Новый Массив;
	
	// Пример: создание элемента справочника
	Если СтрНайти(ВРег(ТекстПользователя), "КОНТРАГЕНТ") > 0 Тогда
		
		Шаг1 = Новый Структура;
		Шаг1.Вставить("action", "CreateReference");
		Шаг1.Вставить("object_name", "Контрагенты");
		Шаги.Добавить(Шаг1);
		
		Шаг2 = Новый Структура;
		Шаг2.Вставить("action", "SetField");
		Шаг2.Вставить("field", "Наименование");
		Шаг2.Вставить("value", "Новый контрагент");
		Шаги.Добавить(Шаг2);
		
		Шаг3 = Новый Структура;
		Шаг3.Вставить("action", "Write");
		Шаги.Добавить(Шаг3);
		
	Иначе
		
		// Общий пример
		Шаг1 = Новый Структура;
		Шаг1.Вставить("action", "ShowInfo");
		Шаг1.Вставить("message", "Пример DSL-сценария. Настройте ИИ для генерации реальных сценариев.");
		Шаги.Добавить(Шаг1);
		
	КонецЕсли;
	
	ПримерСценария.Вставить("steps", Шаги);
	
	// Преобразуем в JSON
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, ПримерСценария);
	JSONСтрока = ЗаписьJSON.Закрыть();
	
	Возврат JSONСтрока;
	
КонецФункции

// Отправляет сообщение и получает ответ от ИИ
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//
// Возвращаемое значение:
//  Структура - структура ответа от ВызватьИИ
//
Функция ОтправитьСообщениеСервера(СсылкаДиалога, ТипСообщения, ТекстПользователя) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	Пользователь = Диалог.Пользователь;
	
	// Обновляем наименование диалога по первому сообщению пользователя (если имя стандартное)
	СтандартноеИмя = "Диалог ИИ от ";
	Если Лев(Диалог.Имя, СтрДлина(СтандартноеИмя)) = СтандартноеИмя И НЕ ПустаяСтрока(ТекстПользователя) Тогда
		// Формируем новое имя из текста пользователя
		НовоеИмя = СокрЛП(ТекстПользователя);
		// Заменяем переносы строк на пробелы
		НовоеИмя = СтрЗаменить(НовоеИмя, Символы.ПС, " ");
		НовоеИмя = СтрЗаменить(НовоеИмя, Символы.ВТаб, " ");
		
		// Ограничиваем длину (безопасно берем 50 символов, чтобы не превысить типичные ограничения)
		Если СтрДлина(НовоеИмя) > 50 Тогда
			НовоеИмя = Лев(НовоеИмя, 47) + "...";
		КонецЕсли;
		
		Диалог.Имя = НовоеИмя;
		Диалог.Записать();
	КонецЕсли;
	
	// Если передан ТипДиалога (перечисление), обновляем его в диалоге и используем
	Если ТипЗнч(ТипСообщения) = Тип("ПеречислениеСсылка.ИИА_ТипДиалога") Тогда
		Если Диалог.ТипДиалога <> ТипСообщения Тогда
			Диалог.ТипДиалога = ТипСообщения;
			Диалог.Записать();
		КонецЕсли;
	КонецЕсли;
	
	// Получаем настройки пользователя
	Настройки = ПолучитьНастройкиПользователя(Пользователь);
	Настройки.Вставить("Пользователь", Пользователь);
	Настройки.Вставить("ТипДиалога", Диалог.ТипДиалога);
	
	// Загружаем историю диалога
	МассивИстории = ПолучитьСообщенияДиалога(СсылкаДиалога, 10);
	
	// Преобразуем массив в таблицу значений для функции ВызватьИИ
	История = ПреобразоватьМассивСообщенийВТаблицу(МассивИстории);
	
	// Определяем тип сообщения для хранения
	Если ТипСообщения = "Запрос" Тогда
		ТипСообщенияДляХранения = Перечисления.ИИА_ТипСообщения.Запрос;
	Иначе
		ТипСообщенияДляХранения = Перечисления.ИИА_ТипСообщения.Текст;
	КонецЕсли;
	
	// Добавляем сообщение пользователя
	ДобавитьСообщениеВДиалог(
		СсылкаДиалога,
		Перечисления.ИИА_АвторСообщения.Пользователь,
		ТипСообщенияДляХранения,
		ТекстПользователя
	);

	// ПЛАНИРОВАНИЕ: Если это режим Агента или Запроса, мы должны сначала спланировать.
	// Очищаем старый план, так как пришло новое сообщение от пользователя.
	Если Диалог.ТипДиалога = Перечисления.ИИА_ТипДиалога.Агент ИЛИ Диалог.ТипДиалога = Перечисления.ИИА_ТипДиалога.Запрос1С Тогда
		Диалог = СсылкаДиалога.ПолучитьОбъект();
		Диалог.План.Очистить();
		Диалог.Записать();
		
		// Возвращаем пустой результат, чтобы клиент запустил оркестратор (планирование)
		Результат = Новый Структура;
		Результат.Вставить("ТипОтвета", "Текст");
		Результат.Вставить("Текст", "Запрос принят. Начинаю планирование...");
		Результат.Вставить("Usage", Новый Структура("TotalTokens", 0));
		Возврат Результат;
	КонецЕсли;

	// Очищаем результат проверки задачи
	СброситьРезультатПроверкиВХранилище(СсылкаДиалога);
	
	// Вызываем ИИ (только для обычных чатов, где нет принудительного планирования)
	ОтветИИ = ИИА_Провайдеры.ВызватьИИ(ТипСообщения, ТекстПользователя, История, Настройки);
	
	// Добавляем промпт в ответ для вывода в лог на клиенте
	Если ОтветИИ.Свойство("Промпт") Тогда
		// Промпт уже добавлен в ответ от ИИ
	Иначе
		ОтветИИ.Вставить("Промпт", "");
	КонецЕсли;
	
	// Определяем тип ответа для хранения
	Если ОтветИИ.ТипОтвета = "Ошибка" ИЛИ ОтветИИ.ТипОтвета = "ОшибкаКонтракта" Тогда
		
		// В лог диалога пишем сырой ответ модели (если есть), даже если он не DSL
		Если ОтветИИ.Свойство("RawModelText") И НЕ ПустаяСтрока(Строка(ОтветИИ.RawModelText)) Тогда
			ДобавитьСообщениеВДиалог(
				СсылкаДиалога,
				Перечисления.ИИА_АвторСообщения.ИИ,
				Перечисления.ИИА_ТипСообщения.Текст,
				Строка(ОтветИИ.RawModelText)
			);
		КонецЕсли;
		
		ТекстОшибкиСообщение = ОтветИИ.Текст;
		Если ОтветИИ.Свойство("Ошибки") И НЕ ПустаяСтрока(Строка(ОтветИИ.Ошибки)) Тогда
			ТекстОшибкиСообщение = ТекстОшибкиСообщение + Символы.ПС + "Детали: " + Строка(ОтветИИ.Ошибки);
		КонецЕсли;
		
		ДобавитьСообщениеВДиалог(
			СсылкаДиалога,
			Перечисления.ИИА_АвторСообщения.Система,
			Перечисления.ИИА_ТипСообщения.Ошибка,
			ТекстОшибкиСообщение
		);
		
		Возврат ОтветИИ;
	ИначеЕсли ОтветИИ.ТипОтвета = "Запрос" Тогда
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Запрос;
		ТекстОтвета = ОтветИИ.Текст;
		ТекстКодаОтвета = ОтветИИ.Запрос;
	ИначеЕсли ОтветИИ.ТипОтвета = "DSL" Тогда
		// Обрабатываем DSL-сценарий
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Код;
		ТекстОтвета = ОтветИИ.Текст;
		// Получаем DSL из ответа
		Если ОтветИИ.Свойство("DSL") И НЕ ПустаяСтрока(ОтветИИ.DSL) Тогда
			ТекстКодаОтвета = ОтветИИ.DSL;
		Иначе
			ТекстКодаОтвета = "";
		КонецЕсли;
		
	Иначе
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Текст;
		ТекстОтвета = ОтветИИ.Текст;
		ТекстКодаОтвета = "";
	КонецЕсли;
	
	// Получаем UsageTokens
	UsageTokens = 0;
	Если ОтветИИ.Свойство("Usage") И ОтветИИ.Usage <> Неопределено Тогда
		Если ТипЗнч(ОтветИИ.Usage) = Тип("Структура") И ОтветИИ.Usage.Свойство("TotalTokens") Тогда
			UsageTokens = ОтветИИ.Usage.TotalTokens;
		КонецЕсли;
	КонецЕсли;
	
	// Определяем статус DSL для сообщения (пока ставим "ВОчереди", потом обновим после выполнения)
	СтатусDSLСообщения = Неопределено;
	Если ОтветИИ.ТипОтвета = "DSL" И (НЕ ПустаяСтрока(ТекстКодаОтвета) ИЛИ НЕ ПустаяСтрока(ОтветИИ.DSL)) Тогда
		СтатусDSLСообщения = Перечисления.ИИА_СтатусDSL.ВОчереди;
	КонецЕсли;
	
	// Сначала добавляем ответ ИИ
	ДобавитьСообщениеВДиалог(
		СсылкаДиалога,
		Перечисления.ИИА_АвторСообщения.ИИ,
		ТипСообщенияОтвета,
		ТекстОтвета,
		ТекстКодаОтвета,
		"",
		UsageTokens,
		СтатусDSLСообщения
	);
	
		// Теперь обрабатываем DSL-сценарий (если это DSL)
		Если ОтветИИ.ТипОтвета = "DSL" И НЕ ПустаяСтрока(ОтветИИ.DSL) Тогда
			
			// Выполняем DSL
			РезультатDSL = ВыполнитьDSLСценарий(ОтветИИ.DSL, СсылкаДиалога);
		
		// Добавляем информацию о результате DSL в ответ для клиента
		ОтветИИ.Вставить("РезультатDSL", РезультатDSL);
		ОтветИИ.Вставить("DSLJSON", ОтветИИ.DSL);
		
		// Базовая обработка результата (статус и сообщения об успехе/ошибке)
		Если РезультатDSL.Успех Тогда
			ОбновитьСтатусDSLВПоследнемСообщении(СсылкаДиалога, Перечисления.ИИА_СтатусDSL.ОбработанУспешно);
			
			// Формируем системный ответ для ИИ
			// Формируем системный ответ для ИИ (JSON)
			Если РезультатDSL.Свойство("СистемныйОтвет") И НЕ ПустаяСтрока(РезультатDSL.СистемныйОтвет) Тогда
				ТекстСистемногоСообщения = РезультатDSL.СистемныйОтвет;
			Иначе
				ТекстСистемногоСообщения = "{""kind"":""dsl_system_result"",""schema_version"":1,""success"":false,""error"":""Системный ответ DSL пуст""}";
			КонецЕсли;
			
			ДобавитьСообщениеВДиалог(
				СсылкаДиалога,
				Перечисления.ИИА_АвторСообщения.Система,
				Перечисления.ИИА_ТипСообщения.Текст,
				СокрЛП(ТекстСистемногоСообщения),
				"",
				"",
				0
			);
			
			// Добавляем ссылки на объекты
			Если РезультатDSL.Свойство("СсылкиОбъектов") И РезультатDSL.СсылкиОбъектов.Количество() > 0 Тогда
				МассивСсылок = РезультатDSL.СсылкиОбъектов;
				
				// Сохраняем ссылки в табличную часть ИзмененныеОбъекты
				ДобавитьИзмененныеОбъекты(СсылкаДиалога, МассивСсылок);
				
				ТекстСсылок = "";
				Если МассивСсылок.Количество() = 1 Тогда
					ТекстСсылок = "Объект: " + МассивСсылок[0];
				Иначе
					ТекстСсылок = "Создано/изменено объектов: " + Формат(МассивСсылок.Количество(), "ЧН=0");
					Для Каждого СсылкаОбъекта Из МассивСсылок Цикл
						ТекстСсылок = ТекстСсылок + Символы.ПС + "- " + СсылкаОбъекта;
					КонецЦикла;
				КонецЕсли;
				
				ДобавитьСообщениеВДиалог(
					СсылкаДиалога,
					Перечисления.ИИА_АвторСообщения.Система,
					Перечисления.ИИА_ТипСообщения.Текст,
					ТекстСсылок,
					"",
					"",
					0
				);
			КонецЕсли;
			
			// Проверка результата выполнения задачи будет выполнена на клиенте
			// Результат DSL передается клиенту для обработки итераций
			
		Иначе
			ОбновитьСтатусDSLВПоследнемСообщении(СсылкаДиалога, Перечисления.ИИА_СтатусDSL.ОбработанСОшибкой);
			
			Если РезультатDSL.Свойство("СистемныйОтвет") И НЕ ПустаяСтрока(РезультатDSL.СистемныйОтвет) Тогда
				ТекстОшибки = РезультатDSL.СистемныйОтвет;
			Иначе
				ТекстОшибки = "{""kind"":""dsl_system_result"",""schema_version"":1,""success"":false,""error"":""Ошибка выполнения DSL: " + РезультатDSL.Сообщение + """}";
			КонецЕсли;
			ДобавитьСообщениеВДиалог(
				СсылкаДиалога,
				Перечисления.ИИА_АвторСообщения.Система,
				Перечисления.ИИА_ТипСообщения.Ошибка,
				ТекстОшибки,
				"",
				"",
				0
			);
		КонецЕсли;
		
	КонецЕсли;
	
	// Если есть ТекстКода, добавляем системное сообщение о получении кода (только для не-DSL типов)
	Если НЕ ПустаяСтрока(ТекстКодаОтвета) И ОтветИИ.ТипОтвета <> "DSL" Тогда
		
		// Определяем текст системного сообщения в зависимости от типа
		Если ОтветИИ.ТипОтвета = "Запрос" Тогда
			ТекстСистемногоСообщения = "Запрос сгенерирован.";
		Иначе
			ТекстСистемногоСообщения = "ИИ сгенерировал код.";
		КонецЕсли;
		
		ДобавитьСообщениеВДиалог(
			СсылкаДиалога,
			Перечисления.ИИА_АвторСообщения.Система,
			Перечисления.ИИА_ТипСообщения.Текст,
			ТекстСистемногоСообщения,
			"",
			"",
			0
		);
		
	КонецЕсли;
	
	Возврат ОтветИИ;
	
КонецФункции

// Проверяет запрос 1С на выполнимость
//
// Параметры:
//  ТекстЗапроса - Строка - текст запроса
//
// Возвращаемое значение:
//  Структура - структура результата:
//   * Успех - Булево - успешность выполнения
//   * Сообщение - Строка - текст ошибки или пусто
//
Функция ПроверитьЗапрос(ТекстЗапроса) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Успех", Ложь);
	Результат.Вставить("Сообщение", "");
	
	Попытка
		
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.Выполнить();
		
		Результат.Успех = Истина;
		
	Исключение
		
		Результат.Сообщение = ОписаниеОшибки();
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Выполняет DSL сценарий
//
// Параметры:
//  DSLJSON - Строка - JSON с DSL командами
//
// Возвращаемое значение:
//  Структура - структура результата выполнения DSL
//
Функция ВыполнитьDSLСценарий(DSLJSON, СсылкаДиалога = Неопределено) Экспорт
	
	// Выполняем DSL
	// В режиме Запрос1С устанавливаем флаг ТолькоЧтение
	ТолькоЧтение = Ложь;
	Если ЗначениеЗаполнено(СсылкаДиалога) Тогда
		ТолькоЧтение = (СсылкаДиалога.ТипДиалога = Перечисления.ИИА_ТипДиалога.Запрос1С);
		
		// Учитываем настройку «ДоступнаЗапись»
		Попытка
			Диалог = СсылкаДиалога.ПолучитьОбъект();
			НастройкиПольз = ПолучитьНастройкиПользователя(Диалог.Пользователь);
			Если НастройкиПольз.Свойство("ДоступнаЗапись") И НЕ НастройкиПольз.ДоступнаЗапись Тогда
				ТолькоЧтение = Истина;
			КонецЕсли;
		Исключение
			// если не удалось получить настройки — не меняем поведение
		КонецПопытки;
	КонецЕсли;
	
	РезультатDSL = ИИА_DSL.ВыполнитьDSL(DSLJSON, СсылкаДиалога, ТолькоЧтение);
	
	// Обрабатываем результаты для установки флагов открытия табличного документа
	Если РезультатDSL.Успех Тогда
		// Проверяем, есть ли данные запроса в результате DSL (устанавливается при RunQuery)
		Если РезультатDSL.Свойство("ДанныеЗапросаДляТаблицы") И РезультатDSL.ДанныеЗапросаДляТаблицы <> Неопределено Тогда
			РезультатDSL.Вставить("ОткрытьТабличныйДокумент", Истина);
			РезультатDSL.Вставить("ДанныеЗапроса", РезультатDSL.ДанныеЗапросаДляТаблицы);
		ИначеЕсли РезультатDSL.Результаты.Количество() > 0 Тогда
			// Проверяем результаты шагов для ShowInfo с результатом запроса
			Для Каждого РезультатШага Из РезультатDSL.Результаты Цикл
				// Если это результат ShowInfo с результатом запроса, устанавливаем флаги
				Если РезультатШага.Свойство("ТипДействия") И РезультатШага.ТипДействия = "ShowInfo" И
				   РезультатШага.Свойство("ЕстьРезультатЗапроса") И РезультатШага.ЕстьРезультатЗапроса Тогда
					РезультатDSL.Вставить("ОткрытьТабличныйДокумент", Истина);
					// Копируем данные запроса в результат DSL
					Если РезультатDSL.Свойство("ДанныеЗапросаДляТаблицы") Тогда
						РезультатDSL.Вставить("ДанныеЗапроса", РезультатDSL.ДанныеЗапросаДляТаблицы);
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Возврат РезультатDSL;
	
КонецФункции

// Выполняет DSL-сценарий без добавления сообщений в диалог
//
// Параметры:
//  DSLJSON - Строка - JSON с DSL командами
//
// Возвращаемое значение:
//  Структура - структура результата выполнения DSL
//
Функция ВыполнитьDSLСценарийБезСообщений(DSLJSON, СсылкаДиалога = Неопределено) Экспорт
	
	// Выполняем DSL без добавления сообщений
	// В режиме Запрос1С устанавливаем флаг ТолькоЧтение
	ТолькоЧтение = Ложь;
	Если ЗначениеЗаполнено(СсылкаДиалога) Тогда
		ТолькоЧтение = (СсылкаДиалога.ТипДиалога = Перечисления.ИИА_ТипДиалога.Запрос1С);
		
		// Учитываем настройку «ДоступнаЗапись»
		Попытка
			Диалог = СсылкаДиалога.ПолучитьОбъект();
			НастройкиПольз = ПолучитьНастройкиПользователя(Диалог.Пользователь);
			Если НастройкиПольз.Свойство("ДоступнаЗапись") И НЕ НастройкиПольз.ДоступнаЗапись Тогда
				ТолькоЧтение = Истина;
			КонецЕсли;
		Исключение
			// если не удалось получить настройки — не меняем поведение
		КонецПопытки;
	КонецЕсли;
	
	РезультатDSL = ИИА_DSL.ВыполнитьDSL(DSLJSON, СсылкаДиалога, ТолькоЧтение);
	
	Возврат РезультатDSL;
	
КонецФункции

// Выполняет DSL-сценарий и добавляет системные сообщения в диалог
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  DSLJSON - Строка - JSON с DSL командами
//
// Возвращаемое значение:
//  Структура - структура результата выполнения DSL
//
Функция ВыполнитьDSLСценарийССообщениями(СсылкаДиалога, DSLJSON) Экспорт
	
	// Выполняем DSL
	// В режиме Запрос1С устанавливаем флаг ТолькоЧтение
	ТолькоЧтение = (СсылкаДиалога.ТипДиалога = Перечисления.ИИА_ТипДиалога.Запрос1С);
	
	// Учитываем настройку «ДоступнаЗапись»
	Попытка
		Диалог = СсылкаДиалога.ПолучитьОбъект();
		НастройкиПольз = ПолучитьНастройкиПользователя(Диалог.Пользователь);
		Если НастройкиПольз.Свойство("ДоступнаЗапись") И НЕ НастройкиПольз.ДоступнаЗапись Тогда
			ТолькоЧтение = Истина;
		КонецЕсли;
	Исключение
		// если не удалось получить настройки — не меняем поведение
	КонецПопытки;
	РезультатDSL = ИИА_DSL.ВыполнитьDSL(DSLJSON, СсылкаДиалога, ТолькоЧтение);
	
	Если РезультатDSL.Успех Тогда
		
		// Добавляем системное сообщение об успешном выполнении
		ТекстСистемногоСообщения = "DSL-сценарий выполнен успешно.";
		
		// Обрабатываем результаты шагов
		Если РезультатDSL.Результаты.Количество() > 0 Тогда
			Для Каждого РезультатШага Из РезультатDSL.Результаты Цикл
				// Если это результат ShowInfo, выводим его как отдельное сообщение от ИИ
				Если РезультатШага.Свойство("ТипДействия") И РезультатШага.ТипДействия = "ShowInfo" И 
				   НЕ ПустаяСтрока(РезультатШага.Сообщение) Тогда
					ДобавитьСообщениеВДиалог(
						СсылкаДиалога,
						Перечисления.ИИА_АвторСообщения.ИИ,
						Перечисления.ИИА_ТипСообщения.Текст,
						РезультатШага.Сообщение,
						"",
						"",
						0
					);
					// Если есть результат запроса, сохраняем данные для создания табличного документа на клиенте
					Если РезультатШага.Свойство("ЕстьРезультатЗапроса") И РезультатШага.ЕстьРезультатЗапроса Тогда
						РезультатDSL.Вставить("ОткрытьТабличныйДокумент", Истина);
						// Ищем данные запроса в результате DSL (они сохраняются при выполнении RunQuery)
						Если РезультатDSL.Свойство("ДанныеЗапросаДляТаблицы") Тогда
							РезультатDSL.Вставить("ДанныеЗапроса", РезультатDSL.ДанныеЗапросаДляТаблицы);
						КонецЕсли;
					КонецЕсли;
				ИначеЕсли РезультатШага.Свойство("ТипДействия") И РезультатШага.ТипДействия = "RunQuery" И
				   РезультатШага.Свойство("ЕстьРезультатЗапроса") И РезультатШага.ЕстьРезультатЗапроса Тогда
					// Если это RunQuery с данными, устанавливаем флаги для открытия табличного документа
					РезультатDSL.Вставить("ОткрытьТабличныйДокумент", Истина);
					Если РезультатDSL.Свойство("ДанныеЗапросаДляТаблицы") Тогда
						РезультатDSL.Вставить("ДанныеЗапроса", РезультатDSL.ДанныеЗапросаДляТаблицы);
					КонецЕсли;
				Иначе
					// Обычный результат шага - добавляем в системное сообщение
					ТекстСистемногоСообщения = ТекстСистемногоСообщения + Символы.ПС + "- " + РезультатШага.Сообщение;
					
					// Если это GetObjectFields, добавляем детальную информацию о реквизитах
					Если РезультатШага.Свойство("ТипДействия") И РезультатШага.ТипДействия = "GetObjectFields" 
						И РезультатШага.Свойство("Данные") И РезультатШага.Данные <> Неопределено Тогда
						
						ДанныеОбъекта = РезультатШага.Данные;
						Если ТипЗнч(ДанныеОбъекта) = Тип("Структура") И ДанныеОбъекта.Свойство("Реквизиты") Тогда
							МассивРеквизитов = ДанныеОбъекта.Реквизиты;
							Если ТипЗнч(МассивРеквизитов) = Тип("Массив") И МассивРеквизитов.Количество() > 0 Тогда
								ТекстСистемногоСообщения = ТекстСистемногоСообщения + Символы.ПС + "Реквизиты:";
								Для Каждого Реквизит Из МассивРеквизитов Цикл
									Если ТипЗнч(Реквизит) = Тип("Структура") И Реквизит.Свойство("Имя") Тогда
										ИмяРеквизита = Реквизит.Имя;
										Если Реквизит.Свойство("Синоним") И НЕ ПустаяСтрока(Реквизит.Синоним) Тогда
											ИмяРеквизита = ИмяРеквизита + " (" + Реквизит.Синоним + ")";
										КонецЕсли;
										ТекстСистемногоСообщения = ТекстСистемногоСообщения + Символы.ПС + "  - " + ИмяРеквизита;
									КонецЕсли;
								КонецЦикла;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		ДобавитьСообщениеВДиалог(
			СсылкаДиалога,
			Перечисления.ИИА_АвторСообщения.Система,
			Перечисления.ИИА_ТипСообщения.Текст,
			ТекстСистемногоСообщения,
			"",
			"",
			0
		);
		
		// Добавляем системное сообщение со ссылками на созданные/измененные объекты
		Если РезультатDSL.Свойство("СсылкиОбъектов") Тогда
			МассивСсылок = РезультатDSL.СсылкиОбъектов;
			Если МассивСсылок.Количество() > 0 Тогда
				Попытка
					
					// Сохраняем ссылки в табличную часть ИзмененныеОбъекты
					ДобавитьИзмененныеОбъекты(СсылкаДиалога, МассивСсылок);
					
					// Формируем текст с детальной информацией
					ТекстСсылок = "Создано/изменено объектов: " + Формат(МассивСсылок.Количество(), "ЧН=0") + Символы.ПС;
					ТекстСсылок = ТекстСсылок + ПолучитьДанныеСозданныхОбъектов(МассивСсылок);
					
					ДобавитьСообщениеВДиалог(
						СсылкаДиалога,
						Перечисления.ИИА_АвторСообщения.Система,
						Перечисления.ИИА_ТипСообщения.Текст,
						ТекстСсылок,
						"",
						"",
						0
					);
					
				Исключение
					// Если не удалось добавить ссылки, добавляем сообщение об ошибке для отладки
					ДобавитьСообщениеВДиалог(
						СсылкаДиалога,
						Перечисления.ИИА_АвторСообщения.Система,
						Перечисления.ИИА_ТипСообщения.Ошибка,
						"Ошибка при формировании сообщения со ссылками: " + ОписаниеОшибки(),
						"",
						"",
						0
					);
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
		
	Иначе
		
		// Добавляем системное сообщение об ошибке
		ТекстОшибки = "Ошибка выполнения DSL: " + РезультатDSL.Сообщение;
		
		// Если ошибка в режиме Запрос1С связана с выполнением запроса, добавляем справку
		Если ТолькоЧтение И (СтрНайти(ТекстОшибки, "RunQuery") > 0 ИЛИ СтрНайти(ТекстОшибки, "Запрос") > 0) Тогда
			
			// Если ошибка "Поле не найдено", советуем получить метаданные
			Если СтрНайти(ТекстОшибки, "Поле не найдено") > 0 Тогда
				ТекстСправки = "СОВЕТ: Система не нашла указанное поле. Возможно, ты используешь неверное имя (синоним вместо имени). " +
				"Рекомендуется сначала выполнить действие GetObjectFields для этой таблицы, чтобы узнать точные имена полей.";
			Иначе
				// Иначе даем полную справку
				ТекстСправки = "ВНИМАНИЕ! Обнаружена ошибка выполнения запроса 1С. " + Символы.ПС +
				"Используйте эту справочную информацию для исправления запроса:" + Символы.ПС + Символы.ПС +
				ИИА_СправкаЗапросы1С.ПолучитьПолнуюСправку();
			КонецЕсли;
			
			ДобавитьСообщениеВДиалог(
				СсылкаДиалога,
				Перечисления.ИИА_АвторСообщения.Система,
				Перечисления.ИИА_ТипСообщения.Текст,
				ТекстСправки,
				"",
				"",
				0
			);
			
		КонецЕсли;
		
		ДобавитьСообщениеВДиалог(
			СсылкаДиалога,
			Перечисления.ИИА_АвторСообщения.Система,
			Перечисления.ИИА_ТипСообщения.Ошибка,
			ТекстОшибки,
			"",
			"",
			0
		);
		
	КонецЕсли;
	
	Возврат РезультатDSL;
	
КонецФункции

// Генерирует summary (резюме) выполненной работы через ИИ
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Строка - текст summary или пустая строка при ошибке
//
Функция СгенерироватьSummary(СсылкаДиалога) Экспорт
	
	Попытка
		
		Диалог = СсылкаДиалога.ПолучитьОбъект();
		
		// Получаем все сообщения диалога для контекста
		МассивИстории = ПолучитьСообщенияДиалога(СсылкаДиалога, 100);
		История = ПреобразоватьМассивСообщенийВТаблицу(МассивИстории);
		
		// Получаем информацию о созданных/измененных объектах
		ТекстИзмененныхОбъектов = "";
		Если Диалог.ИзмененныеОбъекты.Количество() > 0 Тогда
			ТекстИзмененныхОбъектов = "Созданные/измененные объекты:" + Символы.ПС;
			Для Каждого СтрокаИзмененныхОбъектов Из Диалог.ИзмененныеОбъекты Цикл
				Если ЗначениеЗаполнено(СтрокаИзмененныхОбъектов.СсылкаНаОбъект) Тогда
					ТекстИзмененныхОбъектов = ТекстИзмененныхОбъектов + "- " + СтрокаИзмененныхОбъектов.СсылкаНаОбъект + Символы.ПС;
				КонецЕсли;
			КонецЦикла;
		Иначе
			ТекстИзмененныхОбъектов = "Объекты не создавались и не изменялись.";
		КонецЕсли;
		
		// Получаем все задачи пользователя из истории диалога
		ТекстЗадач = "";
		Для Каждого СтруктураСообщения Из МассивИстории Цикл
			Если СтруктураСообщения.Автор = Перечисления.ИИА_АвторСообщения.Пользователь Тогда
				ТекстЗадачи = СокрЛП(СтруктураСообщения.Текст);
				Если НЕ ПустаяСтрока(ТекстЗадачи) Тогда
					Если НЕ ПустаяСтрока(ТекстЗадач) Тогда
						ТекстЗадач = ТекстЗадач + Символы.ПС;
					КонецЕсли;
					ТекстЗадач = ТекстЗадач + ТекстЗадачи;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		// Извлекаем результаты выполнения DSL из системных сообщений
		// Ищем сообщения с DSL-сценариями и их результаты
		ТекстРезультатовDSL = "";
		Для Индекс = 0 По МассивИстории.Количество() - 1 Цикл
			СтруктураСообщения = МассивИстории[Индекс];
			
			// Ищем сообщения ИИ с DSL-сценариями
			Если СтруктураСообщения.Автор = Перечисления.ИИА_АвторСообщения.ИИ 
				И НЕ ПустаяСтрока(СтруктураСообщения.ТекстКода) Тогда
				
				// Пытаемся найти следующее системное сообщение с результатами выполнения
				Если Индекс + 1 < МассивИстории.Количество() Тогда
					СледующееСообщение = МассивИстории[Индекс + 1];
					Если СледующееСообщение.Автор = Перечисления.ИИА_АвторСообщения.Система 
						И НЕ ПустаяСтрока(СледующееСообщение.Текст) Тогда
						
						ТекстРезультата = СокрЛП(СледующееСообщение.Текст);
						Если НЕ ПустаяСтрока(ТекстРезультата) Тогда
							Если НЕ ПустаяСтрока(ТекстРезультатовDSL) Тогда
								ТекстРезультатовDSL = ТекстРезультатовDSL + Символы.ПС;
							КонецЕсли;
							ТекстРезультатовDSL = ТекстРезультатовDSL + "DSL-сценарий: " + СокрЛП(СтруктураСообщения.ТекстКода) + Символы.ПС;
							ТекстРезультатовDSL = ТекстРезультатовDSL + "Результат: " + ТекстРезультата;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		// Получаем настройки ИИ для пользователя диалога
		Пользователь = Диалог.Пользователь;
		Настройки = ПолучитьНастройкиПользователя(Пользователь);
		Настройки.Вставить("Пользователь", Пользователь);
		
		// Формируем промпт для генерации summary
		ПромптSummary = ИИА_Промты.СформироватьПромптРезюме(ТекстЗадач, ТекстИзмененныхОбъектов, ТекстРезультатовDSL);
		
		// Вызываем ИИ для генерации summary
		ОтветИИ = ИИА_Провайдеры.ВызватьИИ("Чат", ПромптSummary, История, Настройки);
		
		ТекстSummary = "";
		Если ОтветИИ.Свойство("Текст") И НЕ ПустаяСтрока(ОтветИИ.Текст) Тогда
			ТекстSummary = ОтветИИ.Текст;
		ИначеЕсли ОтветИИ.Свойство("DSL") И НЕ ПустаяСтрока(ОтветИИ.DSL) Тогда
			// Если получен DSL, извлекаем текст из него
			ТекстSummary = ОтветИИ.DSL;
		КонецЕсли;
		
		Возврат ТекстSummary;
		
	Исключение
		Возврат "Ошибка при генерации summary: " + ОписаниеОшибки();
	КонецПопытки;
	
КонецФункции



// Добавляет запись в лог диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  ЗаписьЛога - Строка - текст записи для добавления
//
Процедура ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, ЗаписьЛога) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	// Предполагаем наличие реквизита Лог
	Если Диалог.Метаданные().Реквизиты.Найти("Лог") <> Неопределено Тогда
		
		ТекущийЛог = Диалог.Лог;
		
		Если ПустаяСтрока(ТекущийЛог) Тогда
			НовыйЛог = ЗаписьЛога;
		Иначе
			НовыйЛог = ТекущийЛог + Символы.ПС + ЗаписьЛога;
		КонецЕсли;
		
		Диалог.Лог = НовыйЛог;
		Диалог.Записать();
		
		// Режим отладки: перезаписываем файл полным содержимым реквизита Лог
		Если РежимОтладкиJSON(Диалог.Пользователь) Тогда
			ПутьЛога = "D:\EDTApps\AI_agent\log.txt";
			ТДЗапись = Новый ТекстовыйДокумент;
			ТДЗапись.УстановитьТекст(НовыйЛог);
			// Перезапись файла целиком (как попросили)
			ТДЗапись.Записать(ПутьЛога);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Создает табличный документ из массива структур с данными запроса
//
// Параметры:
//  ДанныеЗапроса - Массив - массив структур с данными запроса
//
// Возвращаемое значение:
//  ТабличныйДокумент - созданный табличный документ
//
Функция СоздатьТабличныйДокументИзДанных(ДанныеЗапроса) Экспорт
	
	Если ДанныеЗапроса = Неопределено Или ТипЗнч(ДанныеЗапроса) <> Тип("Массив") Или ДанныеЗапроса.Количество() = 0 Тогда
		ВызватьИсключение "ДанныеЗапроса пусты или неверного типа";
	КонецЕсли;
	
	Попытка
		// Получаем структуру первой строки для определения колонок
		ПерваяСтрока = ДанныеЗапроса[0];
		Если ТипЗнч(ПерваяСтрока) <> Тип("Структура") Тогда
			ВызватьИсключение "Первая строка данных должна быть структурой";
		КонецЕсли;
		
		// Создаем таблицу значений для удобной работы с данными
		ТаблицаДанных = Новый ТаблицаЗначений;
		
		// Добавляем колонки на основе первой строки
		Для Каждого ПараКлючЗначение Из ПерваяСтрока Цикл
			ТаблицаДанных.Колонки.Добавить(ПараКлючЗначение.Ключ, Новый ОписаниеТипов("Строка"));
		КонецЦикла;
		
		// Заполняем таблицу значений данными
		Для Каждого СтрокаДанных Из ДанныеЗапроса Цикл
			Если ТипЗнч(СтрокаДанных) = Тип("Структура") Тогда
				НоваяСтрока = ТаблицаДанных.Добавить();
				Для Каждого ПараКлючЗначение Из ПерваяСтрока Цикл
					ИмяКолонки = ПараКлючЗначение.Ключ;
					Если СтрокаДанных.Свойство(ИмяКолонки) Тогда
						Значение = СтрокаДанных[ИмяКолонки];
						НоваяСтрока[ИмяКолонки] = Строка(Значение);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
		
		// Создаем табличный документ
		ТабличныйДокумент = Новый ТабличныйДокумент;
		
		// Используем ПостроительОтчета для вывода таблицы значений
		Построитель = Новый ПостроительОтчета;
		Построитель.ИсточникДанных = Новый ОписаниеИсточникаДанных(ТаблицаДанных);
		Построитель.Вывести(ТабличныйДокумент);
		
		Возврат ТабличныйДокумент;
		
	Исключение
		ВызватьИсключение "Ошибка при создании табличного документа: " + ОписаниеОшибки();
	КонецПопытки;
	
КонецФункции

// Устанавливает флаг отображения табличного документа в хранилище диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  Значение - Булево - значение флага
//
Процедура УстановитьФлагТаблицыВХранилище(СсылкаДиалога, Значение) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	СтруктураДанных = Новый Структура;
	
	Если ЗначениеЗаполнено(Диалог.ХранилищеЗначения) Тогда
		Попытка
			СтруктураДанных = Диалог.ХранилищеЗначения.Получить();
		Исключение
			СтруктураДанных = Новый Структура;
		КонецПопытки;
		Если ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
			СтруктураДанных = Новый Структура;
		КонецЕсли;
	КонецЕсли;
	
	СтруктураДанных.Вставить("ТаблицаПоказана", Значение);
	
	ХранилищеЗначения = Новый ХранилищеЗначения(СтруктураДанных);
	Диалог.ХранилищеЗначения = ХранилищеЗначения;
	Диалог.Записать();
	
КонецПроцедуры

// Сохраняет лог в справочник ИИА_Диалоги
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  ТекстЛога - Строка - текст лога для сохранения
//
Процедура СохранитьЛогДиалога(СсылкаДиалога, ТекстЛога) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Попытка
		
		Диалог = СсылкаДиалога.ПолучитьОбъект();
		Диалог.Лог = ТекстЛога;
		Диалог.Записать();
		
	Исключение
		// Игнорируем ошибки сохранения лога
	КонецПопытки;
	
КонецПроцедуры

// Получает лог из справочника ИИА_Диалоги
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Строка - текст лога
//
Функция ПолучитьЛогДиалога(СсылкаДиалога) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ИИА_Диалоги.Лог КАК Лог
	|ИЗ
	|	Справочник.ИИА_Диалоги КАК ИИА_Диалоги
	|ГДЕ
	|	ИИА_Диалоги.Ссылка = &Ссылка";
	
	Запрос.УстановитьПараметр("Ссылка", СсылкаДиалога);
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат "";
	КонецЕсли;
	
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	
	Возврат Выборка.Лог;
	
КонецФункции


// Сбрасывает результат проверки задачи в хранилище диалога (устанавливает ПроверкаВыполнена = Ложь)
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
//
Процедура СброситьРезультатПроверкиВХранилище(СсылкаДиалога) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	СтруктураПроверки = Новый Структура;
	
	Если ЗначениеЗаполнено(Диалог.ХранилищеЗначения) Тогда
		Попытка
			СтруктураПроверки = Диалог.ХранилищеЗначения.Получить();
		Исключение
			СтруктураПроверки = Новый Структура;
		КонецПопытки;
		Если ТипЗнч(СтруктураПроверки) <> Тип("Структура") Тогда
			СтруктураПроверки = Новый Структура;
		КонецЕсли;
	КонецЕсли;
	
	СтруктураПроверки.Вставить("ПроверкаВыполнена", Ложь);
	СтруктураПроверки.Вставить("СтатусПроверкиЗадачи", "");
	СтруктураПроверки.Вставить("ПричинаПроверки", "");
	СтруктураПроверки.Вставить("ТаблицаПоказана", Ложь);
	
	ХранилищеЗначения = Новый ХранилищеЗначения(СтруктураПроверки);
	Диалог.ХранилищеЗначения = ХранилищеЗначения;
	Диалог.Записать();
	
КонецПроцедуры

// Проверяет DSL сценарий
//
// Параметры:
//  DSLJSON - Строка - JSON с DSL командами
//
// Возвращаемое значение:
//  Структура - структура результата проверки DSL
//
Функция ПроверитьDSLСценарий(DSLJSON) Экспорт
	
	Возврат ИИА_DSL.ПроверитьDSL(DSLJSON);
	
КонецФункции

// Получает данные созданных объектов (реквизиты)
//
// Параметры:
//  МассивСсылок - Массив - массив ссылок на созданные объекты
//
// Возвращаемое значение:
//  Строка - текстовое описание реквизитов объектов
//
Функция ПолучитьДанныеСозданныхОбъектов(МассивСсылок)
	
	ТекстДанных = "";
	
	Если МассивСсылок.Количество() = 0 Тогда
		Возврат ТекстДанных;
	КонецЕсли;
	
	Для Каждого СсылкаОбъекта Из МассивСсылок Цикл
		
		Попытка
			
			// Получаем объект по ссылке
			Объект = СсылкаОбъекта.ПолучитьОбъект();
			
			Если Объект = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			// Определяем тип объекта
			ТипСсылки = ТипЗнч(СсылкаОбъекта);
			ИмяТипа = Строка(ТипСсылки);
			
			ТекстДанных = ТекстДанных + "Объект: " + СсылкаОбъекта + Символы.ПС;
			ТекстДанных = ТекстДанных + "Тип: " + ИмяТипа + Символы.ПС;
			
			// Получаем метаданные объекта
			Если Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
				
				МетаданныеОбъекта = СсылкаОбъекта.Метаданные();
				ТекстДанных = ТекстДанных + "Справочник: " + МетаданныеОбъекта.Имя + " (" + МетаданныеОбъекта.Синоним + ")" + Символы.ПС;
				
				// Получаем реквизиты справочника
				Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
					
					Попытка
						ЗначениеРеквизита = Объект[Реквизит.Имя];
						ТекстЗначения = "";
						
						Если ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
							Если ТипЗнч(ЗначениеРеквизита) = Тип("Строка") Тогда
								ТекстЗначения = ЗначениеРеквизита;
							ИначеЕсли ТипЗнч(ЗначениеРеквизита) = Тип("Число") Тогда
								ТекстЗначения = Формат(ЗначениеРеквизита, "ЧГ=");
							ИначеЕсли ТипЗнч(ЗначениеРеквизита) = Тип("Дата") Тогда
								ТекстЗначения = Формат(ЗначениеРеквизита, "ДФ=dd.MM.yyyy HH:mm:ss");
							ИначеЕсли ТипЗнч(ЗначениеРеквизита) = Тип("Булево") Тогда
								Если ЗначениеРеквизита Тогда
									ТекстЗначения = "Истина";
								Иначе
									ТекстЗначения = "Ложь";
								КонецЕсли;
							Иначе
								ТекстЗначения = Строка(ЗначениеРеквизита);
							КонецЕсли;
							
							ТекстДанных = ТекстДанных + "  " + Реквизит.Синоним + " (" + Реквизит.Имя + "): " + ТекстЗначения + Символы.ПС;
						КонецЕсли;
						
					Исключение
						// Игнорируем ошибки получения реквизита
					КонецПопытки;
					
				КонецЦикла;
				
			ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
				
				МетаданныеОбъекта = СсылкаОбъекта.Метаданные();
				ТекстДанных = ТекстДанных + "Документ: " + МетаданныеОбъекта.Имя + " (" + МетаданныеОбъекта.Синоним + ")" + Символы.ПС;
				
				// Получаем реквизиты документа
				Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
					
					Попытка
						ЗначениеРеквизита = Объект[Реквизит.Имя];
						ТекстЗначения = "";
						
						Если ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
							Если ТипЗнч(ЗначениеРеквизита) = Тип("Строка") Тогда
								ТекстЗначения = ЗначениеРеквизита;
							ИначеЕсли ТипЗнч(ЗначениеРеквизита) = Тип("Число") Тогда
								ТекстЗначения = Формат(ЗначениеРеквизита, "ЧГ=");
							ИначеЕсли ТипЗнч(ЗначениеРеквизита) = Тип("Дата") Тогда
								ТекстЗначения = Формат(ЗначениеРеквизита, "ДФ=dd.MM.yyyy HH:mm:ss");
							ИначеЕсли ТипЗнч(ЗначениеРеквизита) = Тип("Булево") Тогда
								Если ЗначениеРеквизита Тогда
									ТекстЗначения = "Истина";
								Иначе
									ТекстЗначения = "Ложь";
								КонецЕсли;
							Иначе
								ТекстЗначения = Строка(ЗначениеРеквизита);
							КонецЕсли;
							
							ТекстДанных = ТекстДанных + "  " + Реквизит.Синоним + " (" + Реквизит.Имя + "): " + ТекстЗначения + Символы.ПС;
						КонецЕсли;
						
					Исключение
						// Игнорируем ошибки получения реквизита
					КонецПопытки;
					
				КонецЦикла;
				
			КонецЕсли;
			
			ТекстДанных = ТекстДанных + Символы.ПС;
			
		Исключение
			// Если не удалось получить данные объекта, просто добавляем ссылку
			ТекстДанных = ТекстДанных + "Объект: " + СсылкаОбъекта + " (не удалось получить данные)" + Символы.ПС + Символы.ПС;
		КонецПопытки;
		
	КонецЦикла;
	
	Возврат ТекстДанных;
	
КонецФункции

// Обновляет статус DSL в последнем сообщении диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  НовыйСтатус - ПеречислениеСсылка.ИИА_СтатусDSL - новый статус
//
Процедура ОбновитьСтатусDSLВПоследнемСообщении(СсылкаДиалога, НовыйСтатус) Экспорт
	
	ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "[Система] Обновление статуса DSL: " + Строка(НовыйСтатус));
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	Если Диалог.Сообщения.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	// Ищем последнее сообщение с DSL (тип Код или статус не пустой)
	Индекс = Диалог.Сообщения.Количество() - 1;
	Пока Индекс >= 0 Цикл
		
		СтрокаСообщения = Диалог.Сообщения[Индекс];
		
		Если СтрокаСообщения.ТипСообщения = Перечисления.ИИА_ТипСообщения.Код 
			ИЛИ ЗначениеЗаполнено(СтрокаСообщения.СтатусDSL) Тогда
			
			СтрокаСообщения.СтатусDSL = НовыйСтатус;
			Диалог.Записать();
			Прервать;
			
		КонецЕсли;
		
		Индекс = Индекс - 1;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ПолучитьПоследнийDslSystemResult(СсылкаДиалога)
	
	Результат = Новый Структура;
	Результат.Вставить("Найдено", Ложь);
	Результат.Вставить("Успех", Ложь);
	Результат.Вставить("Текст", "");
	
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) Тогда
		Возврат Результат;
	КонецЕсли;
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	Если Диалог.Сообщения.Количество() = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	Для Индекс = Диалог.Сообщения.Количество() - 1 По 0 Цикл
		СтрокаСообщения = Диалог.Сообщения[Индекс];
		Если СтрокаСообщения.Автор = Перечисления.ИИА_АвторСообщения.Система
			И НЕ ПустаяСтрока(СтрокаСообщения.Текст)
			И СтрНайти(СтрокаСообщения.Текст, "dsl_system_result") > 0 Тогда
			
			ТекстJSON = ИИА_DSL.НормализоватьJSONТекст(СтрокаСообщения.Текст);
			
			Результат.Найдено = Истина;
			Результат.Текст = ?(ПустаяСтрока(ТекстJSON), СтрокаСообщения.Текст, ТекстJSON);
			
			Если НЕ ПустаяСтрока(ТекстJSON) Тогда
				Попытка
					ЧтениеJSON = Новый ЧтениеJSON;
					ЧтениеJSON.УстановитьСтроку(ТекстJSON);
					Данные = ПрочитатьJSON(ЧтениеJSON);
					ЧтениеJSON.Закрыть();
					
					Если ТипЗнч(Данные) = Тип("Структура") И Данные.Свойство("success") Тогда
						Результат.Успех = Данные.success;
					КонецЕсли;
				Исключение
					// оставляем Успех=Ложь по умолчанию, текст уже заполнен
				КонецПопытки;
			КонецЕсли;
			
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ПроверитьВыводДанныхЗапроса(СсылкаДиалога)
	
	Результат = Новый Структура("ЕстьТабличныйДокумент, Причина", Ложь, "");
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) Тогда
		Возврат Результат;
	КонецЕсли;
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	// 1) Явный флаг из хранилища (устанавливается на клиенте при показе таблицы)
	ТаблицаПоказана = Ложь;
	РезультатИзХранилища = ПолучитьРезультатПроверкиИзХранилища(СсылкаДиалога);
	Если РезультатИзХранилища <> Неопределено
		И ТипЗнч(РезультатИзХранилища) = Тип("Структура")
		И РезультатИзХранилища.Свойство("ТаблицаПоказана") Тогда
		ТаблицаПоказана = РезультатИзХранилища.ТаблицаПоказана;
	КонецЕсли;
	
	Если ТаблицаПоказана Тогда
		Результат.ЕстьТабличныйДокумент = Истина;
		Результат.Причина = "Явный флаг ТаблицаПоказана из хранилища";
		Возврат Результат;
	КонецЕсли;
	
	// 2) Если флага нет — ищем RunQuery/ShowInfo в последних DSL сообщениях
	КоличествоСообщений = Диалог.Сообщения.Количество();
	Для Индекс = Макс(0, КоличествоСообщений - 6) По КоличествоСообщений - 1 Цикл
		СтрокаСообщения = Диалог.Сообщения[Индекс];
		Если СтрокаСообщения.Автор = Перечисления.ИИА_АвторСообщения.ИИ
			И СтрокаСообщения.ТипСообщения = Перечисления.ИИА_ТипСообщения.Код
			И НЕ ПустаяСтрока(СтрокаСообщения.ТекстКода) Тогда
			
			Попытка
				ЧтениеJSON = Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(ИИА_DSL.НормализоватьJSONТекст(СтрокаСообщения.ТекстКода));
				Сценарий = ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				
				Если ТипЗнч(Сценарий) = Тип("Структура") И Сценарий.Свойство("steps") И ТипЗнч(Сценарий.steps) = Тип("Массив") Тогда
					Для Каждого Шаг Из Сценарий.steps Цикл
						Если Шаг.Свойство("action") Тогда
							Действие = ВРег(Шаг.action);
							Если Действие = "RUNQUERY" ИЛИ Действие = "SHOWINFO" Тогда
								Результат.ЕстьТабличныйДокумент = Истина;
								Результат.Причина = "Найден шаг " + Шаг.action;
								Возврат Результат;
							КонецЕсли;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			Исключение
				// Не маскируем ошибку: просто считаем, что не нашли подтверждение вывода
			КонецПопытки;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Проверяет результат выполнения задачи через ИИ
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Структура - результат проверки
//
Функция ПроверитьРезультатВыполненияЗадачи(СсылкаДиалога) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ПроверкаВыполнена", Ложь);
	Результат.Вставить("Причина", "");
	
	// Получаем исходную задачу (первое сообщение пользователя)
	ПервоеСообщение = ПолучитьПервоеСообщениеПользователя(СсылкаДиалога);
	Если НЕ ПервоеСообщение.Найдено Тогда
		Результат.Причина = "Не найдена исходная задача";
		Возврат Результат;
	КонецЕсли;
	
	ТекстЗадачи = ПервоеСообщение.Текст;
	
	// Получаем результаты выполнения DSL из лога (системные сообщения)
	Диалог = СсылкаДиалога.ПолучитьОбъект();

	// ДЕТЕРМИНИРОВАННАЯ ПРОВЕРКА (экономия + предсказуемость)
	ПоследнийСистРез = ПолучитьПоследнийDslSystemResult(СсылкаДиалога);
	Если ПоследнийСистРез.Найдено Тогда
		
		Если НЕ ПоследнийСистРез.Успех Тогда
			Результат.ПроверкаВыполнена = Ложь;
			Результат.Причина = "Последнее выполнение DSL завершилось ошибкой.";
			УстановитьРезультатПроверкиВХранилище(СсылкаДиалога, Результат.ПроверкаВыполнена, Результат.Причина);
			Возврат Результат;
		КонецЕсли;
		
		Если Диалог.ТипДиалога = Перечисления.ИИА_ТипДиалога.Запрос1С Тогда
			ПроверкаВывода = ПроверитьВыводДанныхЗапроса(СсылкаДиалога);
			Если ПроверкаВывода.ЕстьТабличныйДокумент Тогда
				Результат.ПроверкаВыполнена = Истина;
				Результат.Причина = "Данные выведены: " + ПроверкаВывода.Причина;
			Иначе
				Результат.ПроверкаВыполнена = Ложь;
				Результат.Причина = "Нет подтверждения вывода данных (RunQuery или таблица).";
			КонецЕсли;
			УстановитьРезультатПроверкиВХранилище(СсылкаДиалога, Результат.ПроверкаВыполнена, Результат.Причина);
			Возврат Результат;
		Иначе
			Результат.ПроверкаВыполнена = Истина;
			Результат.Причина = "Последнее выполнение DSL успешно.";
			УстановитьРезультатПроверкиВХранилище(СсылкаДиалога, Результат.ПроверкаВыполнена, Результат.Причина);
			Возврат Результат;
		КонецЕсли;
		
	КонецЕсли;

	ТекстРезультатов = "";
	
	// Собираем последние результаты выполнения
	Для Индекс = Макс(0, Диалог.Сообщения.Количество() - 20) По Диалог.Сообщения.Количество() - 1 Цикл
		СтрокаСообщения = Диалог.Сообщения[Индекс];
		Если СтрокаСообщения.Автор = Перечисления.ИИА_АвторСообщения.Система Тогда
			ТекстРезультатов = ТекстРезультатов + Символы.ПС + СтрокаСообщения.Текст;
		КонецЕсли;
	КонецЦикла;
	
	// Формируем промпт для проверки
	ПромптПроверки = ИИА_Промты.СформироватьПромптПроверкиЗадачи(ТекстЗадачи, ТекстРезультатов);
	
	// Вызываем ИИ для проверки (используем только диагностические действия)
	РезультатВызова = ВызватьИИССистемнымСообщением(СсылкаДиалога, "Чат", ПромптПроверки);
	
	// Анализируем ответ
	ТекстОтвета = "";
	Если РезультатВызова.ТипОтвета = "DSL" И НЕ ПустаяСтрока(РезультатВызова.DSL) Тогда
		// Парсим DSL чтобы найти сообщение ShowInfo
		Попытка
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(РезультатВызова.DSL);
			Сценарий = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			
			Если Сценарий.Свойство("steps") И ТипЗнч(Сценарий.steps) = Тип("Массив") Тогда
				Для Каждого Шаг Из Сценарий.steps Цикл
					Если Шаг.action = "ShowInfo" И Шаг.Свойство("message") Тогда
						ТекстОтвета = Шаг.message;
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		Исключение
			// Ошибка парсинга - берем сырой текст если есть
			ТекстОтвета = РезультатВызова.Текст;
		КонецПопытки;
	Иначе
		ТекстОтвета = РезультатВызова.Текст;
	КонецЕсли;
	
	ТекстОтветаВРег = ВРег(ТекстОтвета);
	
	// Улучшенная логика проверки "ДА/НЕТ"
	Если СтрНачинаетсяС(ТекстОтветаВРег, "ДА") 
		ИЛИ СтрНачинаетсяС(ТекстОтветаВРег, "'ДА") 
		ИЛИ СтрНачинаетсяС(ТекстОтветаВРег, """ДА") Тогда
		
		// Для режима Запрос 1С проверяем наличие результата запроса (ТабличныйДокумент)
		Диалог = СсылкаДиалога.ПолучитьОбъект();
		Если Диалог.ТипДиалога = Перечисления.ИИА_ТипДиалога.Запрос1С Тогда
			
			// Сначала проверяем явный флаг из хранилища (устанавливается на клиенте при вызове .Показать())
			ТаблицаПоказана = Ложь;
			РезультатИзХранилища = ПолучитьРезультатПроверкиИзХранилища(СсылкаДиалога);
			Если РезультатИзХранилища <> Неопределено И РезультатИзХранилища.Свойство("ТаблицаПоказана") Тогда
				ТаблицаПоказана = РезультатИзХранилища.ТаблицаПоказана;
			КонецЕсли;
			
			Если ТаблицаПоказана Тогда
				ЕстьТабличныйДокумент = Истина;
				ПричинаЛога = "Явный флаг ТаблицаПоказана из хранилища";
			Иначе
				// Если явного флага нет, проверяем последние сообщения на наличие флага ОткрытьТабличныйДокумент в результате DSL
				// ВАЖНО: Исключаем последнее сообщение, так как это само сообщение с результатом проверки (которое тоже содержит ShowInfo)
				ЕстьТабличныйДокумент = Ложь;
				ПричинаЛога = "";
				КоличествоСообщений = Диалог.Сообщения.Количество();
				Для Индекс = Макс(0, КоличествоСообщений - 6) По КоличествоСообщений - 2 Цикл
					СтрокаСообщения = Диалог.Сообщения[Индекс];
					Если СтрокаСообщения.Автор = Перечисления.ИИА_АвторСообщения.ИИ И СтрокаСообщения.ТипСообщения = Перечисления.ИИА_ТипСообщения.Код Тогда
						// Проверяем DSL на наличие действия RunQuery или ShowInfo (который вывел данные)
						// Парсим JSON, чтобы не полагаться на регистр и пробелы
						Попытка
							ЧтениеJSON = Новый ЧтениеJSON;
							ЧтениеJSON.УстановитьСтроку(СтрокаСообщения.ТекстКода);
							Сценарий = ПрочитатьJSON(ЧтениеJSON);
							ЧтениеJSON.Закрыть();
							
							Если Сценарий.Свойство("steps") И ТипЗнч(Сценарий.steps) = Тип("Массив") Тогда
								Для Каждого Шаг Из Сценарий.steps Цикл
									Если Шаг.Свойство("action") И (ВРег(Шаг.action) = "RUNQUERY" ИЛИ ВРег(Шаг.action) = "SHOWINFO") Тогда
										ЕстьТабличныйДокумент = Истина;
										ПричинаЛога = "Найден шаг " + Шаг.action + " в сообщении ИИ #" + Индекс;
										Прервать;
									КонецЕсли;
								КонецЦикла;
							КонецЕсли;
						Исключение
							// Если не удалось распарсить, проверяем наличие строки "RunQuery" или "ShowInfo" в тексте кода как запасной вариант
							ТекстКодаВРег = ВРег(СтрокаСообщения.ТекстКода);
							Если СтрНайти(ТекстКодаВРег, "RUNQUERY") > 0 Тогда
								ЕстьТабличныйДокумент = Истина;
								ПричинаЛога = "Найдена подстрока RUNQUERY в сообщении ИИ #" + Индекс;
							ИначеЕсли СтрНайти(ТекстКодаВРег, "SHOWINFO") > 0 Тогда
								ЕстьТабличныйДокумент = Истина;
								ПричинаЛога = "Найдена подстрока SHOWINFO в сообщении ИИ #" + Индекс;
							КонецЕсли;
						КонецПопытки;
						
						Если ЕстьТабличныйДокумент Тогда
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			
			// Логируем результат проверки табличного документа
			ЗаписьЛога = "Проверка наличия вывода данных: " + ?(ЕстьТабличныйДокумент, "ДА (" + ПричинаЛога + ")", "НЕТ");
			ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, ЗаписьЛога);
			
			Если НЕ ЕстьТабличныйДокумент Тогда
				Результат.ПроверкаВыполнена = Ложь;
				Результат.Причина = "ИИ считает задачу выполненной, но не был выполнен шаг RunQuery для отображения данных (ТабличныйДокумент). Обязательно выполни запрос к базе данных.";
			Иначе
				Результат.ПроверкаВыполнена = Истина;
				Результат.Причина = ТекстОтвета;
			КонецЕсли;
			
		Иначе
			Результат.ПроверкаВыполнена = Истина;
			Результат.Причина = ТекстОтвета;
		КонецЕсли;
		
	Иначе
		// Если не начинается с ДА, считаем что НЕТ.
		Результат.ПроверкаВыполнена = Ложь;
		Результат.Причина = ТекстОтвета;
	КонецЕсли;
	
	// Сохраняем результат проверки в хранилище
	УстановитьРезультатПроверкиВХранилище(СсылкаДиалога, Результат.ПроверкаВыполнена, Результат.Причина);
	
	Возврат Результат;
	
КонецФункции

// Генерирует следующий шаг выполнения задачи, если она не завершена
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Булево - Истина, если был сгенерирован и отправлен запрос к ИИ
//
Функция СгенерироватьПродолжениеВыполнения(СсылкаДиалога) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	// ПРОВЕРКА ПЛАНА
	Если Диалог.План.Количество() > 0 Тогда
		
		// Если все пункты плана уже выполнены, не тратим вызов ИИ
		ЕстьНевыполненные = Ложь;
		Для Каждого СтрокаПлана Из Диалог.План Цикл
			Если НЕ СтрокаПлана.Выполнена Тогда
				ЕстьНевыполненные = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если НЕ ЕстьНевыполненные Тогда
			Возврат Ложь;
		КонецЕсли;
		
		ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "[Система] Комбинированное обновление плана и генерация следующего шага...");
		
		// 1. Подготовка данных для промпта
		МассивПлана = Новый Массив;
		Для Каждого СтрокаПлана Из Диалог.План Цикл
			МассивПлана.Добавить(Новый Структура("Задача, Выполнена, Результат", СтрокаПлана.Задача, СтрокаПлана.Выполнена, СтрокаПлана.Результат));
		КонецЦикла;
		
		ЗаписьJSON = Новый ЗаписьJSON;
		ЗаписьJSON.УстановитьСтроку();
		ЗаписатьJSON(ЗаписьJSON, МассивПлана);
		ПланJSON = ЗаписьJSON.Закрыть();
		
		ТекстРезультатов = "";
		КоличествоСообщений = Диалог.Сообщения.Количество();
		// Берем результаты последних действий
		Для Индекс = Макс(0, КоличествоСообщений - 5) По КоличествоСообщений - 1 Цикл
			СтрокаСообщения = Диалог.Сообщения[Индекс];
			Если СтрокаСообщения.Автор = Перечисления.ИИА_АвторСообщения.Система Тогда
				ТекстРезультатов = ТекстРезультатов + Символы.ПС + СтрокаСообщения.Текст;
			ИначеЕсли СтрокаСообщения.Автор = Перечисления.ИИА_АвторСообщения.ИИ И НЕ ПустаяСтрока(СтрокаСообщения.ТекстКода) Тогда
				ТекстРезультатов = ТекстРезультатов + Символы.ПС + "Выполнен DSL: " + СтрокаСообщения.ТекстКода;
			КонецЕсли;
		КонецЦикла;
		
		// 2. Получение промпта
		Промпт = ИИА_Промты.ПолучитьПромптОбновленияИПланирования(ПланJSON, ТекстРезультатов);
		
		// 3. Вызов ИИ
		ОтветИИ = ВызватьИИССистемнымСообщением(СсылкаДиалога, "Запрос", Промпт);
		
		// 4. Парсинг ответа
		Если РежимОтладкиJSON(Диалог.Пользователь) Тогда
			
			// В режиме отладки НЕ используем Попытка/Исключение — ошибка должна «падать» в месте возникновения.
			ТекстОтвета = ОтветИИ.Текст;
			ТекстОтвета = ИИА_DSL.НормализоватьJSONТекст(ТекстОтвета);
			Если ПустаяСтрока(ТекстОтвета) Тогда
				ВызватьИсключение "Пустой JSON после нормализации комбинированного ответа";
			КонецЕсли;
			
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ТекстОтвета);
			РезультатКомби = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			
			Если ТипЗнч(РезультатКомби) <> Тип("Структура") Тогда
				ВызватьИсключение "Комбинированный ответ должен быть JSON объектом";
			КонецЕсли;
			
		Иначе
			
			Попытка
				
				ТекстОтвета = ОтветИИ.Текст;
				
				// Нормализация JSON (единый алгоритм)
				ТекстОтвета = ИИА_DSL.НормализоватьJSONТекст(ТекстОтвета);
				Если ПустаяСтрока(ТекстОтвета) Тогда
					Возврат Ложь;
				КонецЕсли;
				
				ЧтениеJSON = Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(ТекстОтвета);
				РезультатКомби = ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				
				Если ТипЗнч(РезультатКомби) <> Тип("Структура") Тогда
					Возврат Ложь;
				КонецЕсли;
				
			Исключение
				ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "[Система] Ошибка парсинга комбинированного ответа: " + ОписаниеОшибки());
				Возврат Ложь;
			КонецПопытки;
			
		КонецЕсли;
		
		// 4.1. Обновляем план в базе
		Если РезультатКомби.Свойство("updated_plan") И ТипЗнч(РезультатКомби.updated_plan) = Тип("Массив") Тогда
			Диалог = СсылкаДиалога.ПолучитьОбъект();
			Для Каждого ПунктОбновления Из РезультатКомби.updated_plan Цикл
				Для Каждого СтрокаПлана Из Диалог.План Цикл
					Если СтрокаПлана.Задача = ПунктОбновления.Задача Тогда
						СтрокаПлана.Выполнена = ПунктОбновления.Выполнена;
						СтрокаПлана.Результат = ПунктОбновления.Результат;
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;
			Диалог.Записать();
		КонецЕсли;
		
		// 4.2. Добавляем следующий DSL в диалог как ответ ИИ
		Если РезультатКомби.Свойство("next_step_dsl") Тогда
			
			ЗаписьDSL = Новый ЗаписьJSON;
			ЗаписьDSL.УстановитьСтроку();
			ЗаписатьJSON(ЗаписьDSL, РезультатКомби.next_step_dsl);
			ТекстDSL = ЗаписьDSL.Закрыть();
			
			ДобавитьСообщениеВДиалог(
				СсылкаДиалога,
				Перечисления.ИИА_АвторСообщения.ИИ,
				Перечисления.ИИА_ТипСообщения.Код,
				"Следующий шаг выполнения по плану",
				ТекстDSL,
				"",
				0
			);
			
			Возврат Истина;
		КонецЕсли;
		
		Возврат Ложь;
		
	Иначе
		
		// СТАРЫЙ МЕХАНИЗМ (без плана) - для совместимости или если план не создан
		
		ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "[Система] План не найден. Генерация продолжения через анализ истории...");
		
		// Получаем результат проверки
		РезультатПроверки = ПолучитьРезультатПроверкиИзХранилища(СсылкаДиалога);
		
		// Если проверки не было или она успешна - ничего не делаем
		Если РезультатПроверки = Неопределено ИЛИ РезультатПроверки.ПроверкаВыполнена = Ложь ИЛИ РезультатПроверки.СтатусПроверкиЗадачи = "Успешно" Тогда
			Возврат Ложь;
		КонецЕсли;
		
		// Если задача не выполнена, формируем промпт для продолжения
		Причина = РезультатПроверки.ПричинаПроверки;
		
		// Анализируем контекст для более точного промпта
		ДопИнструкция = "";
		
		// Получаем последние сообщения для анализа
		МассивСообщений = ПолучитьСообщенияДиалога(СсылкаДиалога, 5);
		ПоследнееСообщениеСистемы = Неопределено;
		
		// Ищем последнее системное сообщение
		Индекс = МассивСообщений.Количество() - 1;
		Пока Индекс >= 0 Цикл
			Если МассивСообщений[Индекс].Автор = Перечисления.ИИА_АвторСообщения.Система Тогда
				ПоследнееСообщениеСистемы = МассивСообщений[Индекс];
				Прервать;
			КонецЕсли;
			Индекс = Индекс - 1;
		КонецЦикла;
		
		// Если последнее сообщение содержит реквизиты (результат GetObjectFields), но задача еще не выполнена
		Если ПоследнееСообщениеСистемы <> Неопределено И СтрНайти(ПоследнееСообщениеСистемы.Текст, "Реквизиты:") > 0 Тогда
			ДопИнструкция = "Ты только что получил список реквизитов (полей). Теперь ОБЯЗАТЕЛЬНО сформируй и выполни запрос (RunQuery), используя эти точные имена полей. НЕ ОСТАНАВЛИВАЙСЯ на получении полей. Задача требует получения ДАННЫХ.";
		КонецЕсли;
		
		// Если проверка говорит, что не выполнен запрос
		Если СтрНайти(Причина, "RunQuery") > 0 ИЛИ СтрНайти(Причина, "данные") > 0 Тогда
			Если ПустаяСтрока(ДопИнструкция) Тогда
				ДопИнструкция = "Задача требует получения данных. Сформируй и выполни запрос (RunQuery).";
			КонецЕсли;
		КонецЕсли;
		
		ПромптПродолжения = "Предыдущий шаг выполнен успешно, но задача пользователя еще не решена полностью." + Символы.ПС +
		"Проанализируй историю и результаты предыдущих действий." + Символы.ПС +
		"Причина остановки (из проверки): " + Причина + Символы.ПС +
		ДопИнструкция + Символы.ПС +
		"Сгенерируй СЛЕДУЮЩИЙ шаг (DSL-сценарий) для выполнения задачи." + Символы.ПС +
		"Например, если ты получил поля объекта в предыдущем шаге, теперь сформируй и выполни запрос (RunQuery) или создай объект (CreateReference).";
		
	КонецЕсли;
	
	// Отправляем запрос ИИ как системное сообщение
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	ТипДиалога = Диалог.ТипДиалога;
	ТипСообщения = ?(ТипДиалога = Перечисления.ИИА_ТипДиалога.Запрос1С, "Запрос", "Чат");
	
	ВызватьИИССистемнымСообщением(СсылкаДиалога, ТипСообщения, ПромптПродолжения);
	
	Возврат Истина;
	
КонецФункции

#Область Integration_Gitsell

// Начинает процесс Device Flow авторизации
//
// Параметры:
//  InstanceLabel - Строка - метка установки (например "ERP Прод")
//  UserAgent - Строка - user-agent
//
// Возвращаемое значение:
//  Структура - результат:
//   * Успех - Булево
//   * Ошибка - Строка
//   * device_code - Строка
//   * user_code - Строка
//   * verification_uri_complete - Строка
//   * expires_in - Число
//   * interval - Число
//
Функция Gitsell_НачатьDeviceFlow(InstanceLabel = "1C Agent", UserAgent = "1C-Enterprise") Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Успех", Ложь);
	Результат.Вставить("Ошибка", "");
	Результат.Вставить("device_code", "");
	Результат.Вставить("user_code", "");
	Результат.Вставить("verification_uri_complete", "");
	Результат.Вставить("expires_in", 0);
	Результат.Вставить("interval", 5);
	
	Попытка
		// Генерируем новый UUID для каждой сессии авторизации (как договорились)
		InstanceId = Строка(Новый УникальныйИдентификатор);
		
		Соединение = Новый HTTPСоединение("gitsell.ru", 443, , , , , Новый ЗащищенноеСоединениеOpenSSL());
		
		Заголовки = Новый Соответствие;
		Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
		Заголовки.Вставить("Accept", "application/json");
		If НЕ ПустаяСтрока(UserAgent) Тогда
			Заголовки.Вставить("User-Agent", UserAgent);
		КонецЕсли;
		
		// Параметры запроса
		ПараметрыСтрока = "client_id=1c-agent" +
			"&scope=agent:read agent:write profile:read" +
			"&instance_id=" + КодироватьСтроку(InstanceId, СпособКодированияСтроки.URLВКодировкеURL) +
			"&instance_label=" + КодироватьСтроку(InstanceLabel, СпособКодированияСтроки.URLВКодировкеURL);
			
		Запрос = Новый HTTPЗапрос("/api/oauth/device_authorization", Заголовки);
		Запрос.УстановитьТелоИзСтроки(ПараметрыСтрока);
		
		Ответ = Соединение.ОтправитьДляОбработки(Запрос);
		ТекстОтвета = Ответ.ПолучитьТелоКакСтроку();
		
		Если Ответ.КодСостояния = 200 Тогда
			Попытка
				ЧтениеJSON = Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(ТекстОтвета);
				Данные = ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				
				Результат.Успех = Истина;
				Результат.device_code = Данные.device_code;
				Результат.user_code = Данные.user_code;
				Результат.verification_uri_complete = Данные.verification_uri_complete;
				Результат.expires_in = Данные.expires_in;
				Результат.interval = Данные.interval;
			Исключение
				Результат.Ошибка = "Ошибка парсинга ответа: " + ОписаниеОшибки();
			КонецПопытки;
		Иначе
			Результат.Ошибка = "Ошибка сервера (" + Ответ.КодСостояния + "): " + ТекстОтвета;
		КонецЕсли;
		
	Исключение
		Результат.Ошибка = "Ошибка соединения: " + ОписаниеОшибки();
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Опрашивает статус токена
//
// Параметры:
//  DeviceCode - Строка - код устройства
//
// Возвращаемое значение:
//  Структура - результат:
//   * Статус - Строка (success, pending, slow_down, expired, denied, error)
//   * Токен - Строка (если успех)
//   * Ошибка - Строка
//
Функция Gitsell_ОпросТокена(DeviceCode) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Статус", "error");
	Результат.Вставить("Токен", "");
	Результат.Вставить("Ошибка", "");
	
	Попытка
		Соединение = Новый HTTPСоединение("gitsell.ru", 443, , , , , Новый ЗащищенноеСоединениеOpenSSL());
		
		Заголовки = Новый Соответствие;
		Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
		Заголовки.Вставить("Accept", "application/json");
		
		ПараметрыСтрока = "client_id=1c-agent" +
			"&grant_type=urn:ietf:params:oauth:grant-type:device_code" +
			"&device_code=" + КодироватьСтроку(DeviceCode, СпособКодированияСтроки.URLВКодировкеURL);
			
		Запрос = Новый HTTPЗапрос("/api/oauth/token", Заголовки);
		Запрос.УстановитьТелоИзСтроки(ПараметрыСтрока);
		
		Ответ = Соединение.ОтправитьДляОбработки(Запрос);
		ТекстОтвета = Ответ.ПолучитьТелоКакСтроку();
		
		// Пытаемся распарсить JSON
		Данные = Неопределено;
		Попытка
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ТекстОтвета);
			Данные = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
		Исключение
			// Ошибка парсинга - оставляем Данные = Неопределено
		КонецПопытки;
		
		Если Ответ.КодСостояния = 200 Тогда
			Если Данные <> Неопределено И Данные.Свойство("ai_proxy_token") Тогда
				Результат.Статус = "success";
				Результат.Токен = Данные.ai_proxy_token;
				
				// Получаем email, если access_token есть в ответе
				Если Данные.Свойство("access_token") Тогда
					Попытка
						СоединениеAPI = Новый HTTPСоединение("gitsell.ru", 443, , , , , Новый ЗащищенноеСоединениеOpenSSL());
						ЗаголовкиAPI = Новый Соответствие;
						ЗаголовкиAPI.Вставить("Authorization", "Bearer " + Данные.access_token);
						ЗапросAPI = Новый HTTPЗапрос("/api/me", ЗаголовкиAPI);
						ОтветAPI = СоединениеAPI.Получить(ЗапросAPI);
						
						Если ОтветAPI.КодСостояния = 200 Тогда
							ЧтениеJSON_API = Новый ЧтениеJSON;
							ЧтениеJSON_API.УстановитьСтроку(ОтветAPI.ПолучитьТелоКакСтроку());
							ДанныеAPI = ПрочитатьJSON(ЧтениеJSON_API);
							ЧтениеJSON_API.Закрыть();
							
							Если ДанныеAPI.Свойство("email") Тогда
								Результат.Вставить("Email", ДанныеAPI.email);
							КонецЕсли;
						КонецЕсли;
					Исключение
						// Игнорируем ошибки получения email
					КонецПопытки;
				КонецЕсли;
				
			Иначе
				Результат.Ошибка = "В ответе нет ai_proxy_token" + ?(Данные = Неопределено, " (JSON не распознан)", "");
			КонецЕсли;
		Иначе
			// Обработка ошибок OAuth
			Если Данные <> Неопределено И Данные.Свойство("error") Тогда
				КодОшибки = Данные.error;
				Если КодОшибки = "authorization_pending" Тогда
					Результат.Статус = "pending";
				ИначеЕсли КодОшибки = "slow_down" Тогда
					Результат.Статус = "slow_down";
				ИначеЕсли КодОшибки = "expired_token" Тогда
					Результат.Статус = "expired";
				ИначеЕсли КодОшибки = "access_denied" Тогда
					Результат.Статус = "denied";
				Иначе
					Результат.Статус = "error";
					Результат.Ошибка = "Ошибка OAuth: " + КодОшибки;
				КонецЕсли;
			Иначе
				Результат.Ошибка = "Ошибка сервера (" + Ответ.КодСостояния + "): " + ТекстОтвета;
			КонецЕсли;
		КонецЕсли;
		
	Исключение
		Результат.Ошибка = "Ошибка соединения: " + ОписаниеОшибки();
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Сохраняет токен AI Proxy в настройки
//
// Параметры:
//  Токен - Строка
//  Email - Строка - (необязательно) email пользователя
//
Процедура Gitsell_СохранитьAiProxyToken(Токен, Email = "") Экспорт
	
	Пользователь = ИмяТекущегоПользователя();
	
	НаборЗаписей = РегистрыСведений.ИИА_НастройкиПользователей.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Пользователь.Установить(Пользователь);
	НаборЗаписей.Прочитать();
	
	Если НаборЗаписей.Количество() = 0 Тогда
		Запись = НаборЗаписей.Добавить();
		Запись.Пользователь = Пользователь;
	Иначе
		Запись = НаборЗаписей[0];
	КонецЕсли;
	
	Запись.Provider_ApiKey = Токен;
	Запись.Provider_BaseUrl = "https://gitsell.ru/api/v1"; // Стандартный URL
	Запись.Модель = "auto";
	
	Если ЗначениеЗаполнено(Email) Тогда
		Запись.email = Email;
	КонецЕсли;
	
	НаборЗаписей.Записать();
	
КонецПроцедуры

// Проверяет работу токена (GET /models)
//
// Возвращаемое значение:
//  Структура (Успех, Ошибка)
//
Функция Gitsell_ПроверитьModels() Экспорт
	
	Результат = Новый Структура("Успех, Ошибка", Ложь, "");
	
	Попытка
		// Получаем токен из настроек
		Настройки = ПолучитьНастройкиПользователя();
		Токен = Настройки.Provider_ApiKey;
		
		Если ПустаяСтрока(Токен) Тогда
			Результат.Ошибка = "Токен не найден в настройках";
			Возврат Результат;
		КонецЕсли;
		
		Соединение = Новый HTTPСоединение("gitsell.ru", 443, , , , , Новый ЗащищенноеСоединениеOpenSSL());
		
		Заголовки = Новый Соответствие;
		Заголовки.Вставить("Authorization", "Bearer " + Токен);
		
		Запрос = Новый HTTPЗапрос("/api/v1/models", Заголовки);
		Ответ = Соединение.Получить(Запрос);
		
		Если Ответ.КодСостояния = 200 Тогда
			Результат.Успех = Истина;
		Иначе
			Результат.Ошибка = "Ошибка проверки токена (" + Ответ.КодСостояния + "): " + Ответ.ПолучитьТелоКакСтроку();
		КонецЕсли;
		
	Исключение
		Результат.Ошибка = "Ошибка соединения: " + ОписаниеОшибки();
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Проверяет наличие настроек пользователя (любого пользователя в регистре)
//
// Возвращаемое значение:
//  Булево - Истина, если есть хотя бы одна настройка
//
Функция ЕстьНастройкиПользователя() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Настройки.Пользователь
	|ИЗ
	|	РегистрСведений.ИИА_НастройкиПользователей КАК Настройки";
	
	Результат = Запрос.Выполнить();
	Возврат НЕ Результат.Пустой();
	
КонецФункции

#КонецОбласти

#КонецОбласти
