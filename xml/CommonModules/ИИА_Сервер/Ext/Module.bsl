#Область ПрограммныйИнтерфейс

// Извлекает названия сущностей из запроса пользователя через ИИ
//
// Параметры:
//  ТекстЗапроса - Строка - исходный запрос
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - (опционально) ссылка на диалог для логирования
//
// Возвращаемое значение:
//  Строка - извлеченные сущности или пустая строка
Функция ИзвлечьСущностиДляRAG(Знач ТекстЗапроса, Знач СсылкаДиалога = Неопределено) Экспорт
	
	// Не передавать JSON (DSL) в экстрактор — только текст запроса пользователя
	ТекстОбрезанный = СокрЛП(ТекстЗапроса);
	Если СтрДлина(ТекстОбрезанный) > 0 И (Лев(ТекстОбрезанный, 1) = "{" ИЛИ Лев(ТекстОбрезанный, 1) = "[") Тогда
		Возврат "";
	КонецЕсли;
	
	Промпт = ИИА_Промты.ПолучитьПромптЭкстрактораСущностей(ТекстЗапроса);
	
	// Получаем текущие параметры провайдера
	ПараметрыИИ = ПолучитьНастройкиПользователя(ИмяТекущегоПользователя());
	
	Если ПараметрыИИ = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	// Передаем ссылку на диалог для логирования RAG
	ПараметрыИИ.Вставить("СсылкаДиалога", СсылкаДиалога);
	// Запрещаем рекурсивный вызов RAG внутри экстрактора
	ПараметрыИИ.Вставить("ИспользоватьRAG", Ложь);
	
	ПараметрыИИ.Вставить("ExpectedResponseFormat", "text");
	
	// Вызываем ИИ через стандартный интерфейс провайдера
	ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "[ENTITY_EXTRACTOR] Запрос к ИИ для извлечения сущностей...");
	ОтветИИ = ИИА_Провайдеры.ВызватьИИ("Чат", Промпт, Неопределено, ПараметрыИИ, "", 0.0);
	
	// В ответе ИИ может быть поле Успех или Ошибки. Проверим наличие текста.
	Если НЕ ПустаяСтрока(ОтветИИ.Текст) Тогда
		Результат = СокрЛП(ОтветИИ.Текст);
		ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "[ENTITY_EXTRACTOR] Результат: " + Результат);
		Если ВРег(Результат) = "НЕТ" Тогда
			Возврат "";
		КонецЕсли;
		Возврат Результат;
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

Функция РежимОтладкиJSON(Знач Пользователь = "") Экспорт
	// В этом общем модуле нельзя использовать Перем на уровне модуля,
	// поэтому режим отладки читаем из настроек пользователя.
	ПараметрыПользователя = ПолучитьНастройкиПользователя(Пользователь);
	Если ПараметрыПользователя <> Неопределено И ПараметрыПользователя.Свойство("РежимОтладки") Тогда
		Возврат ПараметрыПользователя.РежимОтладки;
	КонецЕсли;
	Возврат Ложь;
КонецФункции

// Возвращает имя текущего пользователя ИБ или "Администратор" по умолчанию
Функция ИмяТекущегоПользователя() Экспорт
	
	Пользователь = "";
	Попытка
		Пользователь = ПользователиИнформационнойБазы.ТекущийПользователь().Имя;
	Исключение
		ТекстОшибки = ОписаниеОшибки();
	КонецПопытки;
	
	Если ПустаяСтрока(Пользователь) Тогда
		Пользователь = "Администратор";
	КонецЕсли;
	
	Возврат Пользователь;
	
КонецФункции

Функция ОпределитьRAGДляСообщения(ТекстПользователя, ТипДиалога) Экспорт
	
	Результат = Новый Структура("ИспользоватьRAG,Причина", Ложь, "");
	
	Если ТипДиалога = Перечисления.ИИА_ТипДиалога.Запрос1С Тогда
		Результат.ИспользоватьRAG = Истина;
		Результат.Причина = "Тип диалога Запрос1С";
		Возврат Результат;
	КонецЕсли;
	
	Если ПустаяСтрока(ТекстПользователя) Тогда
		Результат.Причина = "Пустой текст запроса";
		Возврат Результат;
	КонецЕсли;
	
	ТекстВРег = ВРег(ТекстПользователя);
	
	Ключевые = Новый Массив;
	Ключевые.Добавить("ДОКУМЕНТ");
	Ключевые.Добавить("СПРАВОЧНИК");
	Ключевые.Добавить("РЕГИСТР");
	Ключевые.Добавить("ПЕРЕЧИСЛЕНИ");
	Ключевые.Добавить("НАКЛАДН");
	Ключевые.Добавить("РЕАЛИЗАЦ");
	Ключевые.Добавить("ОТГРУЗК");
	Ключевые.Добавить("ПОСТУПЛЕН");
	Ключевые.Добавить("ПЕРЕМЕЩЕН");
	Ключевые.Добавить("СЧЕТ");
	Ключевые.Добавить("АКТ");
	Ключевые.Добавить("ПЛАТЕЖ");
	Ключевые.Добавить("КАСС");
	Ключевые.Добавить("СКЛАД");
	Ключевые.Добавить("ТОВАР");
	Ключевые.Добавить("УСЛУГ");
	
	Для Каждого Ключ Из Ключевые Цикл
		Если СтрНайти(ТекстВРег, Ключ) > 0 Тогда
			Результат.ИспользоватьRAG = Истина;
			Результат.Причина = "Найдены ключевые слова метаданных";
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	
	Результат.Причина = "Ключевые слова метаданных не найдены";
	Возврат Результат;
	
КонецФункции

// Получает настройки пользователя из регистра сведений
//
// Параметры:
//  Пользователь - Строка - имя пользователя, для которого получить настройки
	//
	// Возвращаемое значение:
	//  Структура - структура с настройками:
	//   * Provider_BaseURL - Строка
	//   * Provider_ApiKey - Строка
	//   * ЛимитТокеновНаЗапуск - Число
	//   * Модель - Строка
	//   * email - Строка
	//
	Функция ПолучитьНастройкиПользователя(Знач Пользователь = "") Экспорт 
		
		Если ПустаяСтрока(Пользователь) Тогда
			Пользователь = ИмяТекущегоПользователя();
		КонецЕсли;
		
		Результат = Новый Структура;
		Результат.Вставить("Provider_BaseUrl", "");
		Результат.Вставить("Provider_ApiKey", "");
		Результат.Вставить("ЛимитТокеновНаЗапуск", 0);
		Результат.Вставить("Модель", "");
		Результат.Вставить("email", "");
	Результат.Вставить("РежимОтладки", Ложь);
	// По умолчанию запись разрешена (чтобы не ломать существующее поведение)
	Результат.Вставить("ДоступнаЗапись", Истина);
	Результат.Вставить("ПутьКЛогуОтладки", "");
		
		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ
		|	НастройкиПользователя.Provider_BaseUrl,
		|	НастройкиПользователя.Provider_ApiKey,
		|	НастройкиПользователя.ЛимитТокеновНаЗапуск,
		|	НастройкиПользователя.Модель,
	|	НастройкиПользователя.email,
	|	НастройкиПользователя.РежимОтладки,
	|	НастройкиПользователя.ДоступнаЗапись,
	|	НастройкиПользователя.ПутьКЛогуОтладки
		|ИЗ
		|	РегистрСведений.ИИА_НастройкиПользователей КАК НастройкиПользователя
		|ГДЕ
		|	НастройкиПользователя.Пользователь = &Пользователь";
		
		Запрос.УстановитьПараметр("Пользователь", Пользователь);
		
		РезультатЗапроса = Запрос.Выполнить();
		
		Если РезультатЗапроса.Пустой() Тогда
			Возврат Результат;
		КонецЕсли;
		
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		
		Результат.Provider_BaseUrl = Выборка.Provider_BaseUrl;
		Результат.Provider_ApiKey = Выборка.Provider_ApiKey;
		Результат.ЛимитТокеновНаЗапуск = Выборка.ЛимитТокеновНаЗапуск;
		Результат.Модель = Выборка.Модель;
		Результат.email = Выборка.email;
		
		// Выборка результата запроса не поддерживает метод Свойство().
		// Читаем новые поля через Попытка/Исключение для совместимости со старыми версиями регистра.
		Попытка
			Результат.РежимОтладки = Выборка.РежимОтладки;
		Исключение
			Результат.РежимОтладки = Ложь;
		КонецПопытки;
		
		Попытка
			Результат.ДоступнаЗапись = Выборка.ДоступнаЗапись;
		Исключение
			Результат.ДоступнаЗапись = Истина;
		КонецПопытки;
		
		Попытка
			Результат.ПутьКЛогуОтладки = Выборка.ПутьКЛогуОтладки;
		Исключение
			Результат.ПутьКЛогуОтладки = "";
		КонецПопытки;
		
		Возврат Результат;
		
	КонецФункции

// Функции для работы с Гигачат перенесены в модуль ИИА_Гигачат

// Находит активный диалог пользователя или создает новый
//
// Параметры:
//  Пользователь - СправочникСсылка.Пользователи - пользователь
//
// Возвращаемое значение:
//  СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
Функция НайтиИлиСоздатьДиалогПользователя(Пользователь) Экспорт
	
	// Ищем последний диалог пользователя (по дате создания)
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Диалоги.Ссылка
	|ИЗ
	|	Справочник.ИИА_Диалоги КАК Диалоги
	|ГДЕ
	|	Диалоги.Пользователь = &Пользователь
	|УПОРЯДОЧИТЬ ПО
	|	Диалоги.ДатаСоздания УБЫВ";
	
	Запрос.УстановитьПараметр("Пользователь", Пользователь);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат Выборка.Ссылка;
	КонецЕсли;
	
	// Создаем новый диалог
	НовыйДиалог = Справочники.ИИА_Диалоги.СоздатьЭлемент();
	НовыйДиалог.Пользователь = Пользователь;
	НаименованиеДиалога = "Диалог ИИ от " + Формат(ТекущаяДатаСеанса(), "ДФ=dd.MM.yyyy HH:mm:ss");
	НовыйДиалог.Наименование = НаименованиеДиалога;
	НовыйДиалог.ДатаСоздания = ТекущаяДатаСеанса();
	НовыйДиалог.ТипДиалога = Перечисления.ИИА_ТипДиалога.Агент;
	НовыйДиалог.Записать();
	
	Возврат НовыйДиалог.Ссылка;
	
КонецФункции

// Создает новый диалог для текущего пользователя
//
// Возвращаемое значение:
//  СправочникСсылка.ИИА_Диалоги - ссылка на новый диалог
//
Функция СоздатьНовыйДиалог(Пользователь, ТипДиалога = Неопределено) Экспорт
	
	// Создаем новый диалог
	НовыйДиалог = Справочники.ИИА_Диалоги.СоздатьЭлемент();
	НовыйДиалог.Пользователь = Пользователь;
	НаименованиеДиалога = "Диалог ИИ от " + Формат(ТекущаяДатаСеанса(), "ДФ=dd.MM.yyyy HH:mm:ss");
	НовыйДиалог.Наименование = НаименованиеДиалога;
	НовыйДиалог.ДатаСоздания = ТекущаяДатаСеанса();
	
	// Устанавливаем тип диалога
	Если ТипДиалога <> Неопределено Тогда
		НовыйДиалог.ТипДиалога = ТипДиалога;
	Иначе
		// По умолчанию - Агент
		НовыйДиалог.ТипДиалога = Перечисления.ИИА_ТипДиалога.Агент;
	КонецЕсли;
	
	НовыйДиалог.Записать();
	
	Возврат НовыйДиалог.Ссылка;
	
КонецФункции

// Получает сообщения диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  Количество - Число - количество последних сообщений (0 - все сообщения)
//
// Возвращаемое значение:
//  Массив - массив структур с сообщениями
//
Функция ПолучитьСообщенияДиалога(СсылкаДиалога, Количество = 0) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	ОбеспечитьКорректныеИдентификаторыСообщений(Диалог);
	
	МассивСообщений = Новый Массив;
	
	ИндексНачала = 0;
	Если Количество > 0 Тогда
		ИндексНачала = Макс(0, Диалог.Сообщения.Количество() - Количество);
	КонецЕсли;
	
	Для Индекс = ИндексНачала По Диалог.Сообщения.Количество() - 1 Цикл
		
		Строка = Диалог.Сообщения[Индекс];
		
		СтруктураСообщения = Новый Структура;
		СтруктураСообщения.Вставить("Время", Строка.Время);
		СтруктураСообщения.Вставить("Автор", Строка.Автор);
		СтруктураСообщения.Вставить("ТипСообщения", Строка.ТипСообщения);
		СтруктураСообщения.Вставить("Текст", Строка.Текст);
		СтруктураСообщения.Вставить("ТекстКода", Строка.ТекстКода);
		СтруктураСообщения.Вставить("Статус", Строка.Статус);
		СтруктураСообщения.Вставить("UsageTokens", Строка.UsageTokens);
		СтруктураСообщения.Вставить("СтатусDSL", Строка.СтатусDSL);
		СтруктураСообщения.Вставить("УИД", Строка.УИД);
		СтруктураСообщения.Вставить("СкрытоеСлужебное", Строка.СкрытоеСлужебное);
		
		МассивСообщений.Добавить(СтруктураСообщения);
		
	КонецЦикла;
	
	Возврат МассивСообщений;
	
КонецФункции

Процедура ОбеспечитьКорректныеИдентификаторыСообщений(Диалог)
	Если Диалог = Неопределено Тогда
		ВызватьИсключение "Ошибка синхронизации сообщений: объект диалога не определен.";
	КонецЕсли;
	
	БылиИзменения = Ложь;
	ВстреченныеУИД = Новый Соответствие;
	
	Для Каждого СтрокаСообщения Из Диалог.Сообщения Цикл
		УИДСтроки = "";
		Если ЗначениеЗаполнено(СтрокаСообщения.УИД) Тогда
			УИДСтроки = СокрЛП(Строка(СтрокаСообщения.УИД));
		КонецЕсли;
		
		Если ПустаяСтрока(УИДСтроки) Тогда
			УИДСтроки = Строка(Новый УникальныйИдентификатор());
			СтрокаСообщения.УИД = Лев(УИДСтроки, 36);
			БылиИзменения = Истина;
		Иначе
			УИДСтроки = Лев(УИДСтроки, 36);
			Если УИДСтроки <> СтрокаСообщения.УИД Тогда
				СтрокаСообщения.УИД = УИДСтроки;
				БылиИзменения = Истина;
			КонецЕсли;
		КонецЕсли;
		
		Если ВстреченныеУИД.Получить(УИДСтроки) <> Неопределено Тогда
			ВызватьИсключение "Ошибка синхронизации сообщений: обнаружен дублирующийся УИД '" + УИДСтроки + "'.";
		КонецЕсли;
		ВстреченныеУИД.Вставить(УИДСтроки, Истина);
		
		НовоеСкрытоеСлужебное = ЭтоСкрытоеСлужебноеСообщение(
			СтрокаСообщения.Автор,
			СтрокаСообщения.ТипСообщения,
			СтрокаСообщения.Текст,
			СтрокаСообщения.ТекстКода
		);
		
		Если СтрокаСообщения.СкрытоеСлужебное = Неопределено 
			ИЛИ СтрокаСообщения.СкрытоеСлужебное <> НовоеСкрытоеСлужебное Тогда
			СтрокаСообщения.СкрытоеСлужебное = НовоеСкрытоеСлужебное;
			БылиИзменения = Истина;
		КонецЕсли;
	КонецЦикла;
	
	Если БылиИзменения Тогда
		Попытка
			Диалог.Записать();
		Исключение
			ВызватьИсключение "Ошибка записи УИД сообщений в диалог: " + ОписаниеОшибки();
		КонецПопытки;
	КонецЕсли;
КонецПроцедуры

// Получает первое сообщение пользователя из диалога (исходную задачу)
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Структура - структура с информацией о первом сообщении пользователя:
//   * Найдено - Булево - найдено ли сообщение
//   * Текст - Строка - текст сообщения
//
Функция ПолучитьПервоеСообщениеПользователя(СсылкаДиалога) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Найдено", Ложь);
	Результат.Вставить("Текст", "");
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	Если Диалог.Сообщения.Количество() = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Ищем первое сообщение пользователя (исходную задачу)
	Для Индекс = 0 По Диалог.Сообщения.Количество() - 1 Цикл
		
		СтрокаСообщения = Диалог.Сообщения[Индекс];
		
		Если СтрокаСообщения.Автор = Перечисления.ИИА_АвторСообщения.Пользователь Тогда
			Результат.Найдено = Истина;
			Результат.Текст = СтрокаСообщения.Текст;
			Возврат Результат;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Получает последнее сообщение пользователя из диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Структура - структура с информацией о последнем сообщении пользователя:
//   * Найдено - Булево - найдено ли сообщение
//   * Текст - Строка - текст сообщения
//
Функция ПолучитьПоследнееСообщениеПользователя(СсылкаДиалога) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Найдено", Ложь);
	Результат.Вставить("Текст", "");
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	Если Диалог.Сообщения.Количество() = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Ищем последнее сообщение пользователя
	Индекс = Диалог.Сообщения.Количество() - 1;
	Пока Индекс >= 0 Цикл
		
		СтрокаСообщения = Диалог.Сообщения[Индекс];
		
		Если СтрокаСообщения.Автор = Перечисления.ИИА_АвторСообщения.Пользователь Тогда
			Результат.Найдено = Истина;
			Результат.Текст = СтрокаСообщения.Текст;
			Возврат Результат;
		КонецЕсли;
		
		Индекс = Индекс - 1;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Инициализирует план выполнения задачи в диалоге
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Булево - Истина, если план успешно создан
//
// Функции планирования и оркестрации перенесены в модуль ИИА_Оркестратор

// Получает последнее DSL сообщение и его статус
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Структура - структура с информацией о последнем DSL сообщении:
//   * Найдено - Булево - найдено ли сообщение
//   * СтатусDSL - ПеречислениеСсылка.ИИА_СтатусDSL - статус DSL
//   * ТекстКода - Строка - текст DSL
//
Функция ПолучитьПоследнееDSLСообщение(СсылкаДиалога) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Найдено", Ложь);
	Результат.Вставить("СтатусDSL", Неопределено);
	Результат.Вставить("ТекстКода", "");
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	Если Диалог.Сообщения.Количество() = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Ищем последнее сообщение с DSL (тип Код)
	Индекс = Диалог.Сообщения.Количество() - 1;
	Пока Индекс >= 0 Цикл
		
		СтрокаСообщения = Диалог.Сообщения[Индекс];
		
		Если СтрокаСообщения.ТипСообщения = Перечисления.ИИА_ТипСообщения.Код 
			И НЕ ПустаяСтрока(СтрокаСообщения.ТекстКода) Тогда
			Результат.Найдено = Истина;
			Результат.СтатусDSL = СтрокаСообщения.СтатусDSL;
			Результат.ТекстКода = СтрокаСообщения.ТекстКода;
			Возврат Результат;
		КонецЕсли;
		
		Индекс = Индекс - 1;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Получает общее количество использованных токенов в диалоге
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Число - общее количество использованных токенов
//
Функция ПолучитьОбщееКоличествоТокенов(СсылкаДиалога) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	ОбщееКоличествоТокенов = 0;
	
	Для Каждого СтрокаСообщения Из Диалог.Сообщения Цикл
		Если ЗначениеЗаполнено(СтрокаСообщения.UsageTokens) Тогда
			ОбщееКоличествоТокенов = ОбщееКоличествоТокенов + СтрокаСообщения.UsageTokens;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ОбщееКоличествоТокенов;
	
КонецФункции

// Возвращает структуру данных диалога из регистра ИИА_ДанныеДиалогов (или Неопределено/пустую структуру).
//
Функция ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога) Экспорт
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) Тогда
		Возврат Неопределено;
	КонецЕсли;
	МенеджерЗаписи = РегистрыСведений.ИИА_ДанныеДиалогов.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.Диалог = СсылкаДиалога;
	МенеджерЗаписи.Прочитать();
	Если НЕ МенеджерЗаписи.Выбран() Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если НЕ ЗначениеЗаполнено(МенеджерЗаписи.ХранилищеЗначения) Тогда
		Возврат Неопределено;
	КонецЕсли;
	Попытка
		Данные = МенеджерЗаписи.ХранилищеЗначения.Получить();
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			Возврат Данные;
		КонецЕсли;
	Исключение
		ТекстОшибки = ОписаниеОшибки();
	КонецПопытки;
	Возврат Неопределено;
КонецФункции

// Записывает структуру данных диалога в регистр ИИА_ДанныеДиалогов.
// Сохраняет ОркестраторВключен, чтобы не сбрасывать флаг оркестратора.
//
Процедура ЗаписатьДанныеДиалогаВРегистр(СсылкаДиалога, СтруктураДанных) Экспорт
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) ИЛИ СсылкаДиалога.Пустая() Тогда
		Возврат;
	КонецЕсли;
	Если ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	МенеджерЗаписи = РегистрыСведений.ИИА_ДанныеДиалогов.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.Диалог = СсылкаДиалога;
	МенеджерЗаписи.Прочитать();
	Если НЕ МенеджерЗаписи.Выбран() Тогда
		МенеджерЗаписи.Диалог = СсылкаДиалога;
		МенеджерЗаписи.ОркестраторВключен = Ложь;
		МенеджерЗаписи.ХранилищеЗначения = Новый ХранилищеЗначения(СтруктураДанных);
	Иначе
		СохранитьОркестратор = МенеджерЗаписи.ОркестраторВключен = Истина;
		МенеджерЗаписи.ХранилищеЗначения = Новый ХранилищеЗначения(СтруктураДанных);
		МенеджерЗаписи.ОркестраторВключен = СохранитьОркестратор;
	КонецЕсли;
	МенеджерЗаписи.Записать();
КонецПроцедуры

// Очищает сохранённый контекст DSL для диалога (вызывать при завершении плана)
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
Процедура ОчиститьКонтекстDSLДиалога(СсылкаДиалога) Экспорт
	
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) ИЛИ СсылкаДиалога.Пустая() Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураДанных = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
	Если СтруктураДанных = Неопределено ИЛИ ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	
	КлючиDSL = Новый Массив;
	КлючиDSL.Добавить("DSL_СсылкаОбъекта");
	КлючиDSL.Добавить("DSL_ТипОбъекта");
	КлючиDSL.Добавить("DSL_ИмяОбъекта");
	
	ЕстьИзменения = Ложь;
	Для Каждого Ключ Из КлючиDSL Цикл
		Если СтруктураДанных.Свойство(Ключ) Тогда
			СтруктураДанных.Удалить(Ключ);
			ЕстьИзменения = Истина;
		КонецЕсли;
	КонецЦикла;
	
	Если ЕстьИзменения Тогда
		ЗаписатьДанныеДиалогаВРегистр(СсылкаДиалога, СтруктураДанных);
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает очередь mock-ответов для режима холостого хода (тесты без вызова ИИ).
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  МассивMockОтветов - Массив - массив структур или строк (каждый элемент — mock для очередного вызова ИИ)
//
Процедура УстановитьОчередьMockОтветов(СсылкаДиалога, МассивMockОтветов) Экспорт
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) ИЛИ СсылкаДиалога.Пустая() Тогда
		Возврат;
	КонецЕсли;
	СтруктураДанных = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
	Если СтруктураДанных = Неопределено ИЛИ ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
		СтруктураДанных = Новый Структура;
	КонецЕсли;
	СтруктураДанных.Вставить("MockОтветыОчередь", МассивMockОтветов);
	ЗаписатьДанныеДиалогаВРегистр(СсылкаДиалога, СтруктураДанных);
КонецПроцедуры

// Очищает очередь mock-ответов для диалога.
//
Процедура ОчиститьОчередьMockОтветов(СсылкаДиалога) Экспорт
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) ИЛИ СсылкаДиалога.Пустая() Тогда
		Возврат;
	КонецЕсли;
	СтруктураДанных = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
	Если СтруктураДанных = Неопределено ИЛИ ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	Если СтруктураДанных.Свойство("MockОтветыОчередь") Тогда
		СтруктураДанных.Удалить("MockОтветыОчередь");
		ЗаписатьДанныеДиалогаВРегистр(СсылкаДиалога, СтруктураДанных);
	КонецЕсли;
КонецПроцедуры

// Получает список ключей из хранилища значений диалога (регистр ИИА_ДанныеДиалогов)
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Массив - массив строк с ключами хранилища
//
Функция ПолучитьКлючиХранилища(СсылкаДиалога) Экспорт
	
	Результат = Новый Массив;
	
	Попытка
		СтруктураДанных = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
		Если СтруктураДанных = Неопределено ИЛИ ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
			Возврат Результат;
		КонецЕсли;
		
		Для Каждого КлючЗначение Из СтруктураДанных Цикл
			Результат.Добавить(КлючЗначение.Ключ);
		КонецЦикла;
		
	Исключение
		// В случае ошибки возвращаем пустой массив
		ТекстОшибки = ОписаниеОшибки();
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Инициализирует архитектурный контекст исполнения диалога:
// trace_id, prompt_version, режим выполнения DSL, capability-модель.
Процедура ИнициализироватьКонтекстАрхитектуры(СсылкаДиалога, PromptVersion = "", DSLРежим = "commit") Экспорт
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) Тогда
		Возврат;
	КонецЕсли;
	
	Если ПустаяСтрока(PromptVersion) Тогда
		PromptVersion = ИИА_Промты.ПолучитьВерсиюПромптов();
		Если ПустаяСтрока(PromptVersion) Тогда
			ВызватьИсключение "Не удалось определить Prompt-Version для архитектурного контекста.";
		КонецЕсли;
	КонецЕсли;
	
	СтруктураДанных = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
	Если СтруктураДанных = Неопределено ИЛИ ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
		СтруктураДанных = Новый Структура;
	КонецЕсли;
	
	Если НЕ СтруктураДанных.Свойство("trace_id") ИЛИ ПустаяСтрока(Строка(СтруктураДанных.trace_id)) Тогда
		СтруктураДанных.Вставить("trace_id", Строка(Новый УникальныйИдентификатор()));
	КонецЕсли;
	
	СтруктураДанных.Вставить("prompt_version", PromptVersion);
	СтруктураДанных.Вставить("DSL_РежимВыполнения", DSLРежим);
	
	Если НЕ СтруктураДанных.Свойство("DSL_Capabilities") ИЛИ ТипЗнч(СтруктураДанных.DSL_Capabilities) <> Тип("Массив") Тогда
		Capabilities = Новый Массив;
		Capabilities.Добавить("metadata.read");
		Capabilities.Добавить("data.read");
		Capabilities.Добавить("data.write.reference");
		Capabilities.Добавить("data.write.document");
		Capabilities.Добавить("admin.settings");
		СтруктураДанных.Вставить("DSL_Capabilities", Capabilities);
	КонецЕсли;
	
	ЗаписатьДанныеДиалогаВРегистр(СсылкаДиалога, СтруктураДанных);
КонецПроцедуры

Функция ПолучитьКонтекстАрхитектуры(СсылкаДиалога) Экспорт
	Результат = Новый Структура("trace_id,prompt_version,DSL_РежимВыполнения,DSL_Capabilities", "", "", "commit", Новый Массив);
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) Тогда
		Возврат Результат;
	КонецЕсли;
	
	СтруктураДанных = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
	Если СтруктураДанных = Неопределено ИЛИ ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если СтруктураДанных.Свойство("trace_id") Тогда
		Результат.trace_id = Строка(СтруктураДанных.trace_id);
	КонецЕсли;
	Если СтруктураДанных.Свойство("prompt_version") Тогда
		Результат.prompt_version = Строка(СтруктураДанных.prompt_version);
	КонецЕсли;
	Если СтруктураДанных.Свойство("DSL_РежимВыполнения") Тогда
		Результат.DSL_РежимВыполнения = Строка(СтруктураДанных.DSL_РежимВыполнения);
	КонецЕсли;
	Если СтруктураДанных.Свойство("DSL_Capabilities") Тогда
		Результат.DSL_Capabilities = СтруктураДанных.DSL_Capabilities;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

Функция ПолучитьСостояниеОркестратора(СсылкаДиалога) Экспорт
	Результат = Новый Структура("ТекущаяСтадия,ПоследнийПереход,НомерПопытки", "Intent", "", 0);
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) Тогда
		Возврат Результат;
	КонецЕсли;
	
	СтруктураДанных = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
	Если СтруктураДанных = Неопределено ИЛИ ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если СтруктураДанных.Свойство("Оркестратор_Стадия") Тогда
		Результат.ТекущаяСтадия = Строка(СтруктураДанных.Оркестратор_Стадия);
	КонецЕсли;
	Если СтруктураДанных.Свойство("Оркестратор_Переход") Тогда
		Результат.ПоследнийПереход = Строка(СтруктураДанных.Оркестратор_Переход);
	КонецЕсли;
	Если СтруктураДанных.Свойство("Оркестратор_Попытка") Тогда
		Результат.НомерПопытки = СтруктураДанных.Оркестратор_Попытка;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

Процедура УстановитьСостояниеОркестратора(СсылкаДиалога, Стадия, Переход = "", УвеличитьПопытку = Ложь) Экспорт
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураДанных = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
	Если СтруктураДанных = Неопределено ИЛИ ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
		СтруктураДанных = Новый Структура;
	КонецЕсли;
	
	ПопыткаНомер = 0;
	Если СтруктураДанных.Свойство("Оркестратор_Попытка") Тогда
		ПопыткаНомер = СтруктураДанных.Оркестратор_Попытка;
	КонецЕсли;
	Если УвеличитьПопытку Тогда
		ПопыткаНомер = ПопыткаНомер + 1;
	ИначеЕсли Переход = "reset_attempt" Тогда
		ПопыткаНомер = 0;
	КонецЕсли;
	
	СтруктураДанных.Вставить("Оркестратор_Стадия", Стадия);
	СтруктураДанных.Вставить("Оркестратор_Переход", Переход);
	СтруктураДанных.Вставить("Оркестратор_Попытка", ПопыткаНомер);
	ЗаписатьДанныеДиалогаВРегистр(СсылкаДиалога, СтруктураДанных);
КонецПроцедуры

Процедура СохранитьАртефактПланировщика(СсылкаДиалога, PlannedDSL, PlanReasoning = "", PlanStepId = "") Экспорт
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) Тогда
		Возврат;
	КонецЕсли;
	СтруктураДанных = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
	Если СтруктураДанных = Неопределено ИЛИ ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
		СтруктураДанных = Новый Структура;
	КонецЕсли;
	СтруктураДанных.Вставить("Planner_PlannedDSL", PlannedDSL);
	СтруктураДанных.Вставить("Planner_Reasoning", PlanReasoning);
	СтруктураДанных.Вставить("Planner_StepId", PlanStepId);
	ЗаписатьДанныеДиалогаВРегистр(СсылкаДиалога, СтруктураДанных);
КонецПроцедуры

Функция ПолучитьАртефактПланировщика(СсылкаДиалога) Экспорт
	Результат = Новый Структура("PlannedDSL,PlanReasoning,PlanStepId", "", "", "");
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) Тогда
		Возврат Результат;
	КонецЕсли;
	СтруктураДанных = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
	Если СтруктураДанных = Неопределено ИЛИ ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
		Возврат Результат;
	КонецЕсли;
	Если СтруктураДанных.Свойство("Planner_PlannedDSL") Тогда
		Результат.PlannedDSL = Строка(СтруктураДанных.Planner_PlannedDSL);
	КонецЕсли;
	Если СтруктураДанных.Свойство("Planner_Reasoning") Тогда
		Результат.PlanReasoning = Строка(СтруктураДанных.Planner_Reasoning);
	КонецЕсли;
	Если СтруктураДанных.Свойство("Planner_StepId") Тогда
		Результат.PlanStepId = Строка(СтруктураДанных.Planner_StepId);
	КонецЕсли;
	Возврат Результат;
КонецФункции

Процедура СохранитьРезультатExecutor(СсылкаДиалога, РезультатExecutor) Экспорт
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) Тогда
		Возврат;
	КонецЕсли;
	СтруктураДанных = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
	Если СтруктураДанных = Неопределено ИЛИ ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
		СтруктураДанных = Новый Структура;
	КонецЕсли;
	СтруктураДанных.Вставить("Executor_ПоследнийРезультат", РезультатExecutor);
	ЗаписатьДанныеДиалогаВРегистр(СсылкаДиалога, СтруктураДанных);
КонецПроцедуры

Функция ПолучитьРезультатExecutor(СсылкаДиалога) Экспорт
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураДанных = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
	Если СтруктураДанных = Неопределено ИЛИ ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если СтруктураДанных.Свойство("Executor_ПоследнийРезультат") Тогда
		Возврат СтруктураДанных.Executor_ПоследнийРезультат;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

Процедура УстановитьРежимDSLВДиалоге(СсылкаДиалога, Режим = "commit") Экспорт
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураДанных = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
	Если СтруктураДанных = Неопределено ИЛИ ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
		СтруктураДанных = Новый Структура;
	КонецЕсли;
	СтруктураДанных.Вставить("DSL_РежимВыполнения", Режим);
	ЗаписатьДанныеДиалогаВРегистр(СсылкаДиалога, СтруктураДанных);
КонецПроцедуры

// Возвращает Истина, если оркестратор включен для диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
Функция ОркестраторВключенДляДиалога(СсылкаДиалога) Экспорт
	
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) ИЛИ СсылкаДиалога.Пустая() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	Данные.ОркестраторВключен КАК ОркестраторВключен
		|ИЗ
		|	РегистрСведений.ИИА_ДанныеДиалогов КАК Данные
		|ГДЕ
		|	Данные.Диалог = &Диалог";
	Запрос.УстановитьПараметр("Диалог", СсылкаДиалога);
	
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Выборка = Результат.Выбрать();
	Выборка.Следующий();
	Возврат Выборка.ОркестраторВключен = Истина;
	
КонецФункции

// Устанавливает флаг оркестратор включен для диалога
// Сохраняет текущее ХранилищеЗначения, чтобы не затирать остальные данные диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  Значение - Булево - значение флага
//
Процедура УстановитьОркестраторВключен(СсылкаДиалога, Значение) Экспорт
	
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) ИЛИ СсылкаДиалога.Пустая() Тогда
		ВызватьИсключение "Ссылка на диалог пуста при установке флага оркестратора: " + Строка(СсылкаДиалога);
	КонецЕсли;
	
	// Не включаем оркестратор для удалённого или несуществующего диалога
	Если Значение = Истина Тогда
		ДиалогОбъект = СсылкаДиалога.ПолучитьОбъект();
		Если ДиалогОбъект = Неопределено Тогда
			ВызватьИсключение "Диалог не найден в базе (удалён или ссылка неверна): " + Строка(СсылкаДиалога);
		КонецЕсли;
	КонецЕсли;
	
	МенеджерЗаписи = РегистрыСведений.ИИА_ДанныеДиалогов.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.Диалог = СсылкаДиалога;
	МенеджерЗаписи.Прочитать();
	Если НЕ МенеджерЗаписи.Выбран() Тогда
		МенеджерЗаписи.Диалог = СсылкаДиалога;
		МенеджерЗаписи.ОркестраторВключен = Значение;
		МенеджерЗаписи.ХранилищеЗначения = Новый ХранилищеЗначения(Новый Структура);
	Иначе
		МенеджерЗаписи.ОркестраторВключен = Значение;
		// Сохраняем ХранилищеЗначения - если его не было, создаём пустую структуру
		Если НЕ ЗначениеЗаполнено(МенеджерЗаписи.ХранилищеЗначения) Тогда
			МенеджерЗаписи.ХранилищеЗначения = Новый ХранилищеЗначения(Новый Структура);
		КонецЕсли;
	КонецЕсли;
	МенеджерЗаписи.Записать();
	
КонецПроцедуры

// Сохраняет результат проверки задачи в хранилище диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  Успех - Булево - результат проверки
//  Причина - Строка - пояснение
//
Процедура УстановитьРезультатПроверкиВХранилище(СсылкаДиалога, Успех, Причина = "") Экспорт
	
	СтруктураПроверки = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
	Если СтруктураПроверки = Неопределено ИЛИ ТипЗнч(СтруктураПроверки) <> Тип("Структура") Тогда
		СтруктураПроверки = Новый Структура;
	КонецЕсли;
	
	СтруктураПроверки.Вставить("ПроверкаВыполнена", Истина);
	СтруктураПроверки.Вставить("СтатусПроверкиЗадачи", ?(Успех, "Успешно", "Неудачно"));
	СтруктураПроверки.Вставить("ПричинаПроверки", ?(ПустаяСтрока(Причина), "", Причина));
	
	ЗаписатьДанныеДиалогаВРегистр(СсылкаДиалога, СтруктураПроверки);
	
КонецПроцедуры

// Возвращает структуру с результатам проверки из хранилища диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Структура с полями ПроверкаВыполнена, СтатусПроверкиЗадачи, ПричинаПроверки
//
Функция ПолучитьРезультатПроверкиИзХранилища(СсылкаДиалога) Экспорт
	
	Результат = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
	Если Результат = Неопределено ИЛИ ТипЗнч(Результат) <> Тип("Структура") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если НЕ Результат.Свойство("ПроверкаВыполнена") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Добавляет ссылки на объекты в табличную часть ИзмененныеОбъекты диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  МассивСсылок - Массив - массив ссылок на объекты
//
Процедура ДобавитьИзмененныеОбъекты(СсылкаДиалога, МассивСсылок) Экспорт
	
	Если МассивСсылок = Неопределено ИЛИ МассивСсылок.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	// Добавляем каждую ссылку, если её еще нет в табличной части
	Для Каждого СсылкаОбъекта Из МассивСсылок Цикл
		
		Если НЕ ЗначениеЗаполнено(СсылкаОбъекта) Тогда
			Продолжить;
		КонецЕсли;
		
		// Проверяем, есть ли уже такая ссылка в табличной части
		Найдено = Ложь;
		Для Каждого СтрокаИзмененныхОбъектов Из Диалог.ИзмененныеОбъекты Цикл
			Если ЗначениеЗаполнено(СтрокаИзмененныхОбъектов.СсылкаНаОбъект) Тогда
				Попытка
					Если СтрокаИзмененныхОбъектов.СсылкаНаОбъект = СсылкаОбъекта Тогда
						Найдено = Истина;
						Прервать;
					КонецЕсли;
				Исключение
					// Игнорируем ошибки сравнения
					ТекстОшибки = ОписаниеОшибки();
				КонецПопытки;
			КонецЕсли;
		КонецЦикла;
		
		// Если ссылки еще нет, добавляем её
		Если НЕ Найдено Тогда
			НоваяСтрока = Диалог.ИзмененныеОбъекты.Добавить();
			НоваяСтрока.СсылкаНаОбъект = СсылкаОбъекта;
		КонецЕсли;
		
	КонецЦикла;
	
	Диалог.Записать();
	УведомитьОбОбновленииДиалога(СсылкаДиалога, "НовоеСообщение");
	
КонецПроцедуры

// Преобразует массив сообщений в таблицу значений для передачи в ИИ
//
// Параметры:
//  МассивСообщений - Массив - массив структур с сообщениями
//
// Возвращаемое значение:
//  ТаблицаЗначений - таблица значений с историей сообщений
//
Функция ПреобразоватьМассивСообщенийВТаблицу(МассивСообщений) Экспорт
	
	История = Новый ТаблицаЗначений;
	История.Колонки.Добавить("Время", Новый ОписаниеТипов("Дата"));
	История.Колонки.Добавить("Автор", Новый ОписаниеТипов("ПеречислениеСсылка.ИИА_АвторСообщения"));
	История.Колонки.Добавить("ТипСообщения", Новый ОписаниеТипов("ПеречислениеСсылка.ИИА_ТипСообщения"));
	История.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка"));
	История.Колонки.Добавить("ТекстКода", Новый ОписаниеТипов("Строка"));
	
	Для Каждого СтруктураСообщения Из МассивСообщений Цикл
		
		НоваяСтрока = История.Добавить();
		НоваяСтрока.Время = СтруктураСообщения.Время;
		НоваяСтрока.Автор = СтруктураСообщения.Автор;
		НоваяСтрока.ТипСообщения = СтруктураСообщения.ТипСообщения;
		НоваяСтрока.Текст = СтруктураСообщения.Текст;
		НоваяСтрока.ТекстКода = СтруктураСообщения.ТекстКода;
		
	КонецЦикла;
	
	Возврат История;
	
КонецФункции

// Добавляет сообщение в диалог
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  Автор - ПеречислениеСсылка.ИИА_АвторСообщения - автор сообщения
//  ТипСообщения - ПеречислениеСсылка.ИИА_ТипСообщения - тип сообщения
//  Текст - Строка - текст сообщения
//  ТекстКода - Строка - текст кода (для запросов)
//  Статус - Строка - статус сообщения
//  UsageTokens - Число - количество использованных токенов
//  СтатусDSL - ПеречислениеСсылка.ИИА_СтатусDSL - статус DSL
//
Процедура ДобавитьСообщениеВДиалог(СсылкаДиалога, Автор, ТипСообщения, Текст, ТекстКода = "", Статус = "", UsageTokens = 0, СтатусDSL = Неопределено, УИДСообщения = "", СкрытоеСлужебное = Неопределено) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	НоваяСтрока = Диалог.Сообщения.Добавить();
	НоваяСтрока.Время = ТекущаяДатаСеанса();
	НоваяСтрока.Автор = Автор;
	НоваяСтрока.ТипСообщения = ТипСообщения;
	НоваяСтрока.Текст = Текст;
	НоваяСтрока.ТекстКода = ТекстКода;
	НоваяСтрока.Статус = Статус;
	НоваяСтрока.UsageTokens = UsageTokens;
	
	Если ПустаяСтрока(УИДСообщения) Тогда
		УИДСообщения = Строка(Новый УникальныйИдентификатор());
	КонецЕсли;
	НоваяСтрока.УИД = Лев(Строка(УИДСообщения), 36);
	
	Если СкрытоеСлужебное = Неопределено Тогда
		НоваяСтрока.СкрытоеСлужебное = ЭтоСкрытоеСлужебноеСообщение(Автор, ТипСообщения, Текст, ТекстКода);
	Иначе
		НоваяСтрока.СкрытоеСлужебное = СкрытоеСлужебное;
	КонецЕсли;
	
	// Устанавливаем статус DSL
	Если СтатусDSL = Неопределено Тогда
		// Если есть ТекстКода и это DSL, устанавливаем "ВОчереди", иначе оставляем пустым
		Если НЕ ПустаяСтрока(ТекстКода) И ТипСообщения = Перечисления.ИИА_ТипСообщения.Код Тогда
			НоваяСтрока.СтатусDSL = Перечисления.ИИА_СтатусDSL.ВОчереди;
		Иначе
			// Для не-DSL сообщений статус не устанавливаем (остается пустым)
			НоваяСтрока.СтатусDSL = Неопределено;
		КонецЕсли;
	Иначе
		НоваяСтрока.СтатусDSL = СтатусDSL;
	КонецЕсли;
	
	Диалог.Записать();
	СообщениеДляPayload = Новый Структура;
	СообщениеДляPayload.Вставить("Время", НоваяСтрока.Время);
	СообщениеДляPayload.Вставить("Автор", НоваяСтрока.Автор);
	СообщениеДляPayload.Вставить("ТипСообщения", НоваяСтрока.ТипСообщения);
	СообщениеДляPayload.Вставить("Текст", НоваяСтрока.Текст);
	СообщениеДляPayload.Вставить("ТекстКода", НоваяСтрока.ТекстКода);
	СообщениеДляPayload.Вставить("Статус", НоваяСтрока.Статус);
	СообщениеДляPayload.Вставить("UsageTokens", НоваяСтрока.UsageTokens);
	СообщениеДляPayload.Вставить("СтатусDSL", НоваяСтрока.СтатусDSL);
	СообщениеДляPayload.Вставить("УИД", НоваяСтрока.УИД);
	СообщениеДляPayload.Вставить("СкрытоеСлужебное", НоваяСтрока.СкрытоеСлужебное);
	ДопДанныеУведомления = Новый Структура("ПоследнийУИД", НоваяСтрока.УИД, "Сообщение", СообщениеДляPayload);
	УведомитьОбОбновленииДиалога(СсылкаДиалога, "НовоеСообщение", ДопДанныеУведомления);
	
	// ДУБЛИРУЕМ В ЛОГ (компактно для DSL и dsl_system_result). Дата - в отдельном поле регистра.
	ЗаписьЛога = "[" + Строка(Автор) + "]";
	Если НЕ ПустаяСтрока(Текст) Тогда
		ТекстДляЛога = ФорматироватьКомпактноДляЛога(Текст);
		ЗаписьЛога = ЗаписьЛога + Символы.ПС + ТекстДляЛога;
	КонецЕсли;
	Если НЕ ПустаяСтрока(ТекстКода) Тогда
		ТекстКодаДляЛога = ФорматироватьКомпактноДляЛога(ТекстКода);
		ЗаписьЛога = ЗаписьЛога + Символы.ПС + "Код: " + ТекстКодаДляЛога;
	КонецЕсли;
	ЗаписьЛога = ЗаписьЛога + Символы.ПС + "---";
	
	// Роль для регистра ИИА_Логи: для сообщений ИИ указываем LLM
	РольДляЛога = "";
	Если Автор = Перечисления.ИИА_АвторСообщения.ИИ Тогда
		РольДляЛога = "LLM";
	ИначеЕсли Автор = Перечисления.ИИА_АвторСообщения.Пользователь Тогда
		РольДляЛога = "Пользователь";
	ИначеЕсли Автор = Перечисления.ИИА_АвторСообщения.Система Тогда
		РольДляЛога = "Система";
	КонецЕсли;
	ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, ЗаписьЛога, РольДляЛога, "", НоваяСтрока.УИД);
	
КонецПроцедуры

Функция ЭтоСкрытоеСлужебноеСообщение(Автор, ТипСообщения, Текст, ТекстКода)
	
	Если ТипСообщения = Перечисления.ИИА_ТипСообщения.Код Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(Текст) И СтрНачинаетсяС(СокрЛП(Текст), "=== РЕЗЮМЕ") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Автор <> Перечисления.ИИА_АвторСообщения.Система Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ПустаяСтрока(Текст) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если СтрНайти(Текст, """kind"":""dsl_system_result""") > 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если СтрНайти(Текст, """kind"": ""dsl_system_result""") > 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если (СтрНайти(Текст, """updated_plan"":") > 0 И СтрНайти(Текст, """next_step_dsl"":") > 0) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Отправляет уведомление об обновлении диалога. Вызывать после каждой записи диалога.
// При вызове из фонового задания передаёт уведомление родительскому сеансу для надёжной доставки.
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  ТипСобытия - Строка - тип события ("НовоеСообщение" и т.п.)
//  ДополнительныеДанные - Структура - доп. поля для уведомления (напр. Успех для "ЗадачаЗавершена")
//
Процедура УведомитьОбОбновленииДиалога(СсылкаДиалога, ТипСобытия = "НовоеСообщение", ДополнительныеДанные = Неопределено) Экспорт
	
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) ИЛИ СсылкаДиалога.Пустая() Тогда
		Возврат;
	КонецЕсли;
	
	ДанныеУведомления = Новый Структура;
	ДанныеУведомления.Вставить("Диалог", СсылкаДиалога);
	ДанныеУведомления.Вставить("ТипСобытия", ТипСобытия);
	ДанныеУведомления.Вставить("ВерсияДиалога", ПолучитьВерсиюДиалогаДляУведомления(СсылкаДиалога));
	
	ПоследнийУИД = ПолучитьПоследнийУИДСообщенияДиалога(СсылкаДиалога);
	Если НЕ ПустаяСтрока(ПоследнийУИД) Тогда
		ДанныеУведомления.Вставить("ПоследнийУИД", ПоследнийУИД);
	КонецЕсли;
	
	Если ТипЗнч(ДополнительныеДанные) = Тип("Структура") Тогда
		Для Каждого КлючЗначение Из ДополнительныеДанные Цикл
			ДанныеУведомления.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	
	// Из фонового задания уведомление может не дойти — передаём адресата (родительский сеанс)
	Адресаты = Неопределено;
	Попытка
		ТекущееЗадание = ФоновыеЗадания.Текущее();
		Если ТекущееЗадание <> Неопределено И ЗначениеЗаполнено(ТекущееЗадание.НомерРодительскогоСеанса) Тогда
			Адресаты = Новый Массив;
			Адресаты.Добавить(ТекущееЗадание.НомерРодительскогоСеанса);
		КонецЕсли;
	Исключение
		// Не фоновое задание или свойство недоступно — отправляем без адресатов (всем подписчикам)
	КонецПопытки;
	
	Если Адресаты = Неопределено ИЛИ Адресаты.Количество() = 0 Тогда
		УведомленияКлиента.ОтправитьУведомление("СообщениеПереписки", ДанныеУведомления);
	Иначе
		УведомленияКлиента.ОтправитьУведомление("СообщениеПереписки", ДанныеУведомления, Адресаты);
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьВерсиюДиалогаДляУведомления(СсылкаДиалога)
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) ИЛИ СсылкаДиалога.Пустая() Тогда
		Возврат "";
	КонецЕсли;
	
	Попытка
		Диалог = СсылкаДиалога.ПолучитьОбъект();
		Возврат Строка(СсылкаДиалога.УникальныйИдентификатор()) + ":" + Формат(Диалог.Сообщения.Количество(), "ЧН=0");
	Исключение
		ВызватьИсключение "Ошибка формирования версии диалога для уведомления: " + ОписаниеОшибки();
	КонецПопытки;
КонецФункции

Функция ПолучитьПоследнийУИДСообщенияДиалога(СсылкаДиалога) Экспорт
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) ИЛИ СсылкаДиалога.Пустая() Тогда
		Возврат "";
	КонецЕсли;
	
	Попытка
		Диалог = СсылкаДиалога.ПолучитьОбъект();
		Если Диалог.Сообщения.Количество() = 0 Тогда
			Возврат "";
		КонецЕсли;
		
		ПоследняяСтрока = Диалог.Сообщения[Диалог.Сообщения.Количество() - 1];
		Если ПоследняяСтрока = Неопределено Тогда
			Возврат "";
		КонецЕсли;
		
		Возврат СокрЛП(Строка(ПоследняяСтрока.УИД));
	Исключение
		ВызватьИсключение "Ошибка получения ПоследнийУИД для уведомления: " + ОписаниеОшибки();
	КонецПопытки;
КонецФункции

// Возвращает структуру сообщения по УИД из табличной части Сообщения или Неопределено.
// Используется для передачи полного сообщения в payload уведомления.
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  УИД - Строка - УИД сообщения из табличной части
//
// Возвращаемое значение:
//  Структура, Неопределено - структура с полями Время, Автор, ТипСообщения, Текст, ТекстКода, Статус, UsageTokens, СтатусDSL, УИД, СкрытоеСлужебное
//
Функция ПолучитьСообщениеПоУИД(СсылкаДиалога, УИД) Экспорт
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) ИЛИ СсылкаДиалога.Пустая() ИЛИ ПустаяСтрока(УИД) Тогда
		Возврат Неопределено;
	КонецЕсли;
	УИДНорм = Лев(СокрЛП(Строка(УИД)), 36);
	Попытка
		Диалог = СсылкаДиалога.ПолучитьОбъект();
		Для Индекс = 0 По Диалог.Сообщения.Количество() - 1 Цикл
			Строка = Диалог.Сообщения[Индекс];
			Если Лев(СокрЛП(Строка(Строка.УИД)), 36) = УИДНорм Тогда
				СтруктураСообщения = Новый Структура;
				СтруктураСообщения.Вставить("Время", Строка.Время);
				СтруктураСообщения.Вставить("Автор", Строка.Автор);
				СтруктураСообщения.Вставить("ТипСообщения", Строка.ТипСообщения);
				СтруктураСообщения.Вставить("Текст", Строка.Текст);
				СтруктураСообщения.Вставить("ТекстКода", Строка.ТекстКода);
				СтруктураСообщения.Вставить("Статус", Строка.Статус);
				СтруктураСообщения.Вставить("UsageTokens", Строка.UsageTokens);
				СтруктураСообщения.Вставить("СтатусDSL", Строка.СтатусDSL);
				СтруктураСообщения.Вставить("УИД", Строка.УИД);
				СтруктураСообщения.Вставить("СкрытоеСлужебное", Строка.СкрытоеСлужебное);
				Возврат СтруктураСообщения;
			КонецЕсли;
		КонецЦикла;
		Возврат Неопределено;
	Исключение
		Возврат Неопределено;
	КонецПопытки;
КонецФункции

// Функции для вызова ИИ перенесены в модуль ИИА_Провайдеры
// Функции для работы с Гигачат перенесены в модуль ИИА_Гигачат

// Функции СформироватьПромптДляИИ и РаспознатьОтветИИ перенесены в модуль ИИА_Провайдеры

Функция ПолучитьСправкуЗапросовПоОшибке(ТекстОшибки) Экспорт
	
	ТекстВРег = ВРег(Строка(ТекстОшибки));
	Справка = "";
	
	// Минимальный «якорь», чтобы у модели всегда был контекст базового синтаксиса
	Справка = Справка + ИИА_СправкаЗапросы1С.ПолучитьСправкуОсновныеКонструкции() + Символы.ПС + Символы.ПС;
	
	Если СтрНайти(ТекстВРег, "СОЕДИНЕНИ") > 0 ИЛИ СтрНайти(ТекстВРег, "JOIN") > 0 Тогда
		Справка = Справка + ИИА_СправкаЗапросы1С.ПолучитьСправкуОператорыСоединения() + Символы.ПС + Символы.ПС;
	КонецЕсли;
	
	Если СтрНайти(ТекстВРег, "ПОДОБНО") > 0 
		ИЛИ СтрНайти(ТекстВРег, "LIKE") > 0
		ИЛИ СтрНайти(ТекстВРег, "СТРНАЙТИ") > 0
		ИЛИ СтрНайти(ТекстВРег, "НАЙТИ(") > 0 Тогда
		Справка = Справка + ИИА_СправкаЗапросы1С.ПолучитьСправкуФункцииСтрок() + Символы.ПС + Символы.ПС;
		Справка = Справка + ИИА_СправкаЗапросы1С.ПолучитьСправкуОператорыСравнения() + Символы.ПС + Символы.ПС;
	КонецЕсли;
	
	Если СтрНайти(ТекстВРег, "ПАРАМЕТР") > 0 ИЛИ СтрНайти(ТекстВРег, "&") > 0 Тогда
		Справка = Справка + ИИА_СправкаЗапросы1С.ПолучитьСправкуПараметры() + Символы.ПС + Символы.ПС;
	КонецЕсли;
	
	Если СтрНайти(ТекстВРег, "ДОБАВИТЬКДАТЕ") > 0 Тогда
		Справка = Справка + ИИА_СправкаЗапросы1С.ПолучитьСправкуПоФункции("ДОБАВИТЬКДАТЕ") + Символы.ПС + Символы.ПС;
	КонецЕсли;
	
	Если СтрНайти(ТекстВРег, "ДАТА") > 0 ИЛИ СтрНайти(ТекстВРег, "ПЕРИОД") > 0 Тогда
		Справка = Справка + ИИА_СправкаЗапросы1С.ПолучитьСправкуФункцииДаты() + Символы.ПС + Символы.ПС;
	КонецЕсли;
	
	Если СтрНайти(ТекстВРег, "КОЛИЧЕСТВО") > 0 ИЛИ СтрНайти(ТекстВРег, "СУММА") > 0 Тогда
		Справка = Справка + ИИА_СправкаЗапросы1С.ПолучитьСправкуАгрегатныеФункции() + Символы.ПС + Символы.ПС;
	КонецЕсли;
	
	Справка = Справка + ИИА_СправкаЗапросы1С.ПолучитьСправкуВажныеПравила();
	
	Возврат Справка;
	
КонецФункции

// Исправляет DSL-сценарий через ИИ при ошибке выполнения (использует обычную функцию ВызватьИИ)
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  ТекстОшибки - Строка - текст ошибки
//  ИсходныйDSL - Строка - исходный DSL-сценарий
//
// Возвращаемое значение:
//  Структура - структура ответа от ВызватьИИ (содержит DSL в поле DSL или Текст)
//
Функция ИсправитьDSLЧерезИИ(СсылкаДиалога, ТекстОшибки, ИсходныйDSL) Экспорт
	
	// Дополняем текст ошибки справкой, если это ошибка запроса
	ТекстОшибкиСКонтекстом = ТекстОшибки;
	ТекстВРег = ВРег(ТекстОшибки);
	
	// Если ошибка связана с запросом или синтаксисом
	Если СтрНайти(ТекстОшибки, "RunQuery") > 0 
		ИЛИ СтрНайти(ТекстОшибки, "Запрос") > 0 
		ИЛИ СтрНайти(ТекстОшибки, "Синтаксическая ошибка") > 0 Тогда
		
		// Если ошибка "Поле не найдено" - подсказываем получить метаданные
		Если СтрНайти(ТекстОшибки, "Поле не найдено") > 0 Тогда
			ТекстОшибкиСКонтекстом = ТекстОшибкиСКонтекстом + Символы.ПС +
			"СОВЕТ: Возможно, ты используешь неверные имена полей. Сначала выполни GetObjectFields, чтобы узнать точную структуру.";
		ИначеЕсли СтрНайти(ТекстОшибки, "не найден") > 0 Тогда
			// Универсальная обработка ошибок поиска объектов (GetObjectFields, CheckObjectExists и др.)
			// Ищем паттерны: "Документ 'Имя' не найден" или "Справочник 'Имя' не найден"
			ТипОбъекта = "";
			ИмяОбъекта = "";
			
			Если СтрНайти(ТекстОшибки, "Документ '") > 0 Тогда
				ТипОбъекта = "Документ";
			ИначеЕсли СтрНайти(ТекстОшибки, "Справочник '") > 0 Тогда
				ТипОбъекта = "Справочник";
			КонецЕсли;
			
			Если НЕ ПустаяСтрока(ТипОбъекта) Тогда
				ПозНачала = СтрНайти(ТекстОшибки, ТипОбъекта + " '") + СтрДлина(ТипОбъекта) + 2;
				ПозКонца = СтрНайти(ТекстОшибки, "'", НаправлениеПоиска.СНачала, ПозНачала);
				Если ПозКонца > 0 Тогда
					ИмяОбъекта = Сред(ТекстОшибки, ПозНачала, ПозКонца - ПозНачала);
					
					// --- СБОР ИСТОРИИ ПОПЫТОК ---
					МассивПопыток = Новый Массив;
					МассивИстории = ПолучитьСообщенияДиалога(СсылкаДиалога, 20);
					Для Каждого Сообщение Из МассивИстории Цикл
						Если Сообщение.Автор = Перечисления.ИИА_АвторСообщения.Система 
							И (СтрНайти(Сообщение.Текст, "table_not_found") > 0 ИЛИ СтрНайти(Сообщение.Текст, "не найден") > 0) Тогда
							ПозТ = СтрНайти(Сообщение.Текст, "Таблица '");
							Если ПозТ = 0 Тогда ПозТ = СтрНайти(Сообщение.Текст, "Объект '"); КонецЕсли;
							Если ПозТ > 0 Тогда
								ИмяТ = Сред(Сообщение.Текст, ПозТ + 9);
								ПозК = СтрНайти(ИмяТ, "'");
								Если ПозК > 0 Тогда
									ИмяТ = Лев(ИмяТ, ПозК - 1);
									Если МассивПопыток.Найти(ИмяТ) = Неопределено Тогда
										МассивПопыток.Добавить(ИмяТ);
									КонецЕсли;
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
					КонецЦикла;
					
					// Ищем похожие объекты
					Похожие = ИИА_Метаданные.НайтиПохожиеОбъекты(ИмяОбъекта, ТипОбъекта);
					
					// Исключаем уже опробованные
					ЧистыеПохожие = Новый Массив;
					Для Каждого Кандидат Из Похожие Цикл
						БылВПопытках = Ложь;
						Для Каждого ПрошлаяПопытка Из МассивПопыток Цикл
							Если ВРег(ПрошлаяПопытка) = ВРег(Кандидат) ИЛИ СтрНайти(ВРег(ПрошлаяПопытка), ВРег(Кандидат)) > 0 Тогда
								БылВПопытках = Истина;
								Прервать;
							КонецЕсли;
						КонецЦикла;
						Если НЕ БылВПопытках Тогда
							ЧистыеПохожие.Добавить(Кандидат);
						КонецЕсли;
					КонецЦикла;
					
					ТекстОшибкиСКонтекстом = ТекстОшибкиСКонтекстом + Символы.ПС +
					"!!! КРИТИЧЕСКАЯ ПОДСКАЗКА ДЛЯ ИСПРАВЛЕНИЯ !!!" + Символы.ПС +
					"Объект '" + ИмяОбъекта + "' не найден. ";
					
					Если МассивПопыток.Количество() > 0 Тогда
						ТекстОшибкиСКонтекстом = ТекстОшибкиСКонтекстом + Символы.ПС + 
						"ТЫ УЖЕ ПРОБОВАЛ И ОНИ НЕ ПОДОШЛИ: " + СтрСоединить(МассивПопыток, ", ") + ". ";
					КонецЕсли;
					
					Если ЧистыеПохожие.Количество() > 0 Тогда
						ТекстОшибкиСКонтекстом = ТекстОшибкиСКонтекстом + "ВМЕСТО НЕГО ИСПОЛЬЗУЙ ОДИН ИЗ ЭТИХ ОБЪЕКТОВ: " + СтрСоединить(ЧистыеПохожие, ", ") + ". ";
						ТекстОшибкиСКонтекстом = ТекстОшибкиСКонтекстом + "Твой следующий шаг ОБЯЗАН быть GetObjectFields для одного из этих имен!";
					Иначе
						ТекстОшибкиСКонтекстом = ТекстОшибкиСКонтекстом + "Используй GetMetadata с фильтром для поиска точного имени.";
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли СтрНайти(ТекстОшибки, "table_not_found") > 0 Тогда
			// Извлекаем имя таблицы из ошибки (оно там в формате 'ДОКУМЕНТ.ИМЯ')
			ПозТаблицы = СтрНайти(ТекстОшибки, "Таблица '");
			Если ПозТаблицы > 0 Тогда
				ИмяТаблицы = Сред(ТекстОшибки, ПозТаблицы + 9);
				ПозКонца = СтрНайти(ИмяТаблицы, "'");
				Если ПозКонца > 0 Тогда
					ИмяТаблицы = Лев(ИмяТаблицы, ПозКонца - 1);
					
					// Извлекаем собственно имя объекта (после точки)
					ПозТочки = СтрНайти(ИмяТаблицы, ".");
					Если ПозТочки > 0 Тогда
						ТипОбъекта = Лев(ИмяТаблицы, ПозТочки - 1);
						ИмяОбъекта = Сред(ИмяТаблицы, ПозТочки + 1);
						
						// --- СБОР ИСТОРИИ ПОПЫТОК ---
						МассивПопыток = Новый Массив;
						МассивИстории = ПолучитьСообщенияДиалога(СсылкаДиалога, 20);
						Для Каждого Сообщение Из МассивИстории Цикл
							Если Сообщение.Автор = Перечисления.ИИА_АвторСообщения.Система 
								И (СтрНайти(Сообщение.Текст, "table_not_found") > 0 ИЛИ СтрНайти(Сообщение.Текст, "не найден") > 0) Тогда
								// Извлекаем имя из старой ошибки
								ПозТ = СтрНайти(Сообщение.Текст, "Таблица '");
								Если ПозТ = 0 Тогда ПозТ = СтрНайти(Сообщение.Текст, "Объект '"); КонецЕсли;
								Если ПозТ > 0 Тогда
									ИмяТ = Сред(Сообщение.Текст, ПозТ + 9);
									ПозК = СтрНайти(ИмяТ, "'");
									Если ПозК > 0 Тогда
										ИмяТ = Лев(ИмяТ, ПозК - 1);
										Если МассивПопыток.Найти(ИмяТ) = Неопределено Тогда
											МассивПопыток.Добавить(ИмяТ);
										КонецЕсли;
									КонецЕсли;
								КонецЕсли;
							КонецЕсли;
						КонецЦикла;
						
						// Формируем фильтр
						Фильтр = ИмяОбъекта;
						Если СтрДлина(Фильтр) > 5 Тогда
							Фильтр = Лев(Фильтр, 6);
						КонецЕсли;
						
						// Ищем похожие объекты в метаданных
						ТипДляПоиска = ?(ВРег(ТипОбъекта) = "ДОКУМЕНТ", "Документ", "Справочник");
						Похожие = ИИА_Метаданные.НайтиПохожиеОбъекты(ИмяОбъекта, ТипДляПоиска);
						
						// Исключаем уже опробованные
						ЧистыеПохожие = Новый Массив;
						Для Каждого Кандидат Из Похожие Цикл
							ПолноеИмяКандидата = ВРег(ТипОбъекта + "." + Кандидат);
							БылВПопытках = Ложь;
							Для Каждого ПрошлаяПопытка Из МассивПопыток Цикл
								Если ВРег(ПрошлаяПопытка) = ПолноеИмяКандидата ИЛИ ВРег(ПрошлаяПопытка) = ВРег(Кандидат) Тогда
									БылВПопытках = Истина;
									Прервать;
								КонецЕсли;
							КонецЦикла;
							Если НЕ БылВПопытках Тогда
								ЧистыеПохожие.Добавить(Кандидат);
							КонецЕсли;
						КонецЦикла;
						
						ТекстОшибкиСКонтекстом = ТекстОшибкиСКонтекстом + Символы.ПС +
						"!!! КРИТИЧЕСКАЯ ПОДСКАЗКА ДЛЯ ИСПРАВЛЕНИЯ !!!" + Символы.ПС +
						"Таблица '" + ИмяТаблицы + "' не найдена. ";
						
						Если МассивПопыток.Количество() > 0 Тогда
							ТекстОшибкиСКонтекстом = ТекстОшибкиСКонтекстом + Символы.ПС + 
							"ТЫ УЖЕ ПРОБОВАЛ И ОНИ НЕ ПОДОШЛИ: " + СтрСоединить(МассивПопыток, ", ") + ". ";
						КонецЕсли;
						
						Если ЧистыеПохожие.Количество() > 0 Тогда
							ТекстОшибкиСКонтекстом = ТекстОшибкиСКонтекстом + Символы.ПС + 
							"ВМЕСТО НИХ ИСПОЛЬЗУЙ СЛЕДУЮЩИЙ ОБЪЕКТ ИЗ СПИСКА: " + СтрСоединить(ЧистыеПохожие, ", ") + ". ";
							ТекстОшибкиСКонтекстом = ТекстОшибкиСКонтекстом + "Твой следующий шаг ОБЯЗАН быть RunQuery к одному из этих НОВЫХ имен!";
						Иначе
							ТекстОшибкиСКонтекстом = ТекстОшибкиСКонтекстом + "Выполни GetMetadata с фильтром '" + Фильтр + "' для поиска других вариантов.";
						КонецЕсли;
						
						// СОХРАНЯЕМ РЕКОМЕНДАЦИЮ В КОНТЕКСТ (для автоматической фильтрации GetMetadata)
						СсылкаДиалогаОбъект = СсылкаДиалога.ПолучитьОбъект();
						СсылкаДиалогаОбъект.ДополнительныеСвойства.Вставить("РекомендованныйФильтрМетаданных", Фильтр);
						СсылкаДиалогаОбъект.ДополнительныеСвойства.Вставить("РекомендованныеОбъекты", ЧистыеПохожие);
						
						// ОТСЛЕЖИВАНИЕ НЕЙДЕННЫХ ОБЪЕКТОВ (Memory Cleanup)
						НенайденныеОбъекты = "";
						СсылкаДиалогаОбъект.ДополнительныеСвойства.Свойство("НенайденныеОбъекты", НенайденныеОбъекты);
						Если СтрНайти(НенайденныеОбъекты, ИмяОбъекта) = 0 Тогда
							НенайденныеОбъекты = НенайденныеОбъекты + ?(ПустаяСтрока(НенайденныеОбъекты), "", ",") + ИмяОбъекта;
							СсылкаДиалогаОбъект.ДополнительныеСвойства.Вставить("НенайденныеОбъекты", НенайденныеОбъекты);
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли СтрНайти(ТекстОшибки, "Синтаксическая ошибка") > 0 Тогда
			ТекстОшибкиСКонтекстом = ТекстОшибкиСКонтекстом + Символы.ПС +
			"СОВЕТ: В запросе синтаксическая ошибка. Попробуй упростить запрос. " +
			"Если ты пытаешься найти последнюю запись, используй 'ВЫБРАТЬ ПЕРВЫЕ 1 ... УПОРЯДОЧИТЬ ПО Дата УБЫВ' вместо подзапросов с МАКСИМУМ.";
		КонецЕсли;
		
	КонецЕсли;
	
	Если СтрНайти(ТекстВРег, " RunQuery") > 0 
		ИЛИ СтрНайти(ТекстВРег, " ЗАПРОС") > 0 
		ИЛИ СтрНайти(ТекстВРег, "СИНТАКСИЧЕСКАЯ ОШИБКА") > 0 Тогда
		
		ТекстОшибкиСКонтекстом = ТекстОшибкиСКонтекстом + Символы.ПС + Символы.ПС +
		"ДЛЯ ИСПРАВЛЕНИЯ ОШИБКИ ИСПОЛЬЗУЙ ОФИЦИАЛЬНУЮ СПРАВКУ ПО ЯЗЫКУ ЗАПРОСОВ 1С:" + Символы.ПС +
		ПолучитьСправкуЗапросовПоОшибке(ТекстОшибки);
	КонецЕсли;
	
	// Формирует промпт для исправления
	ПромптИсправления = ИИА_Промты.ПолучитьПромптИсправленияDSL(ТекстОшибкиСКонтекстом, ИсходныйDSL);
	
	// ТЕМПЕРАТУРА: Повышаем температуру при исправлении ошибок для креативности в подборе синонимов
	Температура = 0.7;
	
	// Вызываем ИИ с системным сообщением (не от пользователя)
	// Для исправления ошибок RAG может быть полезен для поиска альтернативных имен
	Возврат ВызватьИИССистемнымСообщением(СсылкаДиалога, "Чат", ПромптИсправления, "", "dsl", Температура, Истина);
КонецФункции

// Вызывает ИИ с системным сообщением (не от пользователя)
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстСистемногоСообщения - Строка - текст системного сообщения
//  СистемныйПромпт - Строка - (опционально) переопределение системного промпта
//  ExpectedResponseFormat - Строка - ожидаемый формат ответа
//  Температура - Число - (опционально) температура модели
//  ИспользоватьRAG - Булево - (опционально) если Истина, RAG-контекст будет добавлен
//
// Возвращаемое значение:
//  Структура - структура ответа от ВызватьИИ
//
Функция ВызватьИИССистемнымСообщением(СсылкаДиалога, ТипСообщения, ТекстСистемногоСообщения, СистемныйПромпт = "", ExpectedResponseFormat = "dsl", Температура = Неопределено, Знач ИспользоватьRAG = Ложь, Знач АвтоВыполнятьDSL = Истина) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	Пользователь = Диалог.Пользователь;
	CallId = Строка(Новый УникальныйИдентификатор);
	
	// Получаем настройки пользователя
	ПараметрыПользователя = ПолучитьНастройкиПользователя(Пользователь);
	ПараметрыПользователя.Вставить("Пользователь", Пользователь);
	ПараметрыПользователя.Вставить("ТипДиалога", Диалог.ТипДиалога);
	ПараметрыПользователя.Вставить("СсылкаДиалога", СсылкаДиалога);
	ПараметрыПользователя.Вставить("ИспользоватьRAG", ИспользоватьRAG);
	АрхКонтекст = ПолучитьКонтекстАрхитектуры(СсылкаДиалога);
	Если НЕ ПустаяСтрока(АрхКонтекст.trace_id) Тогда
		ПараметрыПользователя.Вставить("trace_id", АрхКонтекст.trace_id);
	КонецЕсли;
	Если НЕ ПустаяСтрока(АрхКонтекст.prompt_version) Тогда
		ПараметрыПользователя.Вставить("prompt_version", АрхКонтекст.prompt_version);
	КонецЕсли;
	
	// Ожидаемый формат ответа задается ЯВНО вызывающим кодом (hard mode).
	ПараметрыПользователя.Вставить("ExpectedResponseFormat", ExpectedResponseFormat);
	
	// Режим холостого хода: берём mock из очереди, если есть
	СтруктураДанных = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
	Если СтруктураДанных <> Неопределено И ТипЗнч(СтруктураДанных) = Тип("Структура") И СтруктураДанных.Свойство("MockОтветыОчередь") Тогда
		Очередь = СтруктураДанных.MockОтветыОчередь;
		Если ТипЗнч(Очередь) = Тип("Массив") И Очередь.Количество() > 0 Тогда
			ВзятыйMock = Очередь[0];
			Очередь.Удалить(0);
			СтруктураДанных.MockОтветыОчередь = Очередь;
			ЗаписатьДанныеДиалогаВРегистр(СсылкаДиалога, СтруктураДанных);
			ПараметрыПользователя.Вставить("MockОтвет", ВзятыйMock);
		КонецЕсли;
	КонецЕсли;
	
	// Загружаем историю диалога
	МассивИстории = ПолучитьСообщенияДиалога(СсылкаДиалога, 50);
	
	// ОЧИСТКА СТАРЫХ МЕТАДАННЫХ (Context Saver)
	// Оставляем только самый последний результат GetMetadata/GetObjectFields в истории
	DiscoveryНайдено = Ложь;
	КоличествоИстории = МассивИстории.Количество();
	Если КоличествоИстории > 0 Тогда
		Для Индекс = КоличествоИстории - 1 По 0 Цикл
			СтрокаИст = МассивИстории[Индекс];
			Если СтрокаИст.Автор = Перечисления.ИИА_АвторСообщения.Система Тогда
				ЭтоDiscovery = (СтрНайти(СтрокаИст.Текст, "Получены метаданные") > 0 
					ИЛИ СтрНайти(СтрокаИст.Текст, "Получены реквизиты") > 0);
				
				Если ЭтоDiscovery Тогда
					Если DiscoveryНайдено Тогда
						// Удаляем тело старого результата, оставляя только заголовок
						ПозПС = СтрНайти(СтрокаИст.Текст, Символы.ПС);
						Если ПозПС > 0 Тогда
							СтрокаИст.Текст = Лев(СтрокаИст.Текст, ПозПС) + "...(старые данные удалены для экономии контекста)";
						КонецЕсли;
					Иначе
						DiscoveryНайдено = Истина;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Преобразуем массив в таблицу значений для функции ВызватьИИ
	История = ПреобразоватьМассивСообщенийВТаблицу(МассивИстории);

	// ВАЖНО: системный промпт НЕ добавляем в Диалог.Сообщения, чтобы не создавать самоповтор
	// (он иначе попадает в историю/StateSummary/Результаты последних действий и раздувает контекст).
	// Вызываем ИИ (передаем системное сообщение как текст пользователя для ИИ, но не сохраняем его как сообщение диалога)
	// Для плановых форматов системный промпт должен соответствовать контракту (иначе модель будет возвращать DSL).
	СистемныйПромптДляВызова = СистемныйПромпт;
	
	ОтветИИ = ИИА_Провайдеры.ВызватьИИ(ТипСообщения, ТекстСистемногоСообщения, История, ПараметрыПользователя, СистемныйПромптДляВызова, Температура);
	
	// Добавляем промпт в ответ для вывода в лог на клиенте
	Если ОтветИИ.Свойство("Промпт") Тогда
		// Промпт уже добавлен в ответ от ИИ
	Иначе
		ОтветИИ.Вставить("Промпт", "");
	КонецЕсли;
	
	// Диагностическое логирование LLM (подробно, но не влияет на контекст)
	МодельДляЛога = "";
	Если ПараметрыПользователя.Свойство("Модель") И НЕ ПустаяСтрока(ПараметрыПользователя.Модель) Тогда
		МодельДляЛога = ПараметрыПользователя.Модель;
	Иначе
		МодельДляЛога = "auto";
	КонецЕсли;
	
	ТекстЛога = "[LLM_REQUEST] CallId=" + CallId +
		", Type=" + ТипСообщения +
		", ExpectedResponseFormat=" + ExpectedResponseFormat +
		", Model=" + МодельДляЛога;
	Если НЕ ПустаяСтрока(АрхКонтекст.trace_id) Тогда
		ТекстЛога = ТекстЛога + ", TraceId=" + АрхКонтекст.trace_id;
	КонецЕсли;
	Если НЕ ПустаяСтрока(АрхКонтекст.prompt_version) Тогда
		ТекстЛога = ТекстЛога + ", PromptVersion=" + АрхКонтекст.prompt_version;
	КонецЕсли;
		
	Если Температура <> Неопределено Тогда
		ТекстЛога = ТекстЛога + ", Temperature=" + Строка(Температура);
	Иначе
		ТекстЛога = ТекстЛога + ", Temperature=0.0";
	КонецЕсли;
	
	// Компактный промпт (JSON и переносы в одну строку) для уменьшения объёма лога
	ПромптКомпакт = СжатьJSONВСтроку(ОтветИИ.Промпт);
	ТекстЛога = ТекстЛога + Символы.ПС + ПромптКомпакт;
	
	ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, ТекстЛога, "LLM_REQUEST", CallId);
	
	Если ОтветИИ.Свойство("RawModelText") И НЕ ПустаяСтрока(Строка(ОтветИИ.RawModelText)) Тогда
		RawText = Строка(ОтветИИ.RawModelText);
	Иначе
		RawText = ОтветИИ.Текст;
	КонецЕсли;
	
	// Компактный вывод JSON (план и др.) в лог
	RawTextДляЛога = RawText;
	Обрезанный = СокрЛП(RawText);
	Если (СтрНайти(Обрезанный, "[") = 1 ИЛИ СтрНайти(Обрезанный, "{") = 1) И СтрДлина(RawText) > 200 Тогда
		RawTextДляЛога = СжатьJSONВСтроку(RawText);
	КонецЕсли;
	
	ДобавитьЗаписьВЛогДиалога(
		СсылкаДиалога,
		"[LLM_RESPONSE_RAW] CallId=" + CallId + Символы.ПС + RawTextДляЛога,
		"LLM_RESPONSE_RAW",
		CallId
	);
	
	НормализованныйJSON = ИИА_DSL.НормализоватьJSONТекст(RawText);
	Если НЕ ПустаяСтрока(НормализованныйJSON) Тогда
		// Пишем нормализованный JSON только если он реально отличается от сырого текста
		Если СокрЛП(НормализованныйJSON) <> СокрЛП(RawText) Тогда
			ДобавитьЗаписьВЛогДиалога(
				СсылкаДиалога,
				"[LLM_RESPONSE_NORMALIZED_JSON] CallId=" + CallId + Символы.ПС + СжатьJSONВСтроку(НормализованныйJSON),
				"LLM_RESPONSE_NORMALIZED_JSON",
				CallId
			);
		КонецЕсли;
	КонецЕсли;
	
	// Usage (если провайдер вернул)
	UsageText = "";
	UsageTokens = 0;
	Если ОтветИИ.Свойство("Usage") И ОтветИИ.Usage <> Неопределено Тогда
		Если ТипЗнч(ОтветИИ.Usage) = Тип("Структура") И ОтветИИ.Usage.Свойство("TotalTokens") Тогда
			UsageText = Символы.ПС + "[Usage] TotalTokens=" + Строка(ОтветИИ.Usage.TotalTokens);
			UsageTokens = ОтветИИ.Usage.TotalTokens;
		КонецЕсли;
	КонецЕсли;
	
	ParsedKind = ExpectedResponseFormat;
	ТекстДлина = 0;
	Если ОтветИИ.Свойство("Текст") И НЕ ПустаяСтрока(ОтветИИ.Текст) Тогда
		ТекстДлина = СтрДлина(ОтветИИ.Текст);
	КонецЕсли;
	
	DSLДляЛога = "";
	Если ОтветИИ.Свойство("DSL") И НЕ ПустаяСтрока(ОтветИИ.DSL) Тогда
		DSLДляЛога = Символы.ПС + "[DSL]" + Символы.ПС + СжатьJSONВСтроку(ОтветИИ.DSL);
	КонецЕсли;
	ДобавитьЗаписьВЛогДиалога(
		СсылкаДиалога,
		"[LLM_RESPONSE_PARSED] CallId=" + CallId +
		", ParsedKind=" + ParsedKind +
		", ТипОтвета=" + ОтветИИ.ТипОтвета +
		?(ТекстДлина > 0, ", TextLen=" + Формат(ТекстДлина, "ЧН=0"), "") +
		UsageText +
		DSLДляЛога,
		"LLM_RESPONSE_PARSED",
		CallId
	);
	
	// Определяем тип ответа для хранения
	Если ОтветИИ.ТипОтвета = "Ошибка" ИЛИ ОтветИИ.ТипОтвета = "ОшибкаКонтракта" Тогда
		
		// В лог диалога пишем сырой ответ модели (если есть), даже если он не DSL
		Если ОтветИИ.Свойство("RawModelText") И НЕ ПустаяСтрока(Строка(ОтветИИ.RawModelText)) Тогда
			ДобавитьСообщениеВДиалог(
				СсылкаДиалога,
				Перечисления.ИИА_АвторСообщения.ИИ,
				Перечисления.ИИА_ТипСообщения.Текст,
				Строка(ОтветИИ.RawModelText),
				"",
				"",
				UsageTokens
			);
			
			// Явно помечаем в логе, что сырое тело сохранено также как сообщение ИИ (для истории/UI)
			ДобавитьЗаписьВЛогДиалога(
				СсылкаДиалога,
				"[LLM_RESPONSE_RAW_AS_DIALOG_MESSAGE] CallId=" + CallId,
				"LLM_RESPONSE_RAW_AS_DIALOG_MESSAGE",
				CallId
			);
		КонецЕсли;
		
		// Ошибку контракта/провайдера пишем как системную ошибку (чтобы не путать «что ответила модель» и «что мы не приняли»)
		ТекстОшибкиСообщение = ОтветИИ.Текст;
		Если ОтветИИ.Свойство("Ошибки") И НЕ ПустаяСтрока(Строка(ОтветИИ.Ошибки)) Тогда
			ТекстОшибкиСообщение = ТекстОшибкиСообщение + Символы.ПС + "Детали: " + Строка(ОтветИИ.Ошибки);
		КонецЕсли;
		ДобавитьСообщениеВДиалог(
			СсылкаДиалога,
			Перечисления.ИИА_АвторСообщения.Система,
			Перечисления.ИИА_ТипСообщения.Ошибка,
			ТекстОшибкиСообщение
		);
		
		Возврат ОтветИИ;
	ИначеЕсли ОтветИИ.ТипОтвета = "Запрос" Тогда
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Запрос;
		ТекстОтвета = ОтветИИ.Текст;
		ТекстКодаОтвета = ОтветИИ.Запрос;
	ИначеЕсли ОтветИИ.ТипОтвета = "DSL" Тогда
		// Обрабатываем DSL-сценарий
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Код;
		ТекстОтвета = ОтветИИ.Текст;
		// Получаем DSL из ответа
		Если ОтветИИ.Свойство("DSL") И НЕ ПустаяСтрока(ОтветИИ.DSL) Тогда
			ТекстКодаОтвета = ОтветИИ.DSL;
		Иначе
			ТекстКодаОтвета = "";
		КонецЕсли;
		
	Иначе
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Текст;
		ТекстОтвета = ОтветИИ.Текст;
		ТекстКодаОтвета = "";
	КонецЕсли;
	
	// Определяем статус DSL для сообщения (пока ставим "ВОчереди", потом обновим после выполнения)
	СтатусDSLСообщения = Неопределено;
	Если ОтветИИ.ТипОтвета = "DSL" И (НЕ ПустаяСтрока(ТекстКодаОтвета) ИЛИ НЕ ПустаяСтрока(ОтветИИ.DSL)) Тогда
		СтатусDSLСообщения = Перечисления.ИИА_СтатусDSL.ВОчереди;
	КонецЕсли;
	
	// Добавляем ответ ИИ
	ДобавитьСообщениеВДиалог(
		СсылкаДиалога,
		Перечисления.ИИА_АвторСообщения.ИИ,
		ТипСообщенияОтвета,
		ТекстОтвета,
		ТекстКодаОтвета,
		"",
		UsageTokens,
		СтатусDSLСообщения
	);
	
	// Обрабатываем DSL-сценарий (если это DSL)
	Если ОтветИИ.ТипОтвета = "DSL" И НЕ ПустаяСтрока(ОтветИИ.DSL) И АвтоВыполнятьDSL Тогда
		
		// Выполняем DSL (сообщения уже добавлены в диалог)
		ТолькоЧтение = (СсылкаДиалога.ТипДиалога = Перечисления.ИИА_ТипДиалога.Запрос1С);
		Если ПараметрыПользователя.Свойство("ДоступнаЗапись") И НЕ ПараметрыПользователя.ДоступнаЗапись Тогда
			ТолькоЧтение = Истина;
		КонецЕсли;
		РезультатDSL = ИИА_DSL.ВыполнитьDSL(ОтветИИ.DSL, СсылкаДиалога, ТолькоЧтение);
		
		Если РезультатDSL.Успех Тогда
			ОбновитьСтатусDSLВПоследнемСообщении(СсылкаДиалога, Перечисления.ИИА_СтатусDSL.ОбработанУспешно);
			
			// Формируем системный ответ для ИИ (JSON)
			Если РезультатDSL.Свойство("СистемныйОтвет") И НЕ ПустаяСтрока(РезультатDSL.СистемныйОтвет) Тогда
				ТекстСистемногоСообщения = РезультатDSL.СистемныйОтвет;
			Иначе
				ТекстСистемногоСообщения = "{""kind"":""dsl_system_result"",""schema_version"":1,""success"":false,""error"":""Системный ответ DSL пуст""}";
			КонецЕсли;
			
			ДобавитьСообщениеВДиалог(
				СсылкаДиалога,
				Перечисления.ИИА_АвторСообщения.Система,
				Перечисления.ИИА_ТипСообщения.Текст,
				СокрЛП(ТекстСистемногоСообщения),
				"",
				"",
				0
			);
			
			// Добавляем ссылки на объекты
			Если РезультатDSL.Свойство("СсылкиОбъектов") И РезультатDSL.СсылкиОбъектов.Количество() > 0 Тогда
				МассивСсылок = РезультатDSL.СсылкиОбъектов;
				
				// Сохраняем ссылки в табличную часть ИзмененныеОбъекты
				ДобавитьИзмененныеОбъекты(СсылкаДиалога, МассивСсылок);
				
				ТекстСсылок = "";
				Если МассивСсылок.Количество() = 1 Тогда
					ТекстСсылок = "Объект: " + МассивСсылок[0];
				Иначе
					ТекстСсылок = "Создано/изменено объектов: " + Формат(МассивСсылок.Количество(), "ЧН=0");
					Для Каждого СсылкаОбъекта Из МассивСсылок Цикл
						ТекстСсылок = ТекстСсылок + Символы.ПС + "- " + СсылкаОбъекта;
					КонецЦикла;
				КонецЕсли;
				
				ДобавитьСообщениеВДиалог(
					СсылкаДиалога,
					Перечисления.ИИА_АвторСообщения.Система,
					Перечисления.ИИА_ТипСообщения.Текст,
					ТекстСсылок,
					"",
					"",
					0
				);
			КонецЕсли;
			
		Иначе
			ОбновитьСтатусDSLВПоследнемСообщении(СсылкаДиалога, Перечисления.ИИА_СтатусDSL.ОбработанСОшибкой);
			
			Если РезультатDSL.Свойство("СистемныйОтвет") И НЕ ПустаяСтрока(РезультатDSL.СистемныйОтвет) Тогда
				ТекстОшибки = РезультатDSL.СистемныйОтвет;
			Иначе
				ТекстОшибки = "{""kind"":""dsl_system_result"",""schema_version"":1,""success"":false,""error"":""Ошибка выполнения DSL: " + РезультатDSL.Сообщение + """}";
			КонецЕсли;
			ДобавитьСообщениеВДиалог(
				СсылкаДиалога,
				Перечисления.ИИА_АвторСообщения.Система,
				Перечисления.ИИА_ТипСообщения.Ошибка,
				ТекстОшибки,
				"",
				"",
				0
			);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ОтветИИ;
	
КонецФункции

// Отправляет сообщение и получает ответ от ИИ
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//
// Возвращаемое значение:
//  Структура - структура ответа от ВызватьИИ
//
Функция ОтправитьСообщениеСервера(СсылкаДиалога, ТипСообщения, ТекстПользователя) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	Пользователь = Диалог.Пользователь;
	
	// Обновляем наименование диалога по первому сообщению пользователя (если наименование стандартное)
	СтандартноеНаименование = "Диалог ИИ от ";
	Если Лев(Диалог.Наименование, СтрДлина(СтандартноеНаименование)) = СтандартноеНаименование И НЕ ПустаяСтрока(ТекстПользователя) Тогда
		// Формируем новое наименование из текста пользователя
		НовоеНаименование = СокрЛП(ТекстПользователя);
		// Заменяем переносы строк на пробелы
		НовоеНаименование = СтрЗаменить(НовоеНаименование, Символы.ПС, " ");
		НовоеНаименование = СтрЗаменить(НовоеНаименование, Символы.ВТаб, " ");
		
		// Ограничиваем длину (Description до 50 символов по умолчанию)
		Если СтрДлина(НовоеНаименование) > 50 Тогда
			НовоеНаименование = Лев(НовоеНаименование, 47) + "...";
		КонецЕсли;
		
		Диалог.Наименование = НовоеНаименование;
		Диалог.Записать();
		УведомитьОбОбновленииДиалога(СсылкаДиалога, "НовоеСообщение");
	КонецЕсли;

	// Если передан ТипДиалога (перечисление), обновляем его в диалоге и используем
	Если ТипЗнч(ТипСообщения) = Тип("ПеречислениеСсылка.ИИА_ТипДиалога") Тогда
		Если Диалог.ТипДиалога <> ТипСообщения Тогда
			Диалог.ТипДиалога = ТипСообщения;
			Диалог.Записать();
			УведомитьОбОбновленииДиалога(СсылкаДиалога, "НовоеСообщение");
		КонецЕсли;
	КонецЕсли;
	
	// Получаем настройки пользователя
	ПараметрыИИ = ПолучитьНастройкиПользователя(Пользователь);
	ПараметрыИИ.Вставить("Пользователь", Пользователь);
	ПараметрыИИ.Вставить("ТипДиалога", Диалог.ТипДиалога);
	ПараметрыИИ.Вставить("СсылкаДиалога", СсылкаДиалога);
	
	ПараметрыRAG = ОпределитьRAGДляСообщения(ТекстПользователя, Диалог.ТипДиалога);
	ПараметрыИИ.Вставить("ИспользоватьRAG", ПараметрыRAG.ИспользоватьRAG);
	Если ЗначениеЗаполнено(СсылкаДиалога) Тогда
		ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "[RAG_DECISION] Пользователь: " + ?(ПараметрыRAG.ИспользоватьRAG, "включен", "выключен") + ". " + ПараметрыRAG.Причина);
	КонецЕсли;
	
	// Загружаем историю диалога
	МассивИстории = ПолучитьСообщенияДиалога(СсылкаДиалога, 10);
	
	// Преобразуем массив в таблицу значений для функции ВызватьИИ
	История = ПреобразоватьМассивСообщенийВТаблицу(МассивИстории);
	
	// Определяем тип сообщения для хранения
	Если ТипСообщения = "Запрос" Тогда
		ТипСообщенияДляХранения = Перечисления.ИИА_ТипСообщения.Запрос;
	Иначе
		ТипСообщенияДляХранения = Перечисления.ИИА_ТипСообщения.Текст;
	КонецЕсли;
	
	// Добавляем сообщение пользователя
	ДобавитьСообщениеВДиалог(
		СсылкаДиалога,
		Перечисления.ИИА_АвторСообщения.Пользователь,
		ТипСообщенияДляХранения,
		ТекстПользователя
	);

	// ПЛАНИРОВАНИЕ: Если это режим Агента или Запроса, мы должны сначала спланировать.
	Если Диалог.ТипДиалога = Перечисления.ИИА_ТипДиалога.Агент ИЛИ Диалог.ТипДиалога = Перечисления.ИИА_ТипДиалога.Запрос1С Тогда
		Диалог = СсылкаДиалога.ПолучитьОбъект();
		// Продолжение плана: если план завершён — дополняем, иначе — очищаем (прерывание)
		Если ИИА_Оркестратор.ПланЗавершен(СсылкаДиалога) Тогда
			Если НЕ ИИА_Оркестратор.ДополнитьПлан(СсылкаДиалога) Тогда
				// Запасной вариант при ошибке дополнения
				Диалог = СсылкаДиалога.ПолучитьОбъект();
				Диалог.План.Очистить();
				Диалог.Записать();
			КонецЕсли;
		Иначе
			Диалог.План.Очистить();
			Диалог.Записать();
		КонецЕсли;
		УведомитьОбОбновленииДиалога(СсылкаДиалога, "ЗапросПринят");
		
		// Возвращаем пустой результат, чтобы клиент запустил оркестратор (планирование)
		Результат = Новый Структура;
		Результат.Вставить("ТипОтвета", "Текст");
		Результат.Вставить("Текст", "Запрос принят. Начинаю планирование...");
		Результат.Вставить("Usage", Новый Структура("TotalTokens", 0));
		
		Возврат Результат;
	КонецЕсли;

	// Очищаем результат проверки задачи
	СброситьРезультатПроверкиВХранилище(СсылкаДиалога);
	
	// Вызываем ИИ (только для обычных чатов, где нет принудительного планирования)
	ОтветИИ = ИИА_Провайдеры.ВызватьИИ(ТипСообщения, ТекстПользователя, История, ПараметрыИИ);
	
	// Добавляем промпт в ответ для вывода в лог на клиенте
	Если ОтветИИ.Свойство("Промпт") Тогда
		// Промпт уже добавлен в ответ от ИИ
	Иначе
		ОтветИИ.Вставить("Промпт", "");
	КонецЕсли;
	
	// Определяем тип ответа для хранения
	Если ОтветИИ.ТипОтвета = "Ошибка" ИЛИ ОтветИИ.ТипОтвета = "ОшибкаКонтракта" Тогда
		
		// В лог диалога пишем сырой ответ модели (если есть), даже если он не DSL
		Если ОтветИИ.Свойство("RawModelText") И НЕ ПустаяСтрока(Строка(ОтветИИ.RawModelText)) Тогда
			ДобавитьСообщениеВДиалог(
				СсылкаДиалога,
				Перечисления.ИИА_АвторСообщения.ИИ,
				Перечисления.ИИА_ТипСообщения.Текст,
				Строка(ОтветИИ.RawModelText)
			);
		КонецЕсли;
		
		ТекстОшибкиСообщение = ОтветИИ.Текст;
		Если ОтветИИ.Свойство("Ошибки") И НЕ ПустаяСтрока(Строка(ОтветИИ.Ошибки)) Тогда
			ТекстОшибкиСообщение = ТекстОшибкиСообщение + Символы.ПС + "Детали: " + Строка(ОтветИИ.Ошибки);
		КонецЕсли;
		
		ДобавитьСообщениеВДиалог(
			СсылкаДиалога,
			Перечисления.ИИА_АвторСообщения.Система,
			Перечисления.ИИА_ТипСообщения.Ошибка,
			ТекстОшибкиСообщение
		);
		
		Возврат ОтветИИ;
	ИначеЕсли ОтветИИ.ТипОтвета = "Запрос" Тогда
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Запрос;
		ТекстОтвета = ОтветИИ.Текст;
		ТекстКодаОтвета = ОтветИИ.Запрос;
	ИначеЕсли ОтветИИ.ТипОтвета = "DSL" Тогда
		// Обрабатываем DSL-сценарий
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Код;
		ТекстОтвета = ОтветИИ.Текст;
		// Получаем DSL из ответа
		Если ОтветИИ.Свойство("DSL") И НЕ ПустаяСтрока(ОтветИИ.DSL) Тогда
			ТекстКодаОтвета = ОтветИИ.DSL;
		Иначе
			ТекстКодаОтвета = "";
		КонецЕсли;
		
	Иначе
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Текст;
		ТекстОтвета = ОтветИИ.Текст;
		ТекстКодаОтвета = "";
	КонецЕсли;
	
	// Получаем UsageTokens
	UsageTokens = 0;
	Если ОтветИИ.Свойство("Usage") И ОтветИИ.Usage <> Неопределено Тогда
		Если ТипЗнч(ОтветИИ.Usage) = Тип("Структура") И ОтветИИ.Usage.Свойство("TotalTokens") Тогда
			UsageTokens = ОтветИИ.Usage.TotalTokens;
		КонецЕсли;
	КонецЕсли;
	
	// Определяем статус DSL для сообщения (пока ставим "ВОчереди", потом обновим после выполнения)
	СтатусDSLСообщения = Неопределено;
	Если ОтветИИ.ТипОтвета = "DSL" И (НЕ ПустаяСтрока(ТекстКодаОтвета) ИЛИ НЕ ПустаяСтрока(ОтветИИ.DSL)) Тогда
		СтатусDSLСообщения = Перечисления.ИИА_СтатусDSL.ВОчереди;
	КонецЕсли;
	
	// Сначала добавляем ответ ИИ
	ДобавитьСообщениеВДиалог(
		СсылкаДиалога,
		Перечисления.ИИА_АвторСообщения.ИИ,
		ТипСообщенияОтвета,
		ТекстОтвета,
		ТекстКодаОтвета,
		"",
		UsageTokens,
		СтатусDSLСообщения
	);
	
		// Теперь обрабатываем DSL-сценарий (если это DSL)
		Если ОтветИИ.ТипОтвета = "DSL" И НЕ ПустаяСтрока(ОтветИИ.DSL) Тогда
			
			// Выполняем DSL
			РезультатDSL = ВыполнитьDSLСценарий(ОтветИИ.DSL, СсылкаДиалога);
		
		// Добавляем информацию о результате DSL в ответ для клиента
		ОтветИИ.Вставить("РезультатDSL", РезультатDSL);
		ОтветИИ.Вставить("DSLJSON", ОтветИИ.DSL);
		
		// Базовая обработка результата (статус и сообщения об успехе/ошибке)
		Если РезультатDSL.Успех Тогда
			ОбновитьСтатусDSLВПоследнемСообщении(СсылкаДиалога, Перечисления.ИИА_СтатусDSL.ОбработанУспешно);
			
			// Формируем системный ответ для ИИ
			// Формируем системный ответ для ИИ (JSON)
			Если РезультатDSL.Свойство("СистемныйОтвет") И НЕ ПустаяСтрока(РезультатDSL.СистемныйОтвет) Тогда
				ТекстСистемногоСообщения = РезультатDSL.СистемныйОтвет;
			Иначе
				ТекстСистемногоСообщения = "{""kind"":""dsl_system_result"",""schema_version"":1,""success"":false,""error"":""Системный ответ DSL пуст""}";
			КонецЕсли;
			
			ДобавитьСообщениеВДиалог(
				СсылкаДиалога,
				Перечисления.ИИА_АвторСообщения.Система,
				Перечисления.ИИА_ТипСообщения.Текст,
				СокрЛП(ТекстСистемногоСообщения),
				"",
				"",
				0
			);
			
			// Добавляем ссылки на объекты
			Если РезультатDSL.Свойство("СсылкиОбъектов") И РезультатDSL.СсылкиОбъектов.Количество() > 0 Тогда
				МассивСсылок = РезультатDSL.СсылкиОбъектов;
				
				// Сохраняем ссылки в табличную часть ИзмененныеОбъекты
				ДобавитьИзмененныеОбъекты(СсылкаДиалога, МассивСсылок);
				
				ТекстСсылок = "";
				Если МассивСсылок.Количество() = 1 Тогда
					ТекстСсылок = "Объект: " + МассивСсылок[0];
				Иначе
					ТекстСсылок = "Создано/изменено объектов: " + Формат(МассивСсылок.Количество(), "ЧН=0");
					Для Каждого СсылкаОбъекта Из МассивСсылок Цикл
						ТекстСсылок = ТекстСсылок + Символы.ПС + "- " + СсылкаОбъекта;
					КонецЦикла;
				КонецЕсли;
				
				ДобавитьСообщениеВДиалог(
					СсылкаДиалога,
					Перечисления.ИИА_АвторСообщения.Система,
					Перечисления.ИИА_ТипСообщения.Текст,
					ТекстСсылок,
					"",
					"",
					0
				);
			КонецЕсли;
			
			// Проверка результата выполнения задачи будет выполнена на клиенте
			// Результат DSL передается клиенту для обработки итераций
			
		Иначе
			ОбновитьСтатусDSLВПоследнемСообщении(СсылкаДиалога, Перечисления.ИИА_СтатусDSL.ОбработанСОшибкой);
			
			Если РезультатDSL.Свойство("СистемныйОтвет") И НЕ ПустаяСтрока(РезультатDSL.СистемныйОтвет) Тогда
				ТекстОшибки = РезультатDSL.СистемныйОтвет;
			Иначе
				ТекстОшибки = "{""kind"":""dsl_system_result"",""schema_version"":1,""success"":false,""error"":""Ошибка выполнения DSL: " + РезультатDSL.Сообщение + """}";
			КонецЕсли;
			ДобавитьСообщениеВДиалог(
				СсылкаДиалога,
				Перечисления.ИИА_АвторСообщения.Система,
				Перечисления.ИИА_ТипСообщения.Ошибка,
				ТекстОшибки,
				"",
				"",
				0
			);
		КонецЕсли;
		
	КонецЕсли;
	
	// Если есть ТекстКода, добавляем системное сообщение о получении кода (только для не-DSL типов)
	Если НЕ ПустаяСтрока(ТекстКодаОтвета) И ОтветИИ.ТипОтвета <> "DSL" Тогда
		
		// Определяем текст системного сообщения в зависимости от типа
		Если ОтветИИ.ТипОтвета = "Запрос" Тогда
			ТекстСистемногоСообщения = "Запрос сгенерирован.";
		Иначе
			ТекстСистемногоСообщения = "ИИ сгенерировал код.";
		КонецЕсли;
		
		ДобавитьСообщениеВДиалог(
			СсылкаДиалога,
			Перечисления.ИИА_АвторСообщения.Система,
			Перечисления.ИИА_ТипСообщения.Текст,
			ТекстСистемногоСообщения,
			"",
			"",
			0
		);
		
	КонецЕсли;
	
	Возврат ОтветИИ;
	
КонецФункции

// Проверяет запрос 1С на выполнимость
//
// Параметры:
//  ТекстЗапроса - Строка - текст запроса
//
// Возвращаемое значение:
//  Структура - структура результата:
//   * Успех - Булево - успешность выполнения
//   * Сообщение - Строка - текст ошибки или пусто
//
Функция ПроверитьЗапрос(ТекстЗапроса) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Успех", Ложь);
	Результат.Вставить("Сообщение", "");
	
	Попытка
		
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.Выполнить();
		
		Результат.Успех = Истина;
		
	Исключение
		
		Результат.Сообщение = ОписаниеОшибки();
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Выполняет DSL сценарий
//
// Параметры:
//  DSLJSON - Строка - JSON с DSL командами
//
// Возвращаемое значение:
//  Структура - структура результата выполнения DSL
//
Функция ВыполнитьDSLСценарий(DSLJSON, СсылкаДиалога = Неопределено) Экспорт
	
	// Выполняем DSL
	// В режиме Запрос1С устанавливаем флаг ТолькоЧтение
	ТолькоЧтение = Ложь;
	Если ЗначениеЗаполнено(СсылкаДиалога) Тогда
		ИнициализироватьКонтекстАрхитектуры(СсылкаДиалога);
		ТолькоЧтение = (СсылкаДиалога.ТипДиалога = Перечисления.ИИА_ТипДиалога.Запрос1С);
		
		// Учитываем настройку «ДоступнаЗапись»
		Попытка
			Диалог = СсылкаДиалога.ПолучитьОбъект();
			НастройкиПольз = ПолучитьНастройкиПользователя(Диалог.Пользователь);
			Если НастройкиПольз.Свойство("ДоступнаЗапись") И НЕ НастройкиПольз.ДоступнаЗапись Тогда
				ТолькоЧтение = Истина;
			КонецЕсли;
		Исключение
			// если не удалось получить настройки - не меняем поведение
			ТекстОшибки = ОписаниеОшибки();
		КонецПопытки;
	КонецЕсли;
	
	РезультатDSL = ИИА_DSL.ВыполнитьDSL(DSLJSON, СсылкаДиалога, ТолькоЧтение);
	
	// Обрабатываем результаты для установки флагов открытия табличного документа
	Если РезультатDSL.Успех Тогда
		// Проверяем, есть ли данные запроса в результате DSL (устанавливается при RunQuery)
		Если РезультатDSL.Свойство("ДанныеЗапросаДляТаблицы") И РезультатDSL.ДанныеЗапросаДляТаблицы <> Неопределено Тогда
			// Сохраняем последние данные запроса в хранилище диалога (для показа таблицы в конце оркестратора)
			Если ЗначениеЗаполнено(СсылкаДиалога) Тогда
				УстановитьДанныеЗапросаВХранилище(СсылкаДиалога, РезультатDSL.ДанныеЗапросаДляТаблицы);
			КонецЕсли;
			
			РезультатDSL.Вставить("ОткрытьТабличныйДокумент", Истина);
			РезультатDSL.Вставить("ДанныеЗапроса", РезультатDSL.ДанныеЗапросаДляТаблицы);
		ИначеЕсли РезультатDSL.Результаты.Количество() > 0 Тогда
			// Проверяем результаты шагов для ShowInfo с результатом запроса
			Для Каждого РезультатШага Из РезультатDSL.Результаты Цикл
				// Если это результат ShowInfo с результатом запроса, устанавливаем флаги
				Если РезультатШага.Свойство("ТипДействия") И РезультатШага.ТипДействия = "ShowInfo" И
				   РезультатШага.Свойство("ЕстьРезультатЗапроса") И РезультатШага.ЕстьРезультатЗапроса Тогда
					РезультатDSL.Вставить("ОткрытьТабличныйДокумент", Истина);
					// Копируем данные запроса в результат DSL
					Если РезультатDSL.Свойство("ДанныеЗапросаДляТаблицы") Тогда
						РезультатDSL.Вставить("ДанныеЗапроса", РезультатDSL.ДанныеЗапросаДляТаблицы);
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Возврат РезультатDSL;
	
КонецФункции

// Выполняет DSL-сценарий без добавления сообщений в диалог
//
// Параметры:
//  DSLJSON - Строка - JSON с DSL командами
//
// Возвращаемое значение:
//  Структура - структура результата выполнения DSL
//
Функция ВыполнитьDSLСценарийБезСообщений(DSLJSON, СсылкаДиалога = Неопределено) Экспорт
	
	// Выполняем DSL без добавления сообщений
	// В режиме Запрос1С устанавливаем флаг ТолькоЧтение
	ТолькоЧтение = Ложь;
	Если ЗначениеЗаполнено(СсылкаДиалога) Тогда
		ИнициализироватьКонтекстАрхитектуры(СсылкаДиалога);
		ТолькоЧтение = (СсылкаДиалога.ТипДиалога = Перечисления.ИИА_ТипДиалога.Запрос1С);
		
		// Учитываем настройку «ДоступнаЗапись»
		Попытка
			Диалог = СсылкаДиалога.ПолучитьОбъект();
			НастройкиПольз = ПолучитьНастройкиПользователя(Диалог.Пользователь);
			Если НастройкиПольз.Свойство("ДоступнаЗапись") И НЕ НастройкиПольз.ДоступнаЗапись Тогда
				ТолькоЧтение = Истина;
			КонецЕсли;
		Исключение
			// если не удалось получить настройки - не меняем поведение
			ТекстОшибки = ОписаниеОшибки();
		КонецПопытки;
	КонецЕсли;
	
	РезультатDSL = ИИА_DSL.ВыполнитьDSL(DSLJSON, СсылкаДиалога, ТолькоЧтение);
	
	Возврат РезультатDSL;
	
КонецФункции

// Выполняет DSL-сценарий и добавляет системные сообщения в диалог
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  DSLJSON - Строка - JSON с DSL командами
//
// Возвращаемое значение:
//  Структура - структура результата выполнения DSL
//
Функция ВыполнитьDSLСценарийССообщениями(СсылкаДиалога, DSLJSON) Экспорт
	
	// Выполняем DSL
	// В режиме Запрос1С устанавливаем флаг ТолькоЧтение
	ИнициализироватьКонтекстАрхитектуры(СсылкаДиалога);
	ТолькоЧтение = (СсылкаДиалога.ТипДиалога = Перечисления.ИИА_ТипДиалога.Запрос1С);
	
	// Учитываем настройку «ДоступнаЗапись»
	Попытка
		Диалог = СсылкаДиалога.ПолучитьОбъект();
		НастройкиПольз = ПолучитьНастройкиПользователя(Диалог.Пользователь);
		Если НастройкиПольз.Свойство("ДоступнаЗапись") И НЕ НастройкиПольз.ДоступнаЗапись Тогда
			ТолькоЧтение = Истина;
		КонецЕсли;
	Исключение
		// если не удалось получить настройки - не меняем поведение
		ТекстОшибки = ОписаниеОшибки();
	КонецПопытки;
	
	// Фиксируем старт выполнения DSL
	ОбновитьСтатусDSLВПоследнемСообщении(СсылкаДиалога, Перечисления.ИИА_СтатусDSL.Выполняется);
	
	// Создаем контекст выполнения для шагов
	КонтекстВыполнения = Новый Структура;
	КонтекстВыполнения.Вставить("СсылкаДиалога", СсылкаДиалога);
	
	РезультатDSL = ИИА_DSL.ВыполнитьDSL(DSLJSON, СсылкаДиалога, ТолькоЧтение);
	
	// Если был RunQuery - сохраняем данные запроса в хранилище диалога (для показа таблицы на клиенте)
	Если РезультатDSL <> Неопределено И РезультатDSL.Успех
		И РезультатDSL.Свойство("ДанныеЗапросаДляТаблицы")
		И РезультатDSL.ДанныеЗапросаДляТаблицы <> Неопределено Тогда
		
		УстановитьДанныеЗапросаВХранилище(СсылкаДиалога, РезультатDSL.ДанныеЗапросаДляТаблицы);
		
	КонецЕсли;
	
	// Добавляем структурированный системный результат DSL (dsl_system_result) для оркестратора/логов
	Если РезультатDSL.Свойство("СистемныйОтвет") И НЕ ПустаяСтрока(РезультатDSL.СистемныйОтвет) Тогда
		ДобавитьСообщениеВДиалог(
			СсылкаДиалога,
			Перечисления.ИИА_АвторСообщения.Система,
			Перечисления.ИИА_ТипСообщения.Текст,
			СокрЛП(РезультатDSL.СистемныйОтвет),
			"",
			"",
			0
		);
	КонецЕсли;
	
	Если РезультатDSL.Успех Тогда
		
		ОбновитьСтатусDSLВПоследнемСообщении(СсылкаДиалога, Перечисления.ИИА_СтатусDSL.ОбработанУспешно);
		
		// Добавляем системное сообщение об успешном выполнении
		ТекстСистемногоСообщения = "DSL-сценарий выполнен успешно.";
		
		// Обрабатываем результаты шагов
		Если РезультатDSL.Результаты.Количество() > 0 Тогда
			Для Каждого РезультатШага Из РезультатDSL.Результаты Цикл
				// Если это результат ShowInfo, выводим его как отдельное сообщение от ИИ
				Если РезультатШага.Свойство("ТипДействия") И РезультатШага.ТипДействия = "ShowInfo" И 
				   НЕ ПустаяСтрока(РезультатШага.Сообщение) Тогда
					ДобавитьСообщениеВДиалог(
						СсылкаДиалога,
						Перечисления.ИИА_АвторСообщения.ИИ,
						Перечисления.ИИА_ТипСообщения.Текст,
						РезультатШага.Сообщение,
						"",
						"",
						0
					);
					// Если есть результат запроса, сохраняем данные для создания табличного документа на клиенте
					Если РезультатШага.Свойство("ЕстьРезультатЗапроса") И РезультатШага.ЕстьРезультатЗапроса Тогда
						РезультатDSL.Вставить("ОткрытьТабличныйДокумент", Истина);
						// Ищем данные запроса в результате DSL (они сохраняются при выполнении RunQuery)
						Если РезультатDSL.Свойство("ДанныеЗапросаДляТаблицы") Тогда
							РезультатDSL.Вставить("ДанныеЗапроса", РезультатDSL.ДанныеЗапросаДляТаблицы);
						КонецЕсли;
					КонецЕсли;
				ИначеЕсли РезультатШага.Свойство("ТипДействия") И РезультатШага.ТипДействия = "RunQuery" И
				   РезультатШага.Свойство("ЕстьРезультатЗапроса") И РезультатШага.ЕстьРезультатЗапроса Тогда
					// Если это RunQuery с данными, устанавливаем флаги для открытия табличного документа
					РезультатDSL.Вставить("ОткрытьТабличныйДокумент", Истина);
					Если РезультатDSL.Свойство("ДанныеЗапросаДляТаблицы") Тогда
						РезультатDSL.Вставить("ДанныеЗапроса", РезультатDSL.ДанныеЗапросаДляТаблицы);
					КонецЕсли;
				Иначе
					// Обычный результат шага - добавляем в системное сообщение
					ТекстСистемногоСообщения = ТекстСистемногоСообщения + Символы.ПС + "- " + РезультатШага.Сообщение;
					
					// АВТО-ПОДСКАЗКА СЛЕДУЮЩЕГО ШАГА (Discovery Push)
					Если РезультатШага.Свойство("ТипДействия") И РезультатШага.ТипДействия = "GetMetadata" Тогда
						Если РезультатШага.Свойство("Данные") И ТипЗнч(РезультатШага.Данные) = Тип("Структура") Тогда
							// Ищем документы в результате
							Если РезультатШага.Данные.Свойство("Документы") Тогда
								МассивДокументов = РезультатШага.Данные.Документы;
								Если МассивДокументов.Количество() > 0 И МассивДокументов.Количество() <= 5 Тогда
									// Если документов мало, принудительно советуем первый
									ЛучшийКандидат = МассивДокументов[0].Имя;
									ТекстСистемногоСообщения = ТекстСистемногоСообщения + Символы.ПС + 
									"!!! ВНИМАНИЕ: Твой следующий шаг ОБЯЗАН быть GetObjectFields для Документ." + ЛучшийКандидат + " !!!";
									
									// АВТОПИЛОТ: Сразу выполняем GetObjectFields для лучшего кандидата
									ШагАвтопилота = Новый Структура("action,object_type,object_name", "GetObjectFields", "Документ", ЛучшийКандидат);
									РезультатАвтопилота = ИИА_DSL.ВыполнитьШаг(ШагАвтопилота, КонтекстВыполнения);
									
									Если РезультатАвтопилота.Успех Тогда
										ТекстСистемногоСообщения = ТекстСистемногоСообщения + Символы.ПС + 
										"ИНФО: Я уже выполнил GetObjectFields за тебя. Вот реквизиты объекта '" + ЛучшийКандидат + "':";
										
										ДанныеОбъекта = РезультатАвтопилота.Данные;
										Если ТипЗнч(ДанныеОбъекта) = Тип("Структура") И ДанныеОбъекта.Свойство("Реквизиты") Тогда
											Для Каждого Реквизит Из ДанныеОбъекта.Реквизиты Цикл
												ТекстСистемногоСообщения = ТекстСистемногоСообщения + Символы.ПС + "  - " + Реквизит.Имя + " (" + Реквизит.Синоним + ")";
											КонецЦикла;
										КонецЕсли;
										
										ТекстСистемногоСообщения = ТекстСистемногоСообщения + Символы.ПС + 
										"ТЕПЕРЬ ВЫПОЛНИ RunQuery К ЭТОМУ ОБЪЕКТУ!";
									КонецЕсли;
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
					
					// Если это GetObjectFields, добавляем детальную информацию о реквизитах
					Если РезультатШага.Свойство("ТипДействия") И РезультатШага.ТипДействия = "GetObjectFields" 
						И РезультатШага.Свойство("Данные") И РезультатШага.Данные <> Неопределено Тогда
						
						ДанныеОбъекта = РезультатШага.Данные;
						Если ТипЗнч(ДанныеОбъекта) = Тип("Структура") И ДанныеОбъекта.Свойство("Реквизиты") Тогда
							МассивРеквизитов = ДанныеОбъекта.Реквизиты;
							Если ТипЗнч(МассивРеквизитов) = Тип("Массив") И МассивРеквизитов.Количество() > 0 Тогда
								ТекстСистемногоСообщения = ТекстСистемногоСообщения + Символы.ПС + "Реквизиты:";
								Для Каждого Реквизит Из МассивРеквизитов Цикл
									Если ТипЗнч(Реквизит) = Тип("Структура") И Реквизит.Свойство("Имя") Тогда
										ИмяРеквизита = Реквизит.Имя;
										Если Реквизит.Свойство("Синоним") И НЕ ПустаяСтрока(Реквизит.Синоним) Тогда
											ИмяРеквизита = ИмяРеквизита + " (" + Реквизит.Синоним + ")";
										КонецЕсли;
										ТекстСистемногоСообщения = ТекстСистемногоСообщения + Символы.ПС + "  - " + ИмяРеквизита;
									КонецЕсли;
								КонецЦикла;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		ДобавитьСообщениеВДиалог(
			СсылкаДиалога,
			Перечисления.ИИА_АвторСообщения.Система,
			Перечисления.ИИА_ТипСообщения.Текст,
			ТекстСистемногоСообщения,
			"",
			"",
			0
		);
		
		// Добавляем системное сообщение со ссылками на созданные/измененные объекты
		Если РезультатDSL.Свойство("СсылкиОбъектов") Тогда
			МассивСсылок = РезультатDSL.СсылкиОбъектов;
			Если МассивСсылок.Количество() > 0 Тогда
				Попытка
					
					// Сохраняем ссылки в табличную часть ИзмененныеОбъекты
					ДобавитьИзмененныеОбъекты(СсылкаДиалога, МассивСсылок);
					
					// Формируем текст с детальной информацией
					ТекстСсылок = "Создано/изменено объектов: " + Формат(МассивСсылок.Количество(), "ЧН=0") + Символы.ПС;
					ТекстСсылок = ТекстСсылок + ПолучитьДанныеСозданныхОбъектов(МассивСсылок);
					
					ДобавитьСообщениеВДиалог(
						СсылкаДиалога,
						Перечисления.ИИА_АвторСообщения.Система,
						Перечисления.ИИА_ТипСообщения.Текст,
						ТекстСсылок,
						"",
						"",
						0
					);
					
				Исключение
					// Если не удалось добавить ссылки, добавляем сообщение об ошибке для отладки
					ДобавитьСообщениеВДиалог(
						СсылкаДиалога,
						Перечисления.ИИА_АвторСообщения.Система,
						Перечисления.ИИА_ТипСообщения.Ошибка,
						"Ошибка при формировании сообщения со ссылками: " + ОписаниеОшибки(),
						"",
						"",
						0
					);
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
		
	Иначе
		
		ОбновитьСтатусDSLВПоследнемСообщении(СсылкаДиалога, Перечисления.ИИА_СтатусDSL.ОбработанСОшибкой);
		
		// Добавляем системное сообщение об ошибке
		ТекстОшибки = "Ошибка выполнения DSL: " + РезультатDSL.Сообщение;
		
		// Если ошибка в режиме Запрос1С связана с выполнением запроса, добавляем справку
		Если ТолькоЧтение И (СтрНайти(ТекстОшибки, "RunQuery") > 0 ИЛИ СтрНайти(ТекстОшибки, "Запрос") > 0) Тогда
			
			// Если ошибка "Поле не найдено", советуем получить метаданные
			Если СтрНайти(ТекстОшибки, "Поле не найдено") > 0 Тогда
				ТекстСправки = "СОВЕТ: Система не нашла указанное поле. Возможно, ты используешь неверное имя (синоним вместо имени). " +
				"Рекомендуется сначала выполнить действие GetObjectFields для этой таблицы, чтобы узнать точные имена полей.";
			Иначе
				// Релевантный фрагмент справки по типу ошибки (вместо полной ~400 строк)
				ТекстСправки = "ВНИМАНИЕ! Обнаружена ошибка выполнения запроса 1С. " + Символы.ПС +
				"Используйте эту справочную информацию для исправления запроса:" + Символы.ПС + Символы.ПС +
				ПолучитьСправкуЗапросовПоОшибке(ТекстОшибки);
			КонецЕсли;
			
			ДобавитьСообщениеВДиалог(
				СсылкаДиалога,
				Перечисления.ИИА_АвторСообщения.Система,
				Перечисления.ИИА_ТипСообщения.Текст,
				ТекстСправки,
				"",
				"",
				0
			);
			
		КонецЕсли;
		
		ДобавитьСообщениеВДиалог(
			СсылкаДиалога,
			Перечисления.ИИА_АвторСообщения.Система,
			Перечисления.ИИА_ТипСообщения.Ошибка,
			ТекстОшибки,
			"",
			"",
			0
		);
		
	КонецЕсли;
	
	Возврат РезультатDSL;
	
КонецФункции

// Генерирует summary (резюме) выполненной работы через ИИ
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Строка - текст summary или пустая строка при ошибке
//
// Функции резюме и проверки перенесены в ИИА_Оркестратор



// Извлекает роль (категорию) из префикса записи лога вида "[РОЛЬ] текст".
//
// Параметры:
//  ТекстЗаписи - Строка - строка лога
//
// Возвращаемое значение:
//  Строка - содержимое в квадратных скобках или пустая строка
//
Функция ИзвлечьРольИзТекстаЛога(ТекстЗаписи)
	Если ПустаяСтрока(ТекстЗаписи) Тогда
		Возврат "";
	КонецЕсли;
	ПозОткрытия = Найти(ТекстЗаписи, "[");
	Если ПозОткрытия = 0 Тогда
		Возврат "";
	КонецЕсли;
	ПозЗакрытия = Найти(Сред(ТекстЗаписи, ПозОткрытия), "]");
	Если ПозЗакрытия = 0 Тогда
		Возврат "";
	КонецЕсли;
	// Длина содержимого в скобках: от "[" до "]" не включая их
	Роль = Сред(ТекстЗаписи, ПозОткрытия + 1, ПозЗакрытия - 2);
	Возврат Лев(СокрЛП(Роль), 50);
КонецФункции

// Убирает префикс [Роль] из начала текста (роль хранится в отдельном поле регистра).
//
Функция УбратьПрефиксРолиИзТекстаЛога(ТекстЗаписи, Роль)
	Если ПустаяСтрока(ТекстЗаписи) Тогда
		Возврат "";
	КонецЕсли;
	ПозОткрытия = Найти(ТекстЗаписи, "[");
	Если ПозОткрытия <> 1 Тогда
		Возврат ТекстЗаписи;
	КонецЕсли;
	ПозЗакрытия = Найти(Сред(ТекстЗаписи, 2), "]");
	Если ПозЗакрытия = 0 Тогда
		Возврат ТекстЗаписи;
	КонецЕсли;
	ПозКонецСкобки = 1 + ПозЗакрытия;
	Остаток = СокрЛП(Сред(ТекстЗаписи, ПозКонецСкобки + 1));
	Если СтрНачинаетсяС(Остаток, " ") Тогда
		Остаток = СокрЛП(Сред(Остаток, 2));
	КонецЕсли;
	Возврат Остаток;
КонецФункции

// Возвращает содержимое последней записи лога для диалога (без префикса [timestamp]).
// Используется для подавления дубликатов dsl_system_result.
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Строка - содержимое последней записи или пустая строка
//
Функция ПолучитьСодержимоеПоследнейЗаписиЛога(СсылкаДиалога)
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИИА_Логи.Лог КАК Лог
	|ИЗ
	|	РегистрСведений.ИИА_Логи КАК ИИА_Логи
	|ГДЕ
	|	ИИА_Логи.Диалог = &Ссылка
	|УПОРЯДОЧИТЬ ПО
	|	ИИА_Логи.Дата УБЫВ";
	Запрос.УстановитьПараметр("Ссылка", СсылкаДиалога);
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат "";
	КонецЕсли;
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	ЛогСтрока = Выборка.Лог;
	// Убираем префикс [yyyyMMddHHmmss] 
	Поз = Найти(ЛогСтрока, "] ");
	Если Поз > 0 Тогда
		Возврат СокрЛП(Сред(ЛогСтрока, Поз + 2));
	КонецЕсли;
	Возврат ЛогСтрока;
КонецФункции

// Форматирует DSL или dsl_system_result компактно для лога (одна строка).
//
Функция ФорматироватьКомпактноДляЛога(Текст) Экспорт
	Если ПустаяСтрока(Текст) Тогда
		Возврат "";
	КонецЕсли;
	ТекстВРег = ВРег(Текст);
	Если СтрНайти(ТекстВРег, "DSL_SYSTEM_RESULT") > 0 Тогда
		// Результат: "DSL Result: ok | RunQuery: сообщение"
		Успех = (СтрНайти(ТекстВРег, """SUCCESS"":TRUE") > 0 ИЛИ СтрНайти(ТекстВРег, """SUCCESS"": TRUE") > 0)
			И СтрНайти(ТекстВРег, """SUCCESS"":FALSE") = 0;
		Статус = ?(Успех, "ok", "err");
		ПозОшибки = СтрНайти(ТекстВРег, """ERROR"":");
		Если НЕ Успех И ПозОшибки > 0 Тогда
			Начало = ПозОшибки + 9;
			Конец = СтрНайти(Сред(Текст, Начало), """");
			Сообщение = ?(Конец > 0, СтрЗаменить(Сред(Текст, Начало, Конец - 1), Символы.ПС, " "), "");
			Возврат "DSL Result: " + Статус + " | " + Лев(Сообщение, 120);
		КонецЕсли;
		ПозAction = СтрНайти(ТекстВРег, """ACTION"":");
		ПозMessage = СтрНайти(ТекстВРег, """MESSAGE"":");
		Действие = "";
		Сообщение = "";
		Если ПозAction > 0 Тогда
			ПослеКолонки = Сред(Текст, ПозAction + 9);
			ПозОткр = СтрНайти(ПослеКолонки, """");
			Если ПозОткр > 0 Тогда
				Внутри = Сред(ПослеКолонки, ПозОткр + 1);
				ПозЗакр = СтрНайти(Внутри, """");
				Если ПозЗакр > 0 Тогда Действие = Сред(Внутри, 1, ПозЗакр - 1); КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если ПозMessage > 0 Тогда
			ПослеКолонки = Сред(Текст, ПозMessage + 10);
			ПозОткр = СтрНайти(ПослеКолонки, """");
			Если ПозОткр > 0 Тогда
				Внутри = Сред(ПослеКолонки, ПозОткр + 1);
				ПозЗакр = СтрНайти(Внутри, """");
				Если ПозЗакр > 0 Тогда Сообщение = СтрЗаменить(Сред(Внутри, 1, ПозЗакр - 1), Символы.ПС, " "); КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		// Для GetMetadata и GetObjectFields нужен полный список объектов — ИИ не должен видеть обрезанные имена
		ЛимитСообщения = ?(Действие = "GetMetadata" ИЛИ Действие = "GetObjectFields", 600, 80);
		Возврат "DSL Result: " + Статус + " | " + Действие + ": " + Лев(Сообщение, ЛимитСообщения);
	КонецЕсли;
	Если СтрНайти(ТекстВРег, """DSL_VERSION""") > 0 И СтрНайти(ТекстВРег, """STEPS""") > 0 Тогда
		// DSL: "DSL: RunQuery | ВЫБРАТЬ..."
		ПозAction = СтрНайти(ТекстВРег, """ACTION"":");
		ПозQuery = СтрНайти(ТекстВРег, """QUERY"":");
		Действие = "";
		Запрос = "";
		Если ПозAction > 0 Тогда
			ПослеКолонки = Сред(Текст, ПозAction + 9);
			ПозОткр = СтрНайти(ПослеКолонки, """");
			Если ПозОткр > 0 Тогда
				Внутри = Сред(ПослеКолонки, ПозОткр + 1);
				ПозЗакр = СтрНайти(Внутри, """");
				Если ПозЗакр > 0 Тогда Действие = Сред(Внутри, 1, ПозЗакр - 1); КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если ПозQuery > 0 Тогда
			ПослеКолонки = Сред(Текст, ПозQuery + 8);
			ПозОткр = СтрНайти(ПослеКолонки, """");
			Если ПозОткр > 0 Тогда
				Внутри = Сред(ПослеКолонки, ПозОткр + 1);
				ПозЗакр = СтрНайти(Внутри, """");
				Если ПозЗакр > 0 Тогда
					Запрос = СтрЗаменить(Сред(Внутри, 1, ПозЗакр - 1), Символы.ПС, " ");
					Запрос = Лев(Запрос, 100);
					Если СтрДлина(Запрос) = 100 Тогда Запрос = Запрос + "..."; КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Возврат "DSL: " + Действие + ?(ПустаяСтрока(Запрос), "", " | " + Запрос);
	КонецЕсли;
	// План (JSON массив объектов {Задача, Выполнена, Результат}) - компактно с меткой [ПЛАН]
	Обрезанный = СокрЛП(Текст);
	Если СтрДлина(Обрезанный) > 2 И Лев(Обрезанный, 1) = "[" 
		И (СтрНайти(ТекстВРег, """ЗАДАЧА""") > 0 ИЛИ СтрНайти(ТекстВРег, """ВЫПОЛНЕНА""") > 0) Тогда
		Возврат "[ПЛАН] " + СжатьJSONВСтроку(Текст);
	КонецЕсли;
	Возврат Текст;
КонецФункции

// Сжимает JSON (план, массив и т.д.) в одну строку для лога.
Функция СжатьJSONВСтроку(Текст) Экспорт
	Если ПустаяСтрока(Текст) Тогда Возврат ""; КонецЕсли;
	Результат = СтрЗаменить(Текст, Символы.ПС, " ");
	Результат = СтрЗаменить(Результат, Символы.ВК, " ");
	Результат = СтрЗаменить(Результат, Символы.ВТаб, " ");
	Пока СтрНайти(Результат, "  ") > 0 Цикл
		Результат = СтрЗаменить(Результат, "  ", " ");
	КонецЦикла;
	Возврат СокрЛП(Результат);
КонецФункции

// Извлекает ключевую часть записи для сравнения (JSON от первой "{" до "\n---").
// Используется для обнаружения дубликатов dsl_system_result.
//
Функция ИзвлечьКлючевоеСодержимоеДляСравнения(ТекстЗаписи)
	ПозНачала = СтрНайти(ТекстЗаписи, "{");
	ПозКонца = СтрНайти(ТекстЗаписи, Символы.ПС + "---");
	Если ПозНачала = 0 Тогда
		Возврат СокрЛП(ТекстЗаписи);
	КонецЕсли;
	Если ПозКонца = 0 Тогда
		ПозКонца = СтрДлина(ТекстЗаписи) + 1;
	КонецЕсли;
	Ключ = Сред(ТекстЗаписи, ПозНачала, ПозКонца - ПозНачала);
	Возврат СокрЛП(Ключ);
КонецФункции

// Добавляет запись в лог диалога (каждая запись - отдельная строка регистра).
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  ЗаписьЛога - Строка - текст записи для добавления
//  Роль - Строка - категория записи (если пусто, извлекается из префикса [XXX] в ЗаписьЛога)
//  CallId - Строка - идентификатор вызова ИИ для связи записей (пусто для не-LLM записей)
//
Процедура ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, ЗаписьЛога, Роль = "", CallId = "", УИДЗаписи = "") Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если СсылкаДиалога = Неопределено 
		ИЛИ ТипЗнч(СсылкаДиалога) <> Тип("СправочникСсылка.ИИА_Диалоги")
		ИЛИ СсылкаДиалога.Пустая() Тогда
		Возврат; 
	КонецЕсли;
	
	Если ПустаяСтрока(ЗаписьЛога) Тогда
		Возврат;
	КонецЕсли;
	
	// Подавление дубликатов: не логируем повторный dsl_system_result
	Если СтрНайти(ЗаписьЛога, "dsl_system_result") > 0 Тогда
		СодержимоеПоследнее = ПолучитьСодержимоеПоследнейЗаписиЛога(СсылкаДиалога);
		Если СтрНайти(СодержимоеПоследнее, "dsl_system_result") > 0 Тогда
			КлючНовый = ИзвлечьКлючевоеСодержимоеДляСравнения(ЗаписьЛога);
			КлючПоследний = ИзвлечьКлючевоеСодержимоеДляСравнения(СодержимоеПоследнее);
			Если НЕ ПустаяСтрока(КлючНовый) И КлючНовый = КлючПоследний Тогда
				Возврат;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	// Дата и Роль хранятся в отдельных полях регистра, в Лог не дублируем
	Если ПустаяСтрока(Роль) Тогда
		Роль = ИзвлечьРольИзТекстаЛога(ЗаписьЛога);
	КонецЕсли;
	Роль = Лев(Роль, 50);
	// Убираем префикс [Роль] из текста, чтобы не дублировать в Лог
	ТекстЗаписи = УбратьПрефиксРолиИзТекстаЛога(ЗаписьЛога, Роль);
	Если CallId <> Неопределено Тогда
		CallId = Лев(Строка(CallId), 36);
	Иначе
		CallId = "";
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(УИДЗаписи) Тогда
		УИДЗаписи = Лев(Строка(УИДЗаписи), 36);
	Иначе
		УИДЗаписи = Строка(Новый УникальныйИдентификатор());
	КонецЕсли;
	
	Попытка
		МенеджерЗаписи = РегистрыСведений.ИИА_Логи.СоздатьМенеджерЗаписи();
		МенеджерЗаписи.Диалог = СсылкаДиалога;
		МенеджерЗаписи.УИД = УИДЗаписи;
		МенеджерЗаписи.Роль = Роль;
		МенеджерЗаписи.CallId = CallId;
		МенеджерЗаписи.Дата = ТекущаяДатаСеанса();
		МенеджерЗаписи.Лог = ТекстЗаписи;
		МенеджерЗаписи.Записать();
	Исключение
		// Лог не должен ронять процесс
		ТекстОшибки = ОписаниеОшибки();
	КонецПопытки;
	
	// Экспорт в файл при отладке (если в настройках указан ПутьКЛогуОтладки)
	Попытка
		ДиалогОбъект = СсылкаДиалога.ПолучитьОбъект();
		ПараметрыПользователя = ПолучитьНастройкиПользователя(ДиалогОбъект.Пользователь);
		Если ПараметрыПользователя <> Неопределено
			И ПараметрыПользователя.Свойство("РежимОтладки") И ПараметрыПользователя.РежимОтладки
			И ПараметрыПользователя.Свойство("ПутьКЛогуОтладки") И ЗначениеЗаполнено(ПараметрыПользователя.ПутьКЛогуОтладки) Тогда
			// Параметры: ИмяФайла, Кодировка, РазделительСтрок, Дописывать (Истина = в конец файла)
			ЗаписьТекста = Новый ЗаписьТекста(ПараметрыПользователя.ПутьКЛогуОтладки, КодировкаТекста.UTF8, Символы.ПС, Истина);
			ЗаписьТекста.ЗаписатьСтроку(ТекстЗаписи);
			ЗаписьТекста.Закрыть();
		КонецЕсли;
	Исключение
		// Экспорт в файл не должен ронять процесс
		ТекстОшибки = ОписаниеОшибки();
	КонецПопытки;
	
КонецПроцедуры

// Очищает (затирает) файл лога отладки для диалога. Вызывать при запуске оркестратора.
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
Процедура ОчиститьФайлЛогаОтладки(СсылкаДиалога) Экспорт
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) Тогда
		Возврат;
	КонецЕсли;
	Попытка
		ДиалогОбъект = СсылкаДиалога.ПолучитьОбъект();
		ПараметрыПользователя = ПолучитьНастройкиПользователя(ДиалогОбъект.Пользователь);
		Если ПараметрыПользователя <> Неопределено
			И ПараметрыПользователя.Свойство("РежимОтладки") И ПараметрыПользователя.РежимОтладки
			И ПараметрыПользователя.Свойство("ПутьКЛогуОтладки") И ЗначениеЗаполнено(ПараметрыПользователя.ПутьКЛогуОтладки) Тогда
			// Дописывать = Ложь - перезапись (файл очищается)
			ЗаписьТекста = Новый ЗаписьТекста(ПараметрыПользователя.ПутьКЛогуОтладки, КодировкаТекста.UTF8, Символы.ПС, Ложь);
			ЗаписьТекста.Закрыть();
		КонецЕсли;
	Исключение
		ТекстОшибки = ОписаниеОшибки();
	КонецПопытки;
КонецПроцедуры

// Создает табличный документ из массива структур с данными запроса
//
// Параметры:
//  ДанныеЗапроса - Массив - массив структур с данными запроса
//
// Возвращаемое значение:
//  ТабличныйДокумент - созданный табличный документ
//
Функция СоздатьТабличныйДокументИзДанных(ДанныеЗапроса) Экспорт
	
	Если ДанныеЗапроса = Неопределено Или ТипЗнч(ДанныеЗапроса) <> Тип("Массив") Или ДанныеЗапроса.Количество() = 0 Тогда
		ВызватьИсключение "ДанныеЗапроса пусты или неверного типа";
	КонецЕсли;
	
	Попытка
		// Получаем структуру первой строки для определения колонок
		ПерваяСтрока = ДанныеЗапроса[0];
		Если ТипЗнч(ПерваяСтрока) <> Тип("Структура") Тогда
			ВызватьИсключение "Первая строка данных должна быть структурой";
		КонецЕсли;
		
		// Создаем таблицу значений для удобной работы с данными
		ТаблицаДанных = Новый ТаблицаЗначений;
		
		// Добавляем колонки на основе первой строки
		Для Каждого ПараКлючЗначение Из ПерваяСтрока Цикл
			ТаблицаДанных.Колонки.Добавить(ПараКлючЗначение.Ключ, Новый ОписаниеТипов("Строка"));
		КонецЦикла;
		
		// Заполняем таблицу значений данными
		Для Каждого СтрокаДанных Из ДанныеЗапроса Цикл
			Если ТипЗнч(СтрокаДанных) = Тип("Структура") Тогда
				НоваяСтрока = ТаблицаДанных.Добавить();
				Для Каждого ПараКлючЗначение Из ПерваяСтрока Цикл
					ИмяКолонки = ПараКлючЗначение.Ключ;
					Если СтрокаДанных.Свойство(ИмяКолонки) Тогда
						Значение = СтрокаДанных[ИмяКолонки];
						НоваяСтрока[ИмяКолонки] = Строка(Значение);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
		
		// Создаем табличный документ
		ТабличныйДокумент = Новый ТабличныйДокумент;
		
		// Используем ПостроительОтчета для вывода таблицы значений
		Построитель = Новый ПостроительОтчета;
		Построитель.ИсточникДанных = Новый ОписаниеИсточникаДанных(ТаблицаДанных);
		Построитель.Вывести(ТабличныйДокумент);
		
		Возврат ТабличныйДокумент;
		
	Исключение
		ВызватьИсключение "Ошибка при создании табличного документа: " + ОписаниеОшибки();
	КонецПопытки;
	
КонецФункции

// Устанавливает флаг отображения табличного документа в хранилище диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  Значение - Булево - значение флага
//
Процедура УстановитьФлагТаблицыВХранилище(СсылкаДиалога, Значение) Экспорт
	
	Попытка
		СтруктураДанных = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
		Если СтруктураДанных = Неопределено ИЛИ ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
			СтруктураДанных = Новый Структура;
		КонецЕсли;
		
		Если СтруктураДанных.Свойство("ТаблицаПоказана") Тогда
			Если СтруктураДанных.ТаблицаПоказана = Значение Тогда
				ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "ТабличныйДокумент: флаг ТаблицаПоказана уже установлен=" + ?(Значение, "Истина", "Ложь"));
				Возврат;
			КонецЕсли;
		КонецЕсли;
		
		СтруктураДанных.Вставить("ТаблицаПоказана", Значение);
		ЗаписатьДанныеДиалогаВРегистр(СсылкаДиалога, СтруктураДанных);
		ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "ТабличныйДокумент: установлен флаг ТаблицаПоказана=" + ?(Значение, "Истина", "Ложь"));
	Исключение
		ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "Ошибка при установке флага ТаблицаПоказана (пропуск): " + ОписаниеОшибки());
	КонецПопытки;
	
КонецПроцедуры

// Устанавливает (перезаписывает) последние данные запроса в хранилище диалога.
// Используется для гарантированного показа ТабличногоДокумента в режиме "Запрос1С" в конце оркестратора.
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  ДанныеЗапроса - Массив - массив структур (строки результата RunQuery)
//
Процедура УстановитьДанныеЗапросаВХранилище(СсылкаДиалога, ДанныеЗапроса)
	
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) Тогда
		Возврат;
	КонецЕсли;
	
	Если ДанныеЗапроса = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Попытка
		СтруктураДанных = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
		Если СтруктураДанных = Неопределено ИЛИ ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
			СтруктураДанных = Новый Структура;
		КонецЕсли;
		
		СтруктураДанных.Вставить("ПоследниеДанныеЗапроса", ДанныеЗапроса);
		СтруктураДанных.Вставить("ТаблицаПоказана", Ложь);
		
		ЗаписатьДанныеДиалогаВРегистр(СсылкаДиалога, СтруктураДанных);
	Исключение
		ВызватьИсключение "Ошибка при записи данных запроса в хранилище: " + ОписаниеОшибки();
	КонецПопытки;
	
	// Диагностический лог (без вывода самих строк)
	КоличествоСтрок = ?(ТипЗнч(ДанныеЗапроса) = Тип("Массив"), ДанныеЗапроса.Количество(), 0);
	КоличествоКолонок = 0;
	СписокКолонок = "";
	Если КоличествоСтрок > 0 Тогда
		ПерваяСтрока = ДанныеЗапроса[0];
		Если ТипЗнч(ПерваяСтрока) = Тип("Структура") Тогда
			КоличествоКолонок = ПерваяСтрока.Количество();
			Осталось = 10;
			Для Каждого Пара Из ПерваяСтрока Цикл
				Если Осталось <= 0 Тогда
					Прервать;
				КонецЕсли;
				Если ПустаяСтрока(СписокКолонок) Тогда
					СписокКолонок = Пара.Ключ;
				Иначе
					СписокКолонок = СписокКолонок + ", " + Пара.Ключ;
				КонецЕсли;
				Осталось = Осталось - 1;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	ДобавитьЗаписьВЛогДиалога(
		СсылкаДиалога,
		"RunQuery: сохранены данные запроса в хранилище (строк=" + Формат(КоличествоСтрок, "ЧН=0") 
			+ ", колонок=" + Формат(КоличествоКолонок, "ЧН=0") 
			+ ", колонки(до10)=""" + СписокКолонок + """)"
	);
	
КонецПроцедуры

// Возвращает последние данные запроса, если таблица ещё не была показана на клиенте.
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Массив или Неопределено
//
Функция ПолучитьНепоказанныеДанныеЗапроса(СсылкаДиалога) Экспорт
	
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		СтруктураДанных = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
	Исключение
		ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "Ошибка чтения данных диалога для показа таблицы: " + ОписаниеОшибки());
		Возврат Неопределено;
	КонецПопытки;
	
	Если СтруктураДанных = Неопределено ИЛИ ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если СтруктураДанных.Свойство("ТаблицаПоказана") И СтруктураДанных.ТаблицаПоказана Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если СтруктураДанных.Свойство("ПоследниеДанныеЗапроса")
		И СтруктураДанных.ПоследниеДанныеЗапроса <> Неопределено
		И ТипЗнч(СтруктураДанных.ПоследниеДанныеЗапроса) = Тип("Массив")
		И СтруктураДанных.ПоследниеДанныеЗапроса.Количество() > 0 Тогда
		
		Возврат СтруктураДанных.ПоследниеДанныеЗапроса;
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Сохраняет лог в справочник ИИА_Диалоги
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  ТекстЛога - Строка - текст лога для сохранения
//
Процедура СохранитьЛогДиалога(СсылкаДиалога, ТекстЛога) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ПустаяСтрока(ТекстЛога) Тогда
		Возврат;
	КонецЕсли;
	
	ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "[LOG_SNAPSHOT] " + ТекстЛога);
	
КонецПроцедуры

// Получает лог из справочника ИИА_Диалоги
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Строка - текст лога
//
Функция ПолучитьЛогДиалога(СсылкаДиалога) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ИИА_Логи.Лог КАК Лог
	|ИЗ
	|	РегистрСведений.ИИА_Логи КАК ИИА_Логи
	|ГДЕ
	|	ИИА_Логи.Диалог = &Ссылка
	|УПОРЯДОЧИТЬ ПО
	|	ИИА_Логи.Дата";
	
	Запрос.УстановитьПараметр("Ссылка", СсылкаДиалога);
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат "";
	КонецЕсли;
	
	Части = Новый Массив;
	Выборка = РезультатЗапроса.Выбрать();
	Пока Выборка.Следующий() Цикл
		Части.Добавить(Выборка.Лог);
	КонецЦикла;
	Возврат СтрСоединить(Части, Символы.ПС);
	
КонецФункции


// Сбрасывает результат проверки задачи в хранилище диалога (устанавливает ПроверкаВыполнена = Ложь)
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
//
Процедура СброситьРезультатПроверкиВХранилище(СсылкаДиалога) Экспорт
	
	СтруктураПроверки = ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
	Если СтруктураПроверки = Неопределено ИЛИ ТипЗнч(СтруктураПроверки) <> Тип("Структура") Тогда
		СтруктураПроверки = Новый Структура;
	КонецЕсли;
	
	СтруктураПроверки.Вставить("ПроверкаВыполнена", Ложь);
	СтруктураПроверки.Вставить("СтатусПроверкиЗадачи", "");
	СтруктураПроверки.Вставить("ПричинаПроверки", "");
	СтруктураПроверки.Вставить("ТаблицаПоказана", Ложь);
	
	ЗаписатьДанныеДиалогаВРегистр(СсылкаДиалога, СтруктураПроверки);
	
КонецПроцедуры

// Проверяет DSL сценарий
//
// Параметры:
//  DSLJSON - Строка - JSON с DSL командами
//
// Возвращаемое значение:
//  Структура - структура результата проверки DSL
//
Функция ПроверитьDSLСценарий(DSLJSON) Экспорт
	
	Возврат ИИА_DSL.ПроверитьDSL(DSLJSON);
	
КонецФункции

// Получает данные созданных объектов (реквизиты)
//
// Параметры:
//  МассивСсылок - Массив - массив ссылок на созданные объекты
//
// Возвращаемое значение:
//  Строка - текстовое описание реквизитов объектов
//
Функция ПолучитьДанныеСозданныхОбъектов(МассивСсылок)
	
	ТекстДанных = "";
	
	Если МассивСсылок.Количество() = 0 Тогда
		Возврат ТекстДанных;
	КонецЕсли;
	
	Для Каждого СсылкаОбъекта Из МассивСсылок Цикл
		
		Попытка
			
			// Получаем объект по ссылке
			Объект = СсылкаОбъекта.ПолучитьОбъект();
			
			Если Объект = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			// Определяем тип объекта
			ТипСсылки = ТипЗнч(СсылкаОбъекта);
			ИмяТипа = Строка(ТипСсылки);
			
			ТекстДанных = ТекстДанных + "Объект: " + СсылкаОбъекта + Символы.ПС;
			ТекстДанных = ТекстДанных + "Тип: " + ИмяТипа + Символы.ПС;
			
			// Получаем метаданные объекта
			Если Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
				
				МетаданныеОбъекта = СсылкаОбъекта.Метаданные();
				ТекстДанных = ТекстДанных + "Справочник: " + МетаданныеОбъекта.Имя + " (" + МетаданныеОбъекта.Синоним + ")" + Символы.ПС;
				
				// Получаем реквизиты справочника
				Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
					
					Попытка
						ЗначениеРеквизита = Объект[Реквизит.Имя];
						ТекстЗначения = "";
						
						Если ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
							Если ТипЗнч(ЗначениеРеквизита) = Тип("Строка") Тогда
								ТекстЗначения = ЗначениеРеквизита;
							ИначеЕсли ТипЗнч(ЗначениеРеквизита) = Тип("Число") Тогда
								ТекстЗначения = Формат(ЗначениеРеквизита, "ЧГ=");
							ИначеЕсли ТипЗнч(ЗначениеРеквизита) = Тип("Дата") Тогда
								ТекстЗначения = Формат(ЗначениеРеквизита, "ДФ=dd.MM.yyyy HH:mm:ss");
							ИначеЕсли ТипЗнч(ЗначениеРеквизита) = Тип("Булево") Тогда
								Если ЗначениеРеквизита Тогда
									ТекстЗначения = "Истина";
								Иначе
									ТекстЗначения = "Ложь";
								КонецЕсли;
							Иначе
								ТекстЗначения = Строка(ЗначениеРеквизита);
							КонецЕсли;
							
							ТекстДанных = ТекстДанных + "  " + Реквизит.Синоним + " (" + Реквизит.Имя + "): " + ТекстЗначения + Символы.ПС;
						КонецЕсли;
						
					Исключение
						// Игнорируем ошибки получения реквизита
						ТекстОшибки = ОписаниеОшибки();
					КонецПопытки;
					
				КонецЦикла;
				
			ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
				
				МетаданныеОбъекта = СсылкаОбъекта.Метаданные();
				ТекстДанных = ТекстДанных + "Документ: " + МетаданныеОбъекта.Имя + " (" + МетаданныеОбъекта.Синоним + ")" + Символы.ПС;
				
				// Получаем реквизиты документа
				Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
					
					Попытка
						ЗначениеРеквизита = Объект[Реквизит.Имя];
						ТекстЗначения = "";
						
						Если ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
							Если ТипЗнч(ЗначениеРеквизита) = Тип("Строка") Тогда
								ТекстЗначения = ЗначениеРеквизита;
							ИначеЕсли ТипЗнч(ЗначениеРеквизита) = Тип("Число") Тогда
								ТекстЗначения = Формат(ЗначениеРеквизита, "ЧГ=");
							ИначеЕсли ТипЗнч(ЗначениеРеквизита) = Тип("Дата") Тогда
								ТекстЗначения = Формат(ЗначениеРеквизита, "ДФ=dd.MM.yyyy HH:mm:ss");
							ИначеЕсли ТипЗнч(ЗначениеРеквизита) = Тип("Булево") Тогда
								Если ЗначениеРеквизита Тогда
									ТекстЗначения = "Истина";
								Иначе
									ТекстЗначения = "Ложь";
								КонецЕсли;
							Иначе
								ТекстЗначения = Строка(ЗначениеРеквизита);
							КонецЕсли;
							
							ТекстДанных = ТекстДанных + "  " + Реквизит.Синоним + " (" + Реквизит.Имя + "): " + ТекстЗначения + Символы.ПС;
						КонецЕсли;
						
					Исключение
						// Игнорируем ошибки получения реквизита
						ТекстОшибки = ОписаниеОшибки();
					КонецПопытки;
					
				КонецЦикла;
				
			КонецЕсли;
			
			ТекстДанных = ТекстДанных + Символы.ПС;
			
		Исключение
			// Если не удалось получить данные объекта, просто добавляем ссылку
			ТекстДанных = ТекстДанных + "Объект: " + СсылкаОбъекта + " (не удалось получить данные)" + Символы.ПС + Символы.ПС;
		КонецПопытки;
		
	КонецЦикла;
	
	Возврат ТекстДанных;
	
КонецФункции

// Обновляет статус DSL в последнем сообщении диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  НовыйСтатус - ПеречислениеСсылка.ИИА_СтатусDSL - новый статус
//
Процедура ОбновитьСтатусDSLВПоследнемСообщении(СсылкаДиалога, НовыйСтатус) Экспорт
	
	ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "[Система] Обновление статуса DSL: " + Строка(НовыйСтатус));
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	Если Диалог.Сообщения.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	// Ищем последнее сообщение с DSL (тип Код или статус не пустой)
	Индекс = Диалог.Сообщения.Количество() - 1;
	Пока Индекс >= 0 Цикл
		
		СтрокаСообщения = Диалог.Сообщения[Индекс];
		
		Если СтрокаСообщения.ТипСообщения = Перечисления.ИИА_ТипСообщения.Код 
			ИЛИ ЗначениеЗаполнено(СтрокаСообщения.СтатусDSL) Тогда
			
			СтрокаСообщения.СтатусDSL = НовыйСтатус;
			Диалог.Записать();
			УведомитьОбОбновленииДиалога(СсылкаДиалога, "ОбновлениеСтатусаDSL");
			Прервать;
			
		КонецЕсли;
		
		Индекс = Индекс - 1;
		
	КонецЦикла;
	
КонецПроцедуры

// Функция ПолучитьПоследнийDslSystemResult перенесена в ИИА_Оркестратор
// Функция ПроверитьВыводДанныхЗапроса перенесена в ИИА_Оркестратор
// Функция ПроверитьРезультатВыполненияЗадачи перенесена в ИИА_Оркестратор


// Генерирует следующий шаг выполнения задачи, если она не завершена
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Булево - Истина, если был сгенерирован и отправлен запрос к ИИ
//
// Функция СгенерироватьПродолжениеВыполнения перенесена в ИИА_Оркестратор
// Примечание: кэш экстрактора сущностей не реализован - в общих модулях 1С запрещены переменные уровня модуля (Перем).
// Для кэширования потребуется РегистрСведений или атрибут в справочнике диалогов.

#КонецОбласти
