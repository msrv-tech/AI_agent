#Область ПрограммныйИнтерфейс

// Вызывает ИИ для получения ответа
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  ПараметрыИИ - Структура - настройки пользователя
//  СистемныйПромпт - Строка - (опционально) переопределение системного промпта
//  Температура - Число - (опционально) температура модели
//
// Возвращаемое значение:
//  Структура - структура ответа
//
Функция ВызватьИИ(ТипСообщения, ТекстПользователя, История, ПараметрыИИ, СистемныйПромпт = "", Температура = Неопределено) Экспорт
	
	// Режим холостого хода: при наличии MockОтвет возвращаем его без вызова API
	Если ПараметрыИИ.Свойство("MockОтвет") И ПараметрыИИ.MockОтвет <> Неопределено Тогда
		Возврат НормализоватьMockОтвет(ПараметрыИИ.MockОтвет);
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", "");
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	Результат.Вставить("Usage", Неопределено);
	Результат.Вставить("Ошибки", Неопределено);
	
	// Проверяем настройки подключения
	Если ПустаяСтрока(ПараметрыИИ.Provider_ApiKey) ИЛИ ПустаяСтрока(ПараметрыИИ.Provider_BaseUrl) Тогда
		
		// Hard DSL mode: это системная ошибка, а не «текстовый ответ»
		Результат.ТипОтвета = "Ошибка";
		Результат.Текст = "Не настроен API ключ или URL провайдера. Настройте подключение к ИИ провайдеру.";
		Возврат Результат;
		
	КонецЕсли;
	
	// Теперь у нас только OpenAI-совместимый провайдер (Gitsell или прямой OpenAI)
	Результат = ВызватьGitsellAiProxy(ТипСообщения, ТекстПользователя, История, ПараметрыИИ, СистемныйПромпт, Температура);
	
	Возврат Результат;
	
КонецФункции

// Публичный контракт провайдера LLM.
Функция ПолучитьКонтрактПровайдера() Экспорт
	Возврат Новый Структура("messages,tools,temperature,timeout", "required", "optional", "optional", "optional");
КонецФункции

Функция СформироватьОшибкуИнструмента(Код, Категория, Рекомендация, Детали = "") Экспорт
	ОшибкаИнструмента = Новый Структура;
	ОшибкаИнструмента.Вставить("code", Код);
	ОшибкаИнструмента.Вставить("category", Категория);
	ОшибкаИнструмента.Вставить("recommendation", Рекомендация);
	ОшибкаИнструмента.Вставить("details", Детали);
	Возврат ОшибкаИнструмента;
КонецФункции

// Унифицированный Tooling Layer для HTTP-вызовов с retry/timeout.
Функция ВыполнитьHTTPИнструмент(БазовыйДомен, URLПуть, Заголовки, JSONТело, Таймаут = 30, МаксПопыток = 3)
	Результат = Новый Структура("Успех,КодСостояния,Тело,Ошибка", Ложь, 0, "", Неопределено);
	
	Для ПопыткаНомер = 1 По МаксПопыток Цикл
		Попытка
			HTTPСоединение = Новый HTTPСоединение(БазовыйДомен, 443, , , , Таймаут, Новый ЗащищенноеСоединениеOpenSSL());
			HTTPЗапрос = Новый HTTPЗапрос(URLПуть, Заголовки);
			HTTPЗапрос.УстановитьТелоИзСтроки(JSONТело);
			Ответ = HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);
			Результат.КодСостояния = Ответ.КодСостояния;
			Результат.Тело = Ответ.ПолучитьТелоКакСтроку();
			
			Если Ответ.КодСостояния >= 200 И Ответ.КодСостояния < 300 Тогда
				Результат.Успех = Истина;
				Возврат Результат;
			КонецЕсли;
			
			Если Ответ.КодСостояния = 429 ИЛИ (Ответ.КодСостояния >= 500 И Ответ.КодСостояния <= 599) Тогда
				Если ПопыткаНомер < МаксПопыток Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
			Результат.Ошибка = СформироватьОшибкуИнструмента("http_error", "provider_http", "Проверьте API ключ/лимиты/доступность провайдера.", Результат.Тело);
			Возврат Результат;
			
		Исключение
			Если ПопыткаНомер < МаксПопыток Тогда
				Продолжить;
			КонецЕсли;
			Результат.Ошибка = СформироватьОшибкуИнструмента("connection_error", "network", "Проверьте сеть и URL провайдера.", ОписаниеОшибки());
			Возврат Результат;
		КонецПопытки;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Вызывает API Gitsell AI Proxy (OpenAI-compatible)
//
// Параметры:
//  ТипСообщения - Строка
//  ТекстПользователя - Строка
//  История - ТаблицаЗначений
//  ПараметрыИИ - Структура
//  СистемныйПромпт - Строка
//  Температура - Число - (опционально) температура модели
//
// Возвращаемое значение:
//  Структура - результат
//
Функция ВызватьGitsellAiProxy(ТипСообщения, ТекстПользователя, История, ПараметрыИИ, СистемныйПромпт = "", Температура = Неопределено)
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", "");
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	Результат.Вставить("Usage", Неопределено);
	Результат.Вставить("Ошибки", Неопределено);
	
	// URL
	URLИзНастроек = ПараметрыИИ.Provider_BaseUrl;
	Если ПустаяСтрока(URLИзНастроек) Тогда
		URLИзНастроек = "https://gitsell.ru/api/v1";
	КонецЕсли;
	
	// Убираем завершающий слеш
	Если Прав(URLИзНастроек, 1) = "/" Тогда
		URLИзНастроек = Лев(URLИзНастроек, СтрДлина(URLИзНастроек) - 1);
	КонецЕсли;
	
	URLПуть = "/chat/completions";
	
	// Если URL содержит полный путь, нужно распарсить
	// Упрощенно считаем, что в BaseUrl только домен и базовый путь API
	// Для HTTPСоединение нужен домен
	URLБезПротокола = СтрЗаменить(URLИзНастроек, "https://", "");
	URLБезПротокола = СтрЗаменить(URLБезПротокола, "http://", "");
	
	ПозицияСлеша = СтрНайти(URLБезПротокола, "/");
	Если ПозицияСлеша > 0 Тогда
		БазовыйДомен = Лев(URLБезПротокола, ПозицияСлеша - 1);
		БазовыйПуть = Сред(URLБезПротокола, ПозицияСлеша);
		URLПуть = БазовыйПуть + "/chat/completions";
	Иначе
		БазовыйДомен = URLБезПротокола;
		URLПуть = "/api/v1/chat/completions";
	КонецЕсли;
	
	Токен = ПараметрыИИ.Provider_ApiKey;
	Если ПустаяСтрока(Токен) Тогда
		Результат.ТипОтвета = "Ошибка";
		Результат.Текст = "Не указан API ключ (токен) для Gitsell AI Proxy";
		Возврат Результат;
	КонецЕсли;
	
	// Промпт
	ТипДиалога = Неопределено;
	Если ПараметрыИИ.Свойство("ТипДиалога") Тогда
		ТипДиалога = ПараметрыИИ.ТипДиалога;
	КонецЕсли;
	
	// Передаем СсылкаДиалога для логирования RAG, если она есть в параметрах
	СсылкаДиалога = Неопределено;
	Если ПараметрыИИ.Свойство("СсылкаДиалога") Тогда
		СсылкаДиалога = ПараметрыИИ.СсылкаДиалога;
	КонецЕсли;
	
	// Защита от бесконечной рекурсии RAG
	ИспользоватьRAG = Ложь;
	Если ПараметрыИИ.Свойство("ИспользоватьRAG") Тогда
		ИспользоватьRAG = ПараметрыИИ.ИспользоватьRAG;
	КонецЕсли;
	
	Промпт = ИИА_Промты.СформироватьПромпт(ТипДиалога, ТипСообщения, ТекстПользователя, История, СистемныйПромпт, СсылкаДиалога, ИспользоватьRAG);
	
	// Логирование промпта
	ТекстПромпта = "";
	Для Каждого Сообщение Из Промпт.Сообщения Цикл
		Роль = ?(Сообщение.Свойство("role"), Сообщение.role, "");
		Содержимое = ?(Сообщение.Свойство("content"), Сообщение.content, "");
		ТекстПромпта = ТекстПромпта + "[" + Роль + "]" + Символы.ПС + Содержимое + Символы.ПС + Символы.ПС;
	КонецЦикла;
	Результат.Вставить("Промпт", ТекстПромпта);
	
	// Тело запроса
	ТелоЗапроса = Новый Структура;
	
	Модель = ?(ПараметрыИИ.Свойство("Модель") И НЕ ПустаяСтрока(ПараметрыИИ.Модель), ПараметрыИИ.Модель, "auto");
	
	ТелоЗапроса.Вставить("model", Модель);
	ТелоЗапроса.Вставить("messages", Промпт.Сообщения);
	
	// ТЕМПЕРАТУРА: Используем переданную или 0.0 по умолчанию
	ЗначениеТемпературы = ?(Температура = Неопределено, 0.0, Температура);
	ТелоЗапроса.Вставить("temperature", ЗначениеТемпературы);
	
	// ТелоЗапроса.Вставить("max_tokens", 4000); // Можно не ограничивать жестко
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, ТелоЗапроса);
	JSONТело = ЗаписьJSON.Закрыть();
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/json");
	Заголовки.Вставить("Accept", "application/json");
	Заголовки.Вставить("Authorization", "Bearer " + Токен);
	Если ПараметрыИИ.Свойство("trace_id") И НЕ ПустаяСтрока(Строка(ПараметрыИИ.trace_id)) Тогда
		Заголовки.Вставить("X-Trace-Id", Строка(ПараметрыИИ.trace_id));
	КонецЕсли;
	
	РезультатHTTP = ВыполнитьHTTPИнструмент(БазовыйДомен, URLПуть, Заголовки, JSONТело, 30, 3);
	
	Если РезультатHTTP.Успех Тогда
		
		ТекстОтвета = РезультатHTTP.Тело;
			
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ТекстОтвета);
			Данные = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			
			Если Данные.Свойство("choices") И Данные.choices.Количество() > 0 Тогда
				Choice = Данные.choices[0];
				Если Choice.Свойство("message") И Choice.message.Свойство("content") Тогда
					ТекстОтветаИИ = Choice.message.content;
					
					// Распознаем тип ответа (учитываем ожидаемый формат из настроек)
					РезультатРаспознавания = РаспознатьОтветИИ(ТекстОтветаИИ, ТипСообщения, ПараметрыИИ);
					
					Для Каждого КлючЗначение Из РезультатРаспознавания Цикл
						Результат.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
			
			// Usage
			Если Данные.Свойство("usage") Тогда
				UsageStruct = Новый Структура;
				Если Данные.usage.Свойство("gitsell_tokens") Тогда
					UsageStruct.Вставить("TotalTokens", Данные.usage.gitsell_tokens);
				Иначе
					UsageStruct.Вставить("TotalTokens", ?(Данные.usage.Свойство("total_tokens"), Данные.usage.total_tokens, 0));
				КонецЕсли;
				Результат.Usage = UsageStruct;
			КонецЕсли;
			
	Иначе
		Результат.ТипОтвета = "Ошибка";
		КодСостояния = РезультатHTTP.КодСостояния;
		Если КодСостояния = 401 Тогда
			Результат.Текст = "Ошибка 401: Требуется авторизация. Токен отозван или невалиден.";
		Иначе
			Результат.Текст = "Ошибка API (" + Строка(КодСостояния) + "): " + РезультатHTTP.Тело;
		КонецЕсли;
		Если РезультатHTTP.Ошибка <> Неопределено Тогда
			Результат.Ошибки = РезультатHTTP.Ошибка;
		Иначе
			Результат.Ошибки = РезультатHTTP.Тело;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Формирует промпт для ИИ с учетом контекста
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//
// Возвращаемое значение:
//  Структура - структура с сообщениями для ИИ
//
Функция СформироватьПромптДляИИ(ТипСообщения, ТекстПользователя, История) Экспорт
	
	// Функция перенесена в общий модуль ИИА_Промты
	// Оставлена для совместимости
	// Используем Агент как тип по умолчанию
	Возврат ИИА_Промты.СформироватьПромпт(Перечисления.ИИА_ТипДиалога.Агент, ТипСообщения, ТекстПользователя, История, "");
	
КонецФункции

// Извлекает DSL JSON из текста
//
// Параметры:
//  Текст - Строка - текст, из которого нужно извлечь JSON
//
// Возвращаемое значение:
//  Строка - извлеченный JSON или пустая строка, если не найден
//
Функция ИзвлечьDSLИзТекста(Текст) Экспорт
	
	Результат = "";
	
	// 1. Попытка найти блок кода JSON (```json ... ```)
	НачалоБлока = СтрНайти(Текст, "```json");
	Если НачалоБлока > 0 Тогда
		НачалоJSON = НачалоБлока + 7; // Длина "```json"
		
		// Ищем закрывающий блок, начиная с позиции после открывающего
		// Используем Сред для получения остатка строки и ищем в нем
		ОстатокТекста = Сред(Текст, НачалоJSON);
		КонецБлокаОтносительный = СтрНайти(ОстатокТекста, "```");
		
		Если КонецБлокаОтносительный = 0 Тогда
             // Если закрывающего блока нет, ищем до конца
             Результат = Сред(Текст, НачалоJSON);
        Иначе
             // Берем содержимое до закрывающего блока
             Результат = Лев(ОстатокТекста, КонецБлокаОтносительный - 1);
        КонецЕсли;
        
	Иначе
		// 2. Попытка найти просто блок кода (``` ... ```) и проверить, является ли он JSON
		НачалоБлока = СтрНайти(Текст, "```");
		Если НачалоБлока > 0 Тогда
			НачалоJSON = НачалоБлока + 3;
			
			ОстатокТекста = Сред(Текст, НачалоJSON);
			КонецБлокаОтносительный = СтрНайти(ОстатокТекста, "```");
			
			Если КонецБлокаОтносительный > 0 Тогда
				ПотенциальныйJSON = СокрЛП(Лев(ОстатокТекста, КонецБлокаОтносительный - 1));
				Если СтрНачинаетсяС(ПотенциальныйJSON, "{") Тогда
					Результат = ПотенциальныйJSON;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	// 3. Если не найдено в блоках, ищем просто JSON-объект в тексте (от первой { до последней })
	Если ПустаяСтрока(Результат) Тогда
		НачалоJSON = СтрНайти(Текст, "{");
		Если НачалоJSON > 0 Тогда
			
			// Ищем последнюю закрывающую скобку
			// Простой поиск с конца не работает корректно, если после JSON есть текст
			// Попробуем балансировку скобок
			
			СчетчикСкобок = 0;
			ВКавычках = Ложь;
			Для Позиция = НачалоJSON По СтрДлина(Текст) Цикл
				Символ = Сред(Текст, Позиция, 1);
				
				// Обработка кавычек для игнорирования скобок внутри строк
				Если Символ = """" Тогда
					// Проверяем, не экранирована ли кавычка (очень упрощенно)
					Если Позиция > 1 И Сред(Текст, Позиция - 1, 1) <> "\" Тогда
						ВКавычках = НЕ ВКавычках;
					КонецЕсли;
				КонецЕсли;
				
				Если НЕ ВКавычках Тогда
					Если Символ = "{" Тогда
						СчетчикСкобок = СчетчикСкобок + 1;
					ИначеЕсли Символ = "}" Тогда
						СчетчикСкобок = СчетчикСкобок - 1;
						
						// Если скобки сбалансированы, это конец JSON
						Если СчетчикСкобок = 0 Тогда
							Результат = Сред(Текст, НачалоJSON, Позиция - НачалоJSON + 1);
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
	КонецЕсли;
	
	// 4. Нормализация (единый алгоритм)
	Если НЕ ПустаяСтрока(Результат) Тогда
		Результат = ИИА_DSL.НормализоватьJSONТекст(Результат);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Распознает ответ ИИ и определяет его тип
//
// Параметры:
//  ТекстОтветаИИ - Строка - текст ответа от ИИ
//  ТипСообщения - Строка - тип исходного сообщения
//  ПараметрыИИ - Структура - (опционально) настройки провайдера
//
// Возвращаемое значение:
//  Структура - структура результата с распознанным типом и данными
//
Функция РаспознатьОтветИИ(ТекстОтветаИИ, ТипСообщения, ПараметрыИИ = Неопределено) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", ТекстОтветаИИ);
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	// Всегда сохраняем сырой ответ модели (для логов), даже если он не DSL
	Результат.Вставить("RawModelText", ТекстОтветаИИ);
	
	ОжидаемыйФормат = "dsl";
	Если ПараметрыИИ <> Неопределено И ТипЗнч(ПараметрыИИ) = Тип("Структура") И ПараметрыИИ.Свойство("ExpectedResponseFormat") Тогда
		ОжидаемыйФормат = Строка(ПараметрыИИ.ExpectedResponseFormat);
	КонецЕсли;
	
	Если ОжидаемыйФормат = "plan_json_array" Тогда
		Норм = ИИА_DSL.НормализоватьJSONТекст(ТекстОтветаИИ);
		Если ПустаяСтрока(Норм) Тогда
			Результат.ТипОтвета = "ОшибкаКонтракта";
			Результат.Текст = "Ожидался JSON массив строк (план), но JSON не найден.";
			Возврат Результат;
		КонецЕсли;
		
		Попытка
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(Норм);
			Данные = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			
			Если ТипЗнч(Данные) = Тип("Массив") Тогда
				Результат.ТипОтвета = "Текст";
				Результат.Текст = Норм;
				Возврат Результат;
			КонецЕсли;
		Исключение
			// упадем ниже
			ТекстОшибки = ОписаниеОшибки();
		КонецПопытки;
		
		Результат.ТипОтвета = "ОшибкаКонтракта";
		Результат.Текст = "Ожидался JSON массив строк (план), но получен другой формат.";
		Возврат Результат;
	КонецЕсли;
	
	Если ОжидаемыйФормат = "plan_and_next_dsl" Тогда
		Норм = ИИА_DSL.НормализоватьJSONТекст(ТекстОтветаИИ);
		Если ПустаяСтрока(Норм) Тогда
			Результат.ТипОтвета = "ОшибкаКонтракта";
			Результат.Текст = "Ожидался JSON объект с updated_plan и next_step_dsl, но JSON не найден.";
			Возврат Результат;
		КонецЕсли;
		Результат.ТипОтвета = "Текст";
		Результат.Текст = Норм;
		Возврат Результат;
	КонецЕсли;
	
	// Явно разрешенный текстовый ответ (без DSL-контракта), например для summary.
	Если ОжидаемыйФормат = "text" Тогда
		Результат.ТипОтвета = "Текст";
		Результат.Текст = ТекстОтветаИИ;
		Возврат Результат;
	КонецЕсли;
	
	// 1. Пытаемся извлечь DSL
	DSL_JSON = ИзвлечьDSLИзТекста(ТекстОтветаИИ);
	
	Если НЕ ПустаяСтрока(DSL_JSON) Тогда
		DSL_JSON = ПопыткаВосстановитьDSL(DSL_JSON, ПараметрыИИ);
		
		// В hard-режиме дополнительно проверяем, что это валидный DSL по схеме
		РезультатПроверки = ИИА_DSL.ПроверитьDSL(DSL_JSON);
		Если РезультатПроверки.Успех Тогда
			Результат.ТипОтвета = "DSL";
			Результат.DSL = DSL_JSON;
			Результат.ВыполнитьDSL = Истина;
		Иначе
			Результат.ТипОтвета = "ОшибкаКонтракта";
			Результат.Текст = "Ответ модели содержит JSON, но он не проходит проверку DSL: " + РезультатПроверки.Сообщение;
			Результат.DSL = DSL_JSON;
			Результат.ВыполнитьDSL = Ложь;
		КонецЕсли;
		Возврат Результат;
	КонецЕсли;
	
	// Hard DSL mode: текстовый ответ считается нарушением контракта
	Результат.ТипОтвета = "ОшибкаКонтракта";
	Результат.Текст = "Ответ модели не содержит DSL JSON. Ожидается ТОЛЬКО валидный DSL JSON.";
	
	Возврат Результат;
	
КонецФункции

Функция ПопыткаВосстановитьDSL(DSL_JSON, ПараметрыИИ)
	
	Если ПустаяСтрока(DSL_JSON) Тогда
		Возврат DSL_JSON;
	КонецЕсли;
	
	Попытка
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(DSL_JSON);
		Сценарий = ПрочитатьJSON(ЧтениеJSON);
		ЧтениеJSON.Закрыть();
		
		Если ТипЗнч(Сценарий) = Тип("Структура") Тогда
			Если НЕ Сценарий.Свойство("steps") И Сценарий.Свойство("action") Тогда
				Обертка = Новый Структура;
				Обертка.Вставить("dsl_version", 1);
				Шаги = Новый Массив;
				Шаги.Добавить(Сценарий);
				Обертка.Вставить("steps", Шаги);
				
				ЗаписьJSON = Новый ЗаписьJSON;
				ЗаписьJSON.УстановитьСтроку();
				ЗаписатьJSON(ЗаписьJSON, Обертка);
				НовыйJSON = ЗаписьJSON.Закрыть();
				
				Если НЕ ПустаяСтрока(НовыйJSON) Тогда
					Если ПараметрыИИ <> Неопределено 
						И ТипЗнч(ПараметрыИИ) = Тип("Структура")
						И ПараметрыИИ.Свойство("СсылкаДиалога")
						И ЗначениеЗаполнено(ПараметрыИИ.СсылкаДиалога) Тогда
						ИИА_Сервер.ДобавитьЗаписьВЛогДиалога(ПараметрыИИ.СсылкаДиалога, "[CONTRACT_RECOVERED] DSL обернут в steps");
					КонецЕсли;
					
					Возврат НовыйJSON;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	Исключение
		ТекстОшибки = ОписаниеОшибки();
	КонецПопытки;
	
	Возврат DSL_JSON;
	
КонецФункции

// Нормализует mock-ответ к структуре, совместимой с ответом ВызватьИИ (режим холостого хода)
//
Функция НормализоватьMockОтвет(MockОтвет)
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", "");
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	Результат.Вставить("Usage", Неопределено);
	Результат.Вставить("Ошибки", Неопределено);
	
	Если ТипЗнч(MockОтвет) = Тип("Строка") Тогда
		Результат.Текст = MockОтвет;
	ИначеЕсли ТипЗнч(MockОтвет) = Тип("Структура") Тогда
		Если MockОтвет.Свойство("Текст") Тогда
			Результат.Текст = MockОтвет.Текст;
		КонецЕсли;
		Если MockОтвет.Свойство("ТипОтвета") Тогда
			Результат.ТипОтвета = MockОтвет.ТипОтвета;
		КонецЕсли;
		Если MockОтвет.Свойство("DSL") Тогда
			Результат.DSL = MockОтвет.DSL;
		КонецЕсли;
		Если MockОтвет.Свойство("Запрос") Тогда
			Результат.Запрос = MockОтвет.Запрос;
		КонецЕсли;
		Если MockОтвет.Свойство("ВыполнитьDSL") Тогда
			Результат.ВыполнитьDSL = MockОтвет.ВыполнитьDSL;
		КонецЕсли;
		Если MockОтвет.Свойство("Usage") Тогда
			Результат.Usage = MockОтвет.Usage;
		КонецЕсли;
		Если MockОтвет.Свойство("Ошибки") Тогда
			Результат.Ошибки = MockОтвет.Ошибки;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

#КонецОбласти
