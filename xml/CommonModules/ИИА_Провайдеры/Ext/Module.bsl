#Область ПрограммныйИнтерфейс

// Вызывает ИИ для получения ответа
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  Настройки - Структура - настройки пользователя
//  СистемныйПромпт - Строка - (опционально) переопределение системного промпта
//
// Возвращаемое значение:
//  Структура - структура ответа:
//   * ТипОтвета - Строка ("Текст", "Запрос" или "DSL")
//   * Текст - Строка - текст ответа
//   * Запрос - Строка - текст запроса (для типа "Запрос")
//   * DSL - Строка - JSON с DSL-сценарием (для типа "DSL")
//   * ВыполнитьDSL - Булево - выполнить ли DSL сразу (для типа "DSL")
//   * Usage - Структура - информация об использовании токенов
//   * Ошибки - ОписаниеОшибки - информация об ошибках
//
Функция ВызватьИИ(ТипСообщения, ТекстПользователя, История, Настройки, СистемныйПромпт = "") Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", "");
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	Результат.Вставить("Usage", Неопределено);
	Результат.Вставить("Ошибки", Неопределено);
	
	// Проверяем настройки подключения
	Если ПустаяСтрока(Настройки.Provider_ApiKey) ИЛИ ПустаяСтрока(Настройки.Provider_BaseUrl) Тогда
		
		// Hard DSL mode: это системная ошибка, а не «текстовый ответ»
		Результат.ТипОтвета = "Ошибка";
		Результат.Текст = "Не настроен API ключ или URL провайдера. Настройте подключение к ИИ провайдеру.";
		Возврат Результат;
		
	КонецЕсли;
	
	// Теперь у нас только OpenAI-совместимый провайдер (Gitsell или прямой OpenAI)
	Результат = ВызватьGitsellAiProxy(ТипСообщения, ТекстПользователя, История, Настройки, СистемныйПромпт);
	
	Возврат Результат;
	
КонецФункции

// Вызывает API Gitsell AI Proxy (OpenAI-compatible)
//
// Параметры:
//  ТипСообщения - Строка
//  ТекстПользователя - Строка
//  История - ТаблицаЗначений
//  Настройки - Структура
//  СистемныйПромпт - Строка
//
// Возвращаемое значение:
//  Структура - результат
//
Функция ВызватьGitsellAiProxy(ТипСообщения, ТекстПользователя, История, Настройки, СистемныйПромпт = "")
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", "");
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	Результат.Вставить("Usage", Неопределено);
	Результат.Вставить("Ошибки", Неопределено);
	
	// URL
	URLИзНастроек = Настройки.Provider_BaseUrl;
	Если ПустаяСтрока(URLИзНастроек) Тогда
		URLИзНастроек = "https://gitsell.ru/api/v1";
	КонецЕсли;
	
	// Убираем завершающий слеш
	Если Прав(URLИзНастроек, 1) = "/" Тогда
		URLИзНастроек = Лев(URLИзНастроек, СтрДлина(URLИзНастроек) - 1);
	КонецЕсли;
	
	URLПуть = "/chat/completions";
	
	// Если URL содержит полный путь, нужно распарсить
	// Упрощенно считаем, что в BaseUrl только домен и базовый путь API
	// Для HTTPСоединение нужен домен
	URLБезПротокола = СтрЗаменить(URLИзНастроек, "https://", "");
	URLБезПротокола = СтрЗаменить(URLБезПротокола, "http://", "");
	
	ПозицияСлеша = СтрНайти(URLБезПротокола, "/");
	Если ПозицияСлеша > 0 Тогда
		БазовыйДомен = Лев(URLБезПротокола, ПозицияСлеша - 1);
		БазовыйПуть = Сред(URLБезПротокола, ПозицияСлеша);
		URLПуть = БазовыйПуть + "/chat/completions";
	Иначе
		БазовыйДомен = URLБезПротокола;
		URLПуть = "/api/v1/chat/completions";
	КонецЕсли;
	
	Токен = Настройки.Provider_ApiKey;
	Если ПустаяСтрока(Токен) Тогда
		Результат.ТипОтвета = "Ошибка";
		Результат.Текст = "Не указан API ключ (токен) для Gitsell AI Proxy";
		Возврат Результат;
	КонецЕсли;
	
	// Промпт
	ТипДиалога = Неопределено;
	Если Настройки.Свойство("ТипДиалога") Тогда
		ТипДиалога = Настройки.ТипДиалога;
	КонецЕсли;
	
	Промпт = ИИА_Промты.СформироватьПромпт(ТипДиалога, ТипСообщения, ТекстПользователя, История, СистемныйПромпт);
	
	// Логирование промпта
	ТекстПромпта = "";
	Для Каждого Сообщение Из Промпт.Сообщения Цикл
		Роль = ?(Сообщение.Свойство("role"), Сообщение.role, "");
		Содержимое = ?(Сообщение.Свойство("content"), Сообщение.content, "");
		ТекстПромпта = ТекстПромпта + "[" + Роль + "]" + Символы.ПС + Содержимое + Символы.ПС + Символы.ПС;
	КонецЦикла;
	Результат.Вставить("Промпт", ТекстПромпта);
	
	// Тело запроса
	ТелоЗапроса = Новый Структура;
	
	Модель = ?(Настройки.Свойство("Модель") И НЕ ПустаяСтрока(Настройки.Модель), Настройки.Модель, "auto");
	
	ТелоЗапроса.Вставить("model", Модель);
	ТелоЗапроса.Вставить("messages", Промпт.Сообщения);
	// Для DSL/hard-контрактов нужна предсказуемость
	ТелоЗапроса.Вставить("temperature", 0.0);
	// ТелоЗапроса.Вставить("max_tokens", 4000); // Можно не ограничивать жестко
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, ТелоЗапроса);
	JSONТело = ЗаписьJSON.Закрыть();
	
	Попытка
		HTTPСоединение = Новый HTTPСоединение(БазовыйДомен, 443, , , , , Новый ЗащищенноеСоединениеOpenSSL());
		
		Заголовки = Новый Соответствие;
		Заголовки.Вставить("Content-Type", "application/json");
		Заголовки.Вставить("Accept", "application/json");
		Заголовки.Вставить("Authorization", "Bearer " + Токен);
		
		HTTPЗапрос = Новый HTTPЗапрос(URLПуть, Заголовки);
		HTTPЗапрос.УстановитьТелоИзСтроки(JSONТело);
		
		Ответ = HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);
		ТекстОтвета = Ответ.ПолучитьТелоКакСтроку();
		
		Если Ответ.КодСостояния = 200 Тогда
			
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ТекстОтвета);
			Данные = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			
			Если Данные.Свойство("choices") И Данные.choices.Количество() > 0 Тогда
				Choice = Данные.choices[0];
				Если Choice.Свойство("message") И Choice.message.Свойство("content") Тогда
					ТекстОтветаИИ = Choice.message.content;
					
					// Распознаем тип ответа (учитываем ожидаемый формат из настроек)
					РезультатРаспознавания = РаспознатьОтветИИ(ТекстОтветаИИ, ТипСообщения, Настройки);
					
					Для Каждого КлючЗначение Из РезультатРаспознавания Цикл
						Результат.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
			
			// Usage
			Если Данные.Свойство("usage") Тогда
				UsageStruct = Новый Структура;
				Если Данные.usage.Свойство("gitsell_tokens") Тогда
					UsageStruct.Вставить("TotalTokens", Данные.usage.gitsell_tokens);
				Иначе
					UsageStruct.Вставить("TotalTokens", ?(Данные.usage.Свойство("total_tokens"), Данные.usage.total_tokens, 0));
				КонецЕсли;
				Результат.Usage = UsageStruct;
			КонецЕсли;
			
		Иначе
			
			Если Ответ.КодСостояния = 401 Тогда
				Результат.ТипОтвета = "Ошибка";
				Результат.Текст = "Ошибка 401: Требуется авторизация. Токен отозван или невалиден.";
			Иначе
				Результат.ТипОтвета = "Ошибка";
				Результат.Текст = "Ошибка API (" + Ответ.КодСостояния + "): " + ТекстОтвета;
			КонецЕсли;
			
			Результат.Ошибки = ТекстОтвета;
			
		КонецЕсли;
		
	Исключение
		Результат.ТипОтвета = "Ошибка";
		Результат.Текст = "Ошибка соединения: " + ОписаниеОшибки();
		Результат.Ошибки = ОписаниеОшибки();
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Формирует промпт для ИИ с учетом контекста
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//
// Возвращаемое значение:
//  Структура - структура с сообщениями для ИИ
//
Функция СформироватьПромптДляИИ(ТипСообщения, ТекстПользователя, История) Экспорт
	
	// Функция перенесена в общий модуль ИИА_Промты
	// Оставлена для совместимости
	// Используем Агент как тип по умолчанию
	Возврат ИИА_Промты.СформироватьПромпт(Перечисления.ИИА_ТипДиалога.Агент, ТипСообщения, ТекстПользователя, История);
	
КонецФункции

// Извлекает DSL JSON из текста
//
// Параметры:
//  Текст - Строка - текст, из которого нужно извлечь JSON
//
// Возвращаемое значение:
//  Строка - извлеченный JSON или пустая строка, если не найден
//
Функция ИзвлечьDSLИзТекста(Текст) Экспорт
	
	Результат = "";
	
	// 1. Попытка найти блок кода JSON (```json ... ```)
	НачалоБлока = СтрНайти(Текст, "```json");
	Если НачалоБлока > 0 Тогда
		НачалоJSON = НачалоБлока + 7; // Длина "```json"
		
		// Ищем закрывающий блок, начиная с позиции после открывающего
		// Используем Сред для получения остатка строки и ищем в нем
		ОстатокТекста = Сред(Текст, НачалоJSON);
		КонецБлокаОтносительный = СтрНайти(ОстатокТекста, "```");
		
		Если КонецБлокаОтносительный = 0 Тогда
             // Если закрывающего блока нет, ищем до конца
             Результат = Сред(Текст, НачалоJSON);
        Иначе
             // Берем содержимое до закрывающего блока
             Результат = Лев(ОстатокТекста, КонецБлокаОтносительный - 1);
        КонецЕсли;
        
	Иначе
		// 2. Попытка найти просто блок кода (``` ... ```) и проверить, является ли он JSON
		НачалоБлока = СтрНайти(Текст, "```");
		Если НачалоБлока > 0 Тогда
			НачалоJSON = НачалоБлока + 3;
			
			ОстатокТекста = Сред(Текст, НачалоJSON);
			КонецБлокаОтносительный = СтрНайти(ОстатокТекста, "```");
			
			Если КонецБлокаОтносительный > 0 Тогда
				ПотенциальныйJSON = СокрЛП(Лев(ОстатокТекста, КонецБлокаОтносительный - 1));
				Если СтрНачинаетсяС(ПотенциальныйJSON, "{") Тогда
					Результат = ПотенциальныйJSON;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	// 3. Если не найдено в блоках, ищем просто JSON-объект в тексте (от первой { до последней })
	Если ПустаяСтрока(Результат) Тогда
		НачалоJSON = СтрНайти(Текст, "{");
		Если НачалоJSON > 0 Тогда
			
			// Ищем последнюю закрывающую скобку
			// Простой поиск с конца не работает корректно, если после JSON есть текст
			// Попробуем балансировку скобок
			
			СчетчикСкобок = 0;
			ВКавычках = Ложь;
			Для Позиция = НачалоJSON По СтрДлина(Текст) Цикл
				Символ = Сред(Текст, Позиция, 1);
				
				// Обработка кавычек для игнорирования скобок внутри строк
				Если Символ = """" Тогда
					// Проверяем, не экранирована ли кавычка (очень упрощенно)
					Если Позиция > 1 И Сред(Текст, Позиция - 1, 1) <> "\" Тогда
						ВКавычках = НЕ ВКавычках;
					КонецЕсли;
				КонецЕсли;
				
				Если НЕ ВКавычках Тогда
					Если Символ = "{" Тогда
						СчетчикСкобок = СчетчикСкобок + 1;
					ИначеЕсли Символ = "}" Тогда
						СчетчикСкобок = СчетчикСкобок - 1;
						
						// Если скобки сбалансированы, это конец JSON
						Если СчетчикСкобок = 0 Тогда
							Результат = Сред(Текст, НачалоJSON, Позиция - НачалоJSON + 1);
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
	КонецЕсли;
	
	// 4. Нормализация (единый алгоритм)
	Если НЕ ПустаяСтрока(Результат) Тогда
		Результат = ИИА_DSL.НормализоватьJSONТекст(Результат);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Распознает ответ ИИ и определяет его тип
//
// Параметры:
//  ТекстОтветаИИ - Строка - текст ответа от ИИ
//  ТипСообщения - Строка - тип исходного сообщения
//
// Возвращаемое значение:
//  Структура - структура результата с распознанным типом и данными
//
Функция РаспознатьОтветИИ(ТекстОтветаИИ, ТипСообщения, Настройки = Неопределено) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", ТекстОтветаИИ);
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	// Всегда сохраняем сырой ответ модели (для логов), даже если он не DSL
	Результат.Вставить("RawModelText", ТекстОтветаИИ);
	
	ОжидаемыйФормат = "dsl";
	Если Настройки <> Неопределено И ТипЗнч(Настройки) = Тип("Структура") И Настройки.Свойство("ExpectedResponseFormat") Тогда
		ОжидаемыйФормат = Строка(Настройки.ExpectedResponseFormat);
	КонецЕсли;
	
	Если ОжидаемыйФормат = "plan_json_array" Тогда
		Норм = ИИА_DSL.НормализоватьJSONТекст(ТекстОтветаИИ);
		Если ПустаяСтрока(Норм) Тогда
			Результат.ТипОтвета = "ОшибкаКонтракта";
			Результат.Текст = "Ожидался JSON массив строк (план), но JSON не найден.";
			Возврат Результат;
		КонецЕсли;
		
		Попытка
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(Норм);
			Данные = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			
			Если ТипЗнч(Данные) = Тип("Массив") Тогда
				Результат.ТипОтвета = "Текст";
				Результат.Текст = Норм;
				Возврат Результат;
			КонецЕсли;
		Исключение
			// упадем ниже
		КонецПопытки;
		
		Результат.ТипОтвета = "ОшибкаКонтракта";
		Результат.Текст = "Ожидался JSON массив строк (план), но получен другой формат.";
		Возврат Результат;
	КонецЕсли;
	
	Если ОжидаемыйФормат = "plan_and_next_dsl" Тогда
		Норм = ИИА_DSL.НормализоватьJSONТекст(ТекстОтветаИИ);
		Если ПустаяСтрока(Норм) Тогда
			Результат.ТипОтвета = "ОшибкаКонтракта";
			Результат.Текст = "Ожидался JSON объект с updated_plan и next_step_dsl, но JSON не найден.";
			Возврат Результат;
		КонецЕсли;
		Результат.ТипОтвета = "Текст";
		Результат.Текст = Норм;
		Возврат Результат;
	КонецЕсли;
	
	// Явно разрешенный текстовый ответ (без DSL-контракта), например для summary.
	Если ОжидаемыйФормат = "text" Тогда
		Результат.ТипОтвета = "Текст";
		Результат.Текст = ТекстОтветаИИ;
		Возврат Результат;
	КонецЕсли;
	
	// 1. Пытаемся извлечь DSL
	DSL_JSON = ИзвлечьDSLИзТекста(ТекстОтветаИИ);
	
	Если НЕ ПустаяСтрока(DSL_JSON) Тогда
		// В hard-режиме дополнительно проверяем, что это валидный DSL по схеме
		РезультатПроверки = ИИА_DSL.ПроверитьDSL(DSL_JSON);
		Если РезультатПроверки.Успех Тогда
			Результат.ТипОтвета = "DSL";
			Результат.DSL = DSL_JSON;
			Результат.ВыполнитьDSL = Истина;
		Иначе
			Результат.ТипОтвета = "ОшибкаКонтракта";
			Результат.Текст = "Ответ модели содержит JSON, но он не проходит проверку DSL: " + РезультатПроверки.Сообщение;
			Результат.DSL = DSL_JSON;
			Результат.ВыполнитьDSL = Ложь;
		КонецЕсли;
		Возврат Результат;
	КонецЕсли;
	
	// Hard DSL mode: текстовый ответ считается нарушением контракта
	Результат.ТипОтвета = "ОшибкаКонтракта";
	Результат.Текст = "Ответ модели не содержит DSL JSON. Ожидается ТОЛЬКО валидный DSL JSON.";
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти
