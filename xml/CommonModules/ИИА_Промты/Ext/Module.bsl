#Область ПрограммныйИнтерфейс

// Формирует промпт для ИИ с учетом контекста
//
// Параметры:
//  ТипДиалога - ПеречислениеСсылка.ИИА_ТипДиалога - тип диалога (Агент, Чат и т.д.)
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  СистемныйПромпт - Строка - (опционально) переопределение системного промпта
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - (опционально) ссылка на диалог для RAG-логирования
//  ИспользоватьRAG - Булево - (опционально) если Истина, RAG-контекст будет добавлен
//
// Возвращаемое значение:
//  Структура - структура с сообщениями для ИИ
//
Функция СформироватьПромпт(ТипДиалога, ТипСообщения, ТекстПользователя, История, СистемныйПромпт = "", Знач СсылкаДиалога = Неопределено, Знач ИспользоватьRAG = Ложь) Экспорт
	
	// Получаем системный промпт в зависимости от типа диалога или используем переданный
	ТекстСистемногоПромпта = ?(ПустаяСтрока(СистемныйПромпт), ПолучитьТекстСистемногоПромпта(ТипДиалога), СистемныйПромпт);
	
	// Формируем массив сообщений
	Сообщения = Новый Массив;
	
	// 1. Системное сообщение
	СообщениеСистема = Новый Структура;
	СообщениеСистема.Вставить("role", "system");
	СообщениеСистема.Вставить("content", ТекстСистемногоПромпта);
	Сообщения.Добавить(СообщениеСистема);
	
	// 2. State summary вместо «сырой» истории (предсказуемее и дешевле по токенам)
	ТекстState = СформироватьStateSummary(История);
	Если НЕ ПустаяСтрока(ТекстState) Тогда
		
		// ДЕТЕКТОР ЦИКЛОВ: Проверяем на повторные вызовы действий для одного и того же объекта
		Если СтрНайти(ТекстState, "Последний выполненный DSL:") > 0 Тогда
			// Ищем паттерны повторов в истории (упрощенно через анализ StateSummary)
			Если СтрЧислоВхождений(ТекстState, "CheckObjectExists") >= 2 Тогда
				ТекстState = ТекстState + Символы.ПС + 
				"ВНИМАНИЕ: Ты уже несколько раз вызывал CheckObjectExists для этого объекта. " +
				"ПЕРЕХОДИ к следующему шагу плана (GetObjectFields или RunQuery). Не зацикливайся на проверке существования.";
			КонецЕсли;
		КонецЕсли;
		
		СообщениеState = Новый Структура;
		СообщениеState.Вставить("role", "user");
		СообщениеState.Вставить("content", ТекстState);
		Сообщения.Добавить(СообщениеState);
	КонецЕсли;
	
	// 3. Текущее сообщение пользователя
	ТекстRAG = "";
	
	// Пытаемся найти контекст RAG по текущему запросу
	// Для системных вызовов (планирование/обновление) используем ТекстПользователя
	// Для обычного чата это и есть запрос пользователя.
	Если ИспользоватьRAG Тогда
		
		ТекстДляRAG = ТекстПользователя;
		
		// Если ТекстПользователя - это системная инструкция, 
		// для RAG нужно использовать реальную задачу пользователя.
		Если СтрНайти(ТекстПользователя, "сгенерировать DSL") > 0 
			ИЛИ СтрНайти(ТекстПользователя, "Обнови статусы плана") > 0 Тогда
			
			// Ищем в истории первое сообщение пользователя
			Для Каждого СтрокаИстории Из История Цикл
				Если СтрокаИстории.Автор = Перечисления.ИИА_АвторСообщения.Пользователь Тогда
					ТекстДляRAG = СтрокаИстории.Текст;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
		ИначеЕсли СтрНайти(ТекстПользователя, "Составь краткий план") > 0 
			ИЛИ СтрНайти(ТекстПользователя, "Задача:") > 0 Тогда
			
			// Для планирования извлекаем только текст задачи (между "Задача:" и "Требования:" или концом)
			ПозЗадача = СтрНайти(ТекстПользователя, "Задача:");
			Если ПозЗадача > 0 Тогда
				Начало = ПозЗадача + СтрДлина("Задача:");
				ПозТребования = СтрНайти(Сред(ТекстПользователя, Начало), "Требования:");
				Если ПозТребования > 0 Тогда
					ТекстДляRAG = СокрЛП(Лев(Сред(ТекстПользователя, Начало), ПозТребования - 1));
				Иначе
					ТекстДляRAG = СокрЛП(Сред(ТекстПользователя, Начало));
				КонецЕсли;
				Если ПустаяСтрока(ТекстДляRAG) Тогда
					ТекстДляRAG = ТекстПользователя;
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
		
		ТекстRAG = СформироватьКонтекстRAG(ТекстДляRAG, СсылкаДиалога);
		
		// Логируем факт вызова RAG, если он вернул данные
		Если НЕ ПустаяСтрока(ТекстRAG) И СсылкаДиалога <> Неопределено Тогда
			ИИА_Сервер.ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "[RAG_CONTEXT_ADDED] Контекст RAG добавлен в промпт.");
		КонецЕсли;
	КонецЕсли;
	
	// ВАЖНО: Если мы в режиме планирования/обновления, принудительно добавляем факты в промпт,
	// если они ещё не включены (оркестратор уже передаёт их в «Факты последних действий»).
	ТекстПользователяВРег = ВРег(ТекстПользователя);
	Если СтрНайти(ТекстПользователяВРег, ВРег("сгенерировать DSL")) > 0 
		ИЛИ СтрНайти(ТекстПользователяВРег, ВРег("Обнови статусы плана")) > 0 Тогда
		
		// Не дублируем: промпт от оркестратора уже содержит блок «Факты последних действий»
		Если СтрНайти(ТекстПользователяВРег, ВРег("Факты последних действий")) = 0 Тогда
			Факты = ИИА_Оркестратор.СобратьФактыПоследнихДействий(СсылкаДиалога);
			Если НЕ ПустаяСтрока(Факты) Тогда
				ТекстПользователя = ТекстПользователя + Символы.ПС + "Факты последних действий (ИЗ ИСТОРИИ): " + Факты;
				Если СсылкаДиалога <> Неопределено Тогда
					ИИА_Сервер.ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "[FACTS_INJECTED] Факты из истории принудительно добавлены в промпт.");
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	СообщениеПользователь = Новый Структура;
	СообщениеПользователь.Вставить("role", "user");
	
	// ВАЖНО: Мы должны использовать модифицированный ТекстПользователя (с фактами)
	Если НЕ ПустаяСтрока(ТекстRAG) Тогда
		СообщениеПользователь.Вставить("content", ТекстRAG + Символы.ПС + "ЗАДАЧА: " + ТекстПользователя);
	Иначе
		СообщениеПользователь.Вставить("content", ТекстПользователя);
	КонецЕсли;
	
	Сообщения.Добавить(СообщениеПользователь);
	
	Результат = Новый Структура;
	Результат.Вставить("Сообщения", Сообщения);
	
	Возврат Результат;
	
КонецФункции

Функция СформироватьStateSummary(История)
	
	Если История = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	Количество = История.Количество();
	Если Количество = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	ПоследнийСистемныйРезультат = "";
	ПоследнийDSL = "";
	ПоследниеСообщенияПользователя = Новый Массив;
	
	Для Индекс = Количество - 1 По 0 Цикл
		
		СтрокаИстории = История[Индекс];
		
		Если СтрокаИстории.ТипСообщения = Перечисления.ИИА_ТипСообщения.Ошибка Тогда
			Продолжить;
		КонецЕсли;
		
		Если ПустаяСтрока(ПоследнийСистемныйРезультат) И СтрокаИстории.Автор = Перечисления.ИИА_АвторСообщения.Система Тогда
			// Предпочитаем dsl_system_result, если он есть
			Если СтрНайти(СтрокаИстории.Текст, "dsl_system_result") > 0 Тогда
				ПоследнийСистемныйРезультат = СтрокаИстории.Текст;
			ИначеЕсли ПустаяСтрока(ПоследнийСистемныйРезультат) Тогда
				ПоследнийСистемныйРезультат = СтрокаИстории.Текст;
			КонецЕсли;
		КонецЕсли;
		
		Если ПустаяСтрока(ПоследнийDSL) И СтрокаИстории.Автор = Перечисления.ИИА_АвторСообщения.ИИ 
			И (СтрокаИстории.ТипСообщения = Перечисления.ИИА_ТипСообщения.Код ИЛИ НЕ ПустаяСтрока(СтрокаИстории.ТекстКода)) Тогда
			ПоследнийDSL = ?(ПустаяСтрока(СтрокаИстории.ТекстКода), СтрокаИстории.Текст, СтрокаИстории.ТекстКода);
		КонецЕсли;
		
		Если СтрокаИстории.Автор = Перечисления.ИИА_АвторСообщения.Пользователь И ПоследниеСообщенияПользователя.Количество() < 2 Тогда
			ПоследниеСообщенияПользователя.Добавить(СтрокаИстории.Текст);
		КонецЕсли;
		
	КонецЦикла;
	
	ТекстState = "ТЕКУЩЕЕ СОСТОЯНИЕ ВЫПОЛНЕНИЯ:" + Символы.ПС;
	
	Если НЕ ПустаяСтрока(ПоследнийСистемныйРезультат) Тогда
		ТекстState = ТекстState + "Результат последнего действия: " + ПоследнийСистемныйРезультат + Символы.ПС;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПоследнийDSL) Тогда
		ТекстState = ТекстState + "Последний выполненный DSL: " + ПоследнийDSL + Символы.ПС;
	КонецЕсли;
	
	Если ПоследниеСообщенияПользователя.Количество() > 0 Тогда
		ТекстState = ТекстState + "Контекст задачи: " + СтрСоединить(ПоследниеСообщенияПользователя, " -> ") + Символы.ПС;
	КонецЕсли;
	
	Возврат ТекстState;
	
КонецФункции

// Формирует промпт для планировщика задач
Функция ПолучитьТекстПромптаПланировщика() Экспорт
	
	Промпт = "Ты - опытный аналитик 1С. Твоя задача - составить план действий для выполнения запроса пользователя." + Символы.ПС +
	"План должен состоять из последовательных шагов, каждый из которых можно выполнить через DSL агента." + Символы.ПС +
	"Поддерживаемые действия: GetMetadata, GetObjectFields, CheckObjectExists, RunQuery, ShowInfo, CreateReference, CreateDocument, SelectObject, SetField, Write, Delete." + Символы.ПС +
	"Если RAG подсказка уже содержит найденные объекты с полями — сразу RunQuery->ShowInfo. Иначе — начни с CheckObjectExists или GetMetadata." + Символы.ПС +
	"Ответ должен быть ТОЛЬКО в формате JSON массива строк.";
	
	Возврат Промпт;
	
КонецФункции

// Формирует контекст последних созданных/изменённых объектов для разрешения местоимений
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
// Возвращаемое значение:
//  Строка - блок контекста или пустая строка
//
Функция СформироватьКонтекстИзмененныхОбъектов(СсылкаДиалога) Экспорт
	
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) ИЛИ СсылкаДиалога.Пустая() Тогда
		Возврат "";
	КонецЕсли;
	
	Попытка
		Диалог = СсылкаДиалога.ПолучитьОбъект();
		Если Диалог = Неопределено ИЛИ Диалог.ИзмененныеОбъекты.Количество() = 0 Тогда
			Возврат "";
		КонецЕсли;
		
		МассивОписаний = Новый Массив;
		МаксимумОбъектов = 10;
		ИндексНачала = Макс(0, Диалог.ИзмененныеОбъекты.Количество() - МаксимумОбъектов);
		
		Для Индекс = ИндексНачала По Диалог.ИзмененныеОбъекты.Количество() - 1 Цикл
			СтрокаИзмененных = Диалог.ИзмененныеОбъекты[Индекс];
			СсылкаНаОбъект = СтрокаИзмененных.СсылкаНаОбъект;
			Если НЕ ЗначениеЗаполнено(СсылкаНаОбъект) Тогда
				Продолжить;
			КонецЕсли;
			
			Попытка
				МетаданныеОбъекта = СсылкаНаОбъект.Метаданные();
				ПолноеИмя = МетаданныеОбъекта.ПолноеИмя();
				Наименование = "";
				Объект = СсылкаНаОбъект.ПолучитьОбъект();
				Если Объект <> Неопределено Тогда
					Попытка
						Наименование = СокрЛП(Строка(Объект.Наименование));
					Исключение
						Наименование = СокрЛП(Строка(СсылкаНаОбъект));
					КонецПопытки;
				Иначе
					Наименование = СокрЛП(Строка(СсылкаНаОбъект));
				КонецЕсли;
				Если СтрДлина(Наименование) > 50 Тогда
					Наименование = Лев(Наименование, 47) + "...";
				КонецЕсли;
				Описание = ПолноеИмя + " — " + Наименование;
				МассивОписаний.Добавить(Описание);
			Исключение
				// Пропускаем объект при ошибке доступа
			КонецПопытки;
		КонецЦикла;
		
		Если МассивОписаний.Количество() = 0 Тогда
			Возврат "";
		КонецЕсли;
		
		МассивСПрефиксом = Новый Массив;
		Для Каждого Описание Из МассивОписаний Цикл
			МассивСПрефиксом.Добавить("- " + Описание);
		КонецЦикла;
		ТекстОбъектов = СтрСоединить(МассивСПрефиксом, Символы.ПС);
		Возврат "Контекст диалога: В этом диалоге недавно созданы/изменены объекты:" + Символы.ПС +
			ТекстОбъектов + Символы.ПС +
			"Местоимения «ему», «его», «этот» в задаче относятся к последнему объекту из списка." + Символы.ПС + Символы.ПС;
		
	Исключение
		Возврат "";
	КонецПопытки;
	
КонецФункции

// Формирует контекст из регистра сведений (ХранилищеЗначений) диалога
// Извлекает DSL_СсылкаОбъекта, DSL_ТипОбъекта, DSL_ИмяОбъекта — текущий объект в контексте DSL
//
Функция СформироватьКонтекстИзРегистраДиалога(СсылкаДиалога) Экспорт
	
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) ИЛИ СсылкаДиалога.Пустая() Тогда
		Возврат "";
	КонецЕсли;
	
	Попытка
		СтруктураДанных = ИИА_Сервер.ПолучитьДанныеДиалогаИзРегистра(СсылкаДиалога);
		Если СтруктураДанных = Неопределено ИЛИ ТипЗнч(СтруктураДанных) <> Тип("Структура") Тогда
			Возврат "";
		КонецЕсли;
		
		Если НЕ СтруктураДанных.Свойство("DSL_СсылкаОбъекта") ИЛИ НЕ ЗначениеЗаполнено(СтруктураДанных.DSL_СсылкаОбъекта) Тогда
			Возврат "";
		КонецЕсли;
		
		СсылкаНаОбъект = СтруктураДанных.DSL_СсылкаОбъекта;
		Попытка
			МетаданныеОбъекта = СсылкаНаОбъект.Метаданные();
			ПолноеИмя = МетаданныеОбъекта.ПолноеИмя();
			Наименование = "";
			Объект = СсылкаНаОбъект.ПолучитьОбъект();
			Если Объект <> Неопределено Тогда
				Попытка
					Наименование = СокрЛП(Строка(Объект.Наименование));
				Исключение
					Наименование = СокрЛП(Строка(СсылкаНаОбъект));
				КонецПопытки;
			Иначе
				Наименование = СокрЛП(Строка(СсылкаНаОбъект));
			КонецЕсли;
			Если СтрДлина(Наименование) > 50 Тогда
				Наименование = Лев(Наименование, 47) + "...";
			КонецЕсли;
			Возврат "Текущий объект в контексте DSL: " + ПолноеИмя + " — " + Наименование + Символы.ПС + Символы.ПС;
		Исключение
			Возврат "";
		КонецПопытки;
		
	Исключение
		Возврат "";
	КонецПопытки;
	
КонецФункции

// Собирает полный контекст для дополнения плана: ИзмененныеОбъекты, регистр диалога, факты последних действий
//
Функция СформироватьПолныйКонтекстДляДополненияПлана(СсылкаДиалога) Экспорт
	
	Если НЕ ЗначениеЗаполнено(СсылкаДиалога) ИЛИ СсылкаДиалога.Пустая() Тогда
		Возврат "";
	КонецЕсли;
	
	МассивБлоков = Новый Массив;
	
	// 1. ИзмененныеОбъекты — обязательно передавать
	КонтекстОбъектов = СформироватьКонтекстИзмененныхОбъектов(СсылкаДиалога);
	Если НЕ ПустаяСтрока(КонтекстОбъектов) Тогда
		МассивБлоков.Добавить(КонтекстОбъектов);
	КонецЕсли;
	
	// 2. Контекст из регистра (ХранилищеЗначений) — текущий объект DSL
	КонтекстРегистра = СформироватьКонтекстИзРегистраДиалога(СсылкаДиалога);
	Если НЕ ПустаяСтрока(КонтекстРегистра) Тогда
		МассивБлоков.Добавить(КонтекстРегистра);
	КонецЕсли;
	
	// 3. Факты последних действий (результаты DSL)
	Факты = ИИА_Оркестратор.СобратьФактыПоследнихДействий(СсылкаДиалога);
	Если НЕ ПустаяСтрока(Факты) Тогда
		ТекстФактов = Факты;
		Если СтрДлина(ТекстФактов) > 2000 Тогда
			ТекстФактов = Лев(ТекстФактов, 2000) + "...(обрезано)";
		КонецЕсли;
		МассивБлоков.Добавить("Факты последних действий (результаты DSL):" + Символы.ПС + ТекстФактов + Символы.ПС + Символы.ПС);
	КонецЕсли;
	
	Если МассивБлоков.Количество() = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	Возврат "КОНТЕКСТ ДИАЛОГА (используй для разрешения местоимений и выбора объектов):" + Символы.ПС + Символы.ПС +
		СтрСоединить(МассивБлоков, "");
	
КонецФункции

// Формирует промпт для создания плана
//
// Параметры:
//  ТекстЗадачи - Строка - текст задачи
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - (опционально) ссылка на диалог для RAG
//
// Возвращаемое значение:
//  Строка - текст промпта
//
Функция ПолучитьПромптСозданияПлана(ТекстЗадачи, Знач СсылкаДиалога = Неопределено) Экспорт
	
	Промпт = "Составь краткий план выполнения задачи (3-6 пунктов) в терминах DSL-действий агента 1С." + Символы.ПС;
	
	// Добавляем контекст последних объектов для разрешения местоимений
	КонтекстОбъектов = СформироватьКонтекстИзмененныхОбъектов(СсылкаДиалога);
	Если НЕ ПустаяСтрока(КонтекстОбъектов) Тогда
		Промпт = Промпт + КонтекстОбъектов;
	КонецЕсли;
	
	Промпт = Промпт + "Задача: " + ТекстЗадачи + Символы.ПС +
	"Требования:" + Символы.ПС +
	"- ЗАДАЧА «СОЗДАТЬ» (создай, создай контрагента, добавь и т.п.): для справочников (контрагент, номенклатура, склад) — CreateReference{object_name,name}; для документов (поступление, реализация, накладная, черновик) — CreateDocument{object_name,data}. Затем Write + ShowInfo. НЕ включай SelectObject (объект уже выбран после CreateReference/CreateDocument), НЕ включай SetField Наименование (CreateReference с name уже задаёт его), НЕ включай RunQuery для проверки (достаточно ShowInfo)." + Символы.ПС +
	"- ОСОБОЕ ПРАВИЛО RAG: Если в блоке 'ПОДСКАЗКА ПО МЕТАДАННЫМ (RAG)' уже найдены подходящие объекты (особенно с полями в формате '(Поля: ...)') — объект УЖЕ подтверждён и поля УЖЕ известны. НЕ включай в план CheckObjectExists и GetObjectFields. Сразу переходи к RunQuery -> ShowInfo." + Символы.ПС +
	"- Если RAG не нашёл объекты или полей нет — используй цепочку: CheckObjectExists -> GetObjectFields -> RunQuery -> ShowInfo." + Символы.ПС +
	"- НЕ описывай действия пользователя в интерфейсе (клики, кнопки, формы, меню, отчёты)." + Символы.ПС +
	"- НЕ используй SQL (SELECT COUNT(*)); используй язык запросов 1С внутри RunQuery." + Символы.ПС +
	"- Для RunQuery: НЕ указывай в плане конкретный текст запроса с именами полей (они могут отсутствовать в базе). Пиши обобщённо, например: RunQuery{query:'ВЫБРАТЬ ...'} - запрос формируется после GetObjectFields или из RAG (если поля указаны)." + Символы.ПС +
	"- Если название объекта неясно и RAG подсказки нет, используй GetMetadata{filter:'...'} ." + Символы.ПС +
	"Ответ: только валидный JSON массив строк. Без пояснений и без Markdown.";
	
	Возврат Промпт;
	
КонецФункции

// Формирует промпт для дополнения плана новыми задачами (режим продолжения диалога)
//
// Параметры:
//  ТекстНовойЗадачи - Строка - текст новой задачи пользователя
//  ТекущийПланJSON - Строка - текущий план в формате JSON (Задача, Выполнена, Результат)
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог для контекста
//
// Возвращаемое значение:
//  Строка - текст промпта
//
Функция ПолучитьПромптДополненияПлана(ТекстНовойЗадачи, ТекущийПланJSON, Знач СсылкаДиалога = Неопределено) Экспорт
	
	Промпт = "В диалоге уже выполнены следующие задачи:" + Символы.ПС +
		ТекущийПланJSON + Символы.ПС + Символы.ПС +
		"Новая задача пользователя: " + ТекстНовойЗадачи + Символы.ПС + Символы.ПС;
	
	// Добавляем полный контекст: ИзмененныеОбъекты, регистр (ХранилищеЗначений), факты последних действий
	ПолныйКонтекст = СформироватьПолныйКонтекстДляДополненияПлана(СсылкаДиалога);
	Если НЕ ПустаяСтрока(ПолныйКонтекст) Тогда
		Промпт = Промпт + ПолныйКонтекст;
	КонецЕсли;
	
	Промпт = Промпт +
		"Добавь ТОЛЬКО новые шаги плана для выполнения новой задачи. НЕ дублируй уже выполненные шаги." + Символы.ПС +
		"Используй контекст объектов (местоимения «ему», «его», «этот» — последний объект из списка)." + Символы.ПС +
		"Ответ: только валидный JSON массив строк (новые задачи). Без пояснений и без Markdown.";
	
	Возврат Промпт;
	
КонецФункции

// Формирует промпт для обновления состояния плана
//
// Параметры:
//  ПланJSON - Строка - текущий план в формате JSON
//  РезультатПоследнегоDSL - Строка - результаты выполнения последнего DSL-сценария
//
// Возвращаемое значение:
//  Строка - текст промпта
//
Функция ПолучитьПромптОбновленияПлана(ПланJSON, РезультатПоследнегоDSL) Экспорт
	
	Промпт = "Обнови статусы плана по последним результатам." + Символы.ПС +
	"План (JSON): " + ПланJSON + Символы.ПС +
	"Факты последних действий: " + РезультатПоследнегоDSL + Символы.ПС +
	"Правила: не меняй Выполнена=true на false; Результат - короткая строка." + Символы.ПС +
	"Ставь Выполнена=true ТОЛЬКО если в 'Факты последних действий' есть явное подтверждение выполнения (например dsl_system_result success=true или выполненный DSL с нужным действием)." + Символы.ПС +
	"ОСОБОЕ ПРАВИЛО для RunQuery: Выполнена=true ТОЛЬКО если в фактах есть успешный RunQuery (запрос выполнен, результат получен). CheckObjectExists 'не существует' НЕ означает, что RunQuery выполнен — RunQuery не запускался. Если объект из плана не существует, но GetMetadata вернул альтернативы — RunQuery ещё не выполнен." + Символы.ПС +
	"ОСОБОЕ ПРАВИЛО для CreateReference: если RunQuery уже вернул найденные записи (Найден X, Результат: X) и выполнен ShowInfo с текстом 'Объект уже существует' - считай CreateReference ВЫПОЛНЕННОЙ, Результат='Объект уже найден'." + Символы.ПС +
	"Если ставишь Выполнена=true - Результат НЕ должен быть пустым (кратко укажи факт/доказательство)." + Символы.ПС +
	"Ответ: только JSON массив объектов {""Задача"":""..."",""Выполнена"":true/false,""Результат"":""...""}.";
	
	Возврат Промпт;
	
КонецФункции

// Формирует промпт для генерации следующего шага DSL на основе плана
//
// Параметры:
//  ПланJSON - Строка - текущий план в формате JSON
//  РезультатПоследнегоDSL - Строка - результаты выполнения последнего DSL-сценария
//  ДоступныеПоля - Строка - (опционально) текст со списком полей из GetObjectFields для использования в RunQuery
//  НеудачныеОбъекты - Строка - (опционально) список имён объектов, по которым уже была ошибка (таблица/поле не найдено)
//
// Возвращаемое значение:
//  Строка - текст промпта
//
Функция ПолучитьПромптГенерацииСледующегоШага(ПланJSON, РезультатПоследнегоDSL, ДоступныеПоля = "", НеудачныеОбъекты = "") Экспорт
	
	Промпт = "Твоя задача - сгенерировать DSL для СЛЕДУЮЩЕГО невыполненного пункта плана." + Символы.ПС +
	"" + Символы.ПС +
	"План (JSON): " + ПланJSON + Символы.ПС +
	"Факты последних действий: " + РезультатПоследнегоDSL + Символы.ПС;
	
	Если НЕ ПустаяСтрока(ДоступныеПоля) Тогда
		Промпт = Промпт + Символы.ПС +
		"!!! КРИТИЧЕСКИ ВАЖНО - ДОСТУПНЫЕ ПОЛЯ (из GetObjectFields, используй ТОЛЬКО их в RunQuery):" + Символы.ПС +
		ДоступныеПоля + Символы.ПС +
		"НЕ выдумывай поля (например ЮрФизЛицо) - они могут отсутствовать в базе. Используй ТОЛЬКО поля из списка выше." + Символы.ПС;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(НеудачныеОбъекты) Тогда
		Промпт = Промпт + Символы.ПС +
		"ЗАПРЕЩЕНО использовать в RunQuery объекты, по которым уже была ошибка: " + НеудачныеОбъекты + "." + Символы.ПС +
		"Используй только объекты из успешных GetMetadata/GetObjectFields." + Символы.ПС;
	КонецЕсли;
	
	Промпт = Промпт + Символы.ПС +
	"Ограничения для DSL:" + Символы.ПС +
	"- steps[].action ТОЛЬКО из поддерживаемых действий: RunQuery, ShowInfo, GetMetadata, GetObjectFields, CheckObjectExists, CreateReference, CreateDocument, FindReferenceByGUID, SelectObject, SetField, Write, Delete, ForEach, SaveToStorage." + Символы.ПС +
	"- ЗАПРЕЩЕНЫ любые UI/браузерные действия (click, open_form и т.п.)." + Символы.ПС +
	"- Все обязательные поля должны быть на верхнем уровне шага (без вложенных params/args)." + Символы.ПС +
	"- ПОДСТАНОВКА ОБЪЕКТА: Если следующий шаг - RunQuery для объекта X, но X не существует (CheckObjectExists или GetMetadata), а в RAG или GetMetadata есть подходящий документ Y (например РасходнаяНакладная для «реализация») — ВЫПОЛНИ RunQuery для Y, НЕ ShowInfo «Данные не найдены»." + Символы.ПС +
	"- ОБЪЕКТ ИЗ GetMetadata: Если объект получен через GetMetadata (а не из RAG с полями) — перед RunQuery ОБЯЗАТЕЛЬНО выполни GetObjectFields и используй ТОЛЬКО поля из результата." + Символы.ПС +
	"- КРИТИЧЕСКОЕ ПРАВИЛО: Если следующий шаг плана - CreateReference, но в Фактах последних действий уже есть УСПЕШНЫЙ RunQuery, который ВЕРНУЛ записи (например 'Найден X', 'Запрос выполнен. Результат: X') - объект УЖЕ СУЩЕСТВУЕТ! НЕ выполняй CreateReference - это создаст дубликат. Вместо этого используй ShowInfo{message:'Объект уже существует в базе: [укажи результат RunQuery]'}." + Символы.ПС +
	"" + Символы.ПС +
	"СХЕМЫ (СТРОГО):" + Символы.ПС +
	"- CheckObjectExists: {""action"":""CheckObjectExists"",""object_type"":""Справочник"",""object_name"":""Контрагенты""}" + Символы.ПС +
	"- GetObjectFields: {""action"":""GetObjectFields"",""object_type"":""Справочник"",""object_name"":""Контрагенты""}" + Символы.ПС +
	"- FindReferenceByGUID: guid — строка UUID (""xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx""), НЕ текст результата" + Символы.ПС +
	"- CreateDocument: {""action"":""CreateDocument"",""object_name"":""ПриходТовараМП"",""data"":{""Контрагент"":""#(FindReferenceByName)""}}" + Символы.ПС +
	"- RunQuery: {""action"":""RunQuery"",""query"":""ВЫБРАТЬ ...""}" + Символы.ПС +
	"- ShowInfo: {""action"":""ShowInfo"",""message"":""...""}" + Символы.ПС +
	"" + Символы.ПС +
	"Ответ: только валидный JSON объект вида {""dsl_version"":1,""steps"":[...]}. Без пояснений и без Markdown.";
	
	Возврат Промпт;
	
КонецФункции

// Формирует промпт для проверки выполнения задачи
//
// Параметры:
//  ТекстЗадачи - Строка - исходная задача пользователя
//  ТекстРезультатов - Строка - результаты выполнения (системные сообщения)
//
// Возвращаемое значение:
//  Строка - текст промпта
//
Функция СформироватьПромптПроверкиЗадачи(ТекстЗадачи, ТекстРезультатов) Экспорт
	
	Промпт = "Проверь, выполнена ли задача пользователя." + Символы.ПС +
	"Задача: " + ТекстЗадачи + Символы.ПС +
	"Результаты выполнения: " + Символы.ПС + ТекстРезультатов + Символы.ПС +
	"Правила ответа:" + Символы.ПС +
	"- Верни ТОЛЬКО валидный DSL JSON с оберткой {""dsl_version"":1,""steps"":[...]}." + Символы.ПС +
	"- Используй ровно один шаг ShowInfo." + Символы.ПС +
	"- В message напиши 'Да: ...' если задача выполнена, иначе 'Нет: ...'." + Символы.ПС +
	"- Не используй Markdown и дополнительный текст.";
	
	Возврат Промпт;
	
КонецФункции

// Формирует промпт для генерации резюме (summary)
//
// Параметры:
//  ТекстЗадач - Строка - текст задач
//  ТекстИзмененныхОбъектов - Строка - список измененных объектов
//  ТекстРезультатовDSL - Строка - результаты выполнения DSL
//
// Возвращаемое значение:
//  Строка - текст промпта
//
Функция СформироватьПромптРезюме(ТекстЗадач, ТекстИзмененныхОбъектов, ТекстРезультатовDSL) Экспорт
	
	Промпт = "Сгенерируй краткое резюме (summary) выполненной работы." + Символы.ПС +
	"Задачи пользователя: " + ТекстЗадач + Символы.ПС +
	"Результаты выполнения действий: " + Символы.ПС + ТекстРезультатовDSL + Символы.ПС +
	ТекстИзмененныхОбъектов + Символы.ПС +
	"Опиши, что было сделано, какие объекты созданы или изменены. Если были ошибки, укажи их. Будь краток и конкретен." + Символы.ПС +
	"ВАЖНО: Пиши ТОЛЬКО текст резюме для пользователя. НЕ используй JSON, НЕ используй Markdown блоки кода.";
	
	Возврат Промпт;
	
КонецФункции

// Формирует промпт для исправления DSL-сценария
//
// Параметры:
//  ТекстОшибки - Строка - текст ошибки
//  ИсходныйDSL - Строка - исходный DSL-сценарий
//
// Возвращаемое значение:
//  Строка - текст промпта
//
Функция ПолучитьПромптИсправленияDSL(ТекстОшибки, ИсходныйDSL, ДоступныеПоля = "") Экспорт
	
	Промпт = "Твой предыдущий DSL-сценарий выполнился с ошибкой." + Символы.ПС +
	"Ошибка: " + ТекстОшибки + Символы.ПС +
	"Исходный DSL: " + ИсходныйDSL + Символы.ПС;
	
	Если НЕ ПустаяСтрока(ДоступныеПоля) Тогда
		Промпт = Промпт + "ДОСТУПНЫЕ ПОЛЯ (из GetObjectFields - используй ТОЛЬКО их в RunQuery):" + Символы.ПС +
		ДоступныеПоля + Символы.ПС +
		"Исправь запрос: замени несуществующее поле на одно из полей выше или убери его из запроса." + Символы.ПС;
	Иначе
		Промпт = Промпт + "Если ошибка в имени поля или объекта, используй GetMetadata или GetObjectFields для уточнения." + Символы.ПС;
	КонецЕсли;
	
	Промпт = Промпт + "Ответ: только валидный JSON объект DSL вида {""dsl_version"":1,""steps"":[...]}.";
	
	Возврат Промпт;
	
КонецФункции

// Возвращает промпт для извлечения сущностей метаданных из запроса
//
// Параметры:
//  ТекстЗапроса - Строка - запрос пользователя
//
// Возвращаемое значение:
//  Строка - текст промпта
//
Функция ПолучитьПромптЭкстрактораСущностей(ТекстЗапроса) Экспорт
	
	Промпт = "Ты - эксперт по метаданным 1С. Твоя задача - выделить из фразы пользователя только названия объектов (документы, справочники, регистры)." + Символы.ПС +
	"Правила:" + Символы.ПС +
	"1. Верни только названия сущностей через запятую." + Символы.ПС +
	"2. Используй именительный падеж (например, 'Расходная накладная', а не 'расходных накладных')." + Символы.ПС +
	"3. Если сущностей нет, верни слово 'НЕТ'." + Символы.ПС +
	"4. Игнорируй глаголы (найти, покажи), даты (апрель, 2022) и количества (сколько)." + Символы.ПС +
	"5. Не пиши ничего, кроме названий объектов." + Символы.ПС +
	"" + Символы.ПС +
	"Фраза пользователя: '" + ТекстЗапроса + "'";
	
	Возврат Промпт;
	
КонецФункции

// Формирует блок контекста на основе результатов RAG-поиска
//
// Параметры:
//  ТекстЗапроса - Строка - исходный запрос пользователя
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - (опционально) ссылка на диалог для логирования
//
// Возвращаемое значение:
//  Строка - блок контекста
//
Функция СформироватьКонтекстRAG(Знач ТекстЗапроса, Знач СсылкаДиалога = Неопределено) Экспорт
	
	Если ПустаяСтрока(ТекстЗапроса) Тогда
		Возврат "";
	КонецЕсли;
	
	// Сначала пробуем извлечь сущности через ИИ
	Сущности = ИИА_Сервер.ИзвлечьСущностиДляRAG(ТекстЗапроса, СсылкаДиалога);
	
	// Если ИИ что-то извлек, ищем по сущностям, иначе по всему тексту
	ТекстДляПоиска = ?(ПустаяСтрока(Сущности), ТекстЗапроса, Сущности);
	
	// Выполняем поиск в индексе (Top-5 для контекста достаточно)
	РезультатыПоиска = ИИА_RAG_Поиск.ВыполнитьПоиск(ТекстДляПоиска, 5, , СсылкаДиалога);
	
	Если РезультатыПоиска.Количество() = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	ТекстКонтекста = "ПОДСКАЗКА ПО МЕТАДАННЫМ (RAG):" + Символы.ПС;
	Если НЕ ПустаяСтрока(Сущности) Тогда
		ТекстКонтекста = ТекстКонтекста + "(Поиск по ключевым сущностям: " + Сущности + ")" + Символы.ПС;
	КонецЕсли;
	ТекстКонтекста = ТекстКонтекста + "На основе твоего запроса в базе найдены следующие релевантные объекты:" + Символы.ПС;
	
	Для Каждого Результат Из РезультатыПоиска Цикл
		
		ТипРус = Результат.Тип;
		ТипРус = СтрЗаменить(ТипРус, "Document", "Документ");
		ТипРус = СтрЗаменить(ТипРус, "Catalog", "Справочник");
		ТипРус = СтрЗаменить(ТипРус, "Enum", "Перечисление");
		ТипРус = СтрЗаменить(ТипРус, "InfoReg", "РегистрСведений");
		ТипРус = СтрЗаменить(ТипРус, "AccumReg", "РегистрНакопления");
		
		ОписаниеОбъекта = СтрШаблон("- %1.%2 (%3)", ТипРус, Результат.Имя, Результат.Синоним);
		ТекстКонтекста = ТекстКонтекста + ОписаниеОбъекта + Символы.ПС;
		
		// Получаем краткий контекст (реквизиты/ТЧ) для Top-1 результата
		Если Результат.Rank = 1 Тогда
			ДанныеЧанка = ИИА_RAG_Поиск.ПолучитьКонтекст(Результат.КлючЧанка);
			Если ДанныеЧанка <> Неопределено И НЕ ПустаяСтрока(ДанныеЧанка.Текст) Тогда
				// Добавляем только первые 300 символов описания полей, чтобы не раздувать промпт
				КраткийТекст = Лев(ДанныеЧанка.Текст, 300);
				ТекстКонтекста = ТекстКонтекста + "  (Поля: " + КраткийТекст + "...)" + Символы.ПС;
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	ТекстКонтекста = ТекстКонтекста + "ИСПОЛЬЗУЙ ЭТИ ИМЕНА ОБЪЕКТОВ В СВОЕМ ПЛАНЕ И DSL-СЦЕНАРИЯХ." + Символы.ПС;
	
	Возврат ТекстКонтекста;
	
КонецФункции

// Получает текст системного промпта
Функция ПолучитьТекстСистемногоПромпта(ТипДиалога)
	
	// Если это агент, формируем специальный промпт
	Если ТипДиалога = Перечисления.ИИА_ТипДиалога.Агент Тогда
		Возврат ПолучитьТекстПромпта_Агент();
	ИначеЕсли ТипДиалога = Перечисления.ИИА_ТипДиалога.Запрос1С Тогда
		Возврат ПолучитьТекстПромпта_Запрос1С();
	Иначе
		// Стандартный промпт для чата/кода
		Возврат "Ты - полезный AI-ассистент, встроенный в 1С:Предприятие. Твоя задача - помогать пользователю, отвечать на вопросы и генерировать код 1С.";
	КонецЕсли;
	
КонецФункции

// Внутренняя функция формирования системного промпта для Агента
Функция ПолучитьТекстПромпта_Агент()
	
	СистемныйПромпт =
	"Ты - агент 1С:Предприятие, выполняющий задачи через DSL (JSON)." + Символы.ПС +
	"Формат ответа: всегда следуй ТРЕБУЕМОМУ контракту формата ответа из текущей инструкции (ожидаемый формат задаётся системой). " +
	"Никакого текста вне JSON." + Символы.ПС +
	"Правила: только двойные кавычки (""); без Markdown; строки-константы (нельзя +, функции, вычисления внутри JSON); #(Var) только для переменных контекста, не для констант." + Символы.ПС +
	"СТРАТЕГИЯ DISCOVERY (ОБЯЗАТЕЛЬНО):" + Символы.ПС +
	"- ТЕБЕ ДОСТУПЕН RAG-ПОИСК: В сообщениях системы может быть блок 'ПОДСКАЗКА ПО МЕТАДАННЫМ (RAG)'. Всегда отдавай приоритет именам объектов и полям из этого блока." + Символы.ПС +
		"- ЕСЛИ CheckObjectExists ВЕРНУЛ 'не существует' или GetMetadata/GetObjectFields вернул список: в блоке RAG или в фактах уже есть объекты из базы. ИСПОЛЬЗУЙ подходящий (например Документ.РасходнаяНакладная вместо РеализацияТоваровУслуг) и ВЫПОЛНИ RunQuery для него. НЕ показывай ShowInfo «Данные не найдены» пока не попробовал альтернативу." + Символы.ПС +
		"- НИКОГДА не делай предположений о названиях документов или справочников. Если RAG не дал подсказку — СНАЧАЛА используй GetMetadata или CheckObjectExists." + Символы.ПС +
	"- ЗАПРЕЩЕНО запрашивать полные списки метаданных без фильтра. Всегда используй GetMetadata{filter: '...'} для сужения поиска." + Символы.ПС +
	"- Если твой поиск по фильтру (например, 'Реализация') ничего не нашел, ты ОБЯЗАН самостоятельно подобрать синонимы (например, 'Продажа', 'Расход', 'Отгрузка') и выполнить повторный GetMetadata с новым фильтром." + Символы.ПС +
	"- ЦЕПОЧКА ДЕЙСТВИЙ: Ошибка -> GetMetadata (поиск замены) -> ВЫБОР ОБЪЕКТА ИЗ СПИСКА -> GetObjectFields (проверка полей) -> RunQuery. НЕ перескакивай шаги и не возвращайся к неверным именам." + Символы.ПС +
	"- Если в сообщении системы есть блок '!!! КРИТИЧЕСКАЯ ПОДСКАЗКА !!!' или 'ИНФО: Я уже выполнил GetObjectFields', ты НЕ ИМЕЕШЬ ПРАВА завершать работу или переключаться на другие задачи. Ты ОБЯЗАН использовать эти данные для RunQuery." + Символы.ПС +
	"- Если ты получил список метаданных, и в нем есть похожие объекты, ты ОБЯЗАН выбрать один из них для следующего шага. Остановка работы без попытки использовать замену считается провалом." + Символы.ПС +
	"- ЗАПРЕЩЕНО использовать плейсхолдеры {Поле} в ShowInfo, если в текущей истории нет успешного RunQuery, вернувшего это поле. Если данных нет - пиши 'Данные не найдены'." + Символы.ПС +
	"- Если RunQuery вернул ошибку, проанализируй её текст. Если ошибка в имени поля - используй GetObjectFields. Не повторяй один и тот же ошибочный запрос." + Символы.ПС +
	"- Для получения последней записи всегда используй 'ВЫБРАТЬ ПЕРВЫЕ 1 ... УПОРЯДОЧИТЬ ПО Дата УБЫВ' вместо сложных подзапросов с МАКСИМУМ в условии ГДЕ." + Символы.ПС +
	"- ВАЖНО ПО ДАТАМ В ЗАПРОСАХ: Функции ГОД(), МЕСЯЦ(), ДЕНЬ() в 1С работают ТОЛЬКО с полями БД. Нельзя писать ГОД(&Параметр) - это вызовет ошибку. Для фильтра по периоду используй: 'Дата МЕЖДУ &НачалоПериода И &КонецПериода'." + Символы.ПС +
	"Действия (action) и ключевые параметры:" + Символы.ПС +
	"- RunQuery{query,parameters?}; ShowInfo{message}; GetMetadata{metadata_type?}; GetObjectFields{object_type,object_name}; CheckObjectExists{object_type,object_name};" + Символы.ПС +
	"- CreateReference{object_type,object_name,name?}; CreateDocument{object_name,data?}; FindReferenceByGUID{object_type,object_name,guid} — guid ТОЛЬКО строка UUID (например ""a1b2c3d4-e5f6-7890-abcd-ef1234567890""), НЕ текст результата и НЕ #(Var:...); SelectObject{reference} или {object_type,object_name,name}; SetField{field_name,value}; Write{posting_mode?}; Delete{};" + Символы.ПС +
	"- ForEach{collection,steps}; SaveToStorage{key,data}.";
	
	Возврат СистемныйПромпт;
	
КонецФункции

// Внутренняя функция формирования системного промпта для Запрос1С
Функция ПолучитьТекстПромпта_Запрос1С()
	
	СистемныйПромпт =
	"Ты - эксперт по языку запросов 1С:Предприятие." + Символы.ПС +
	"Твоя задача - составлять и выполнять запросы к базе данных для получения информации." + Символы.ПС +
	"Используй ТОЛЬКО язык запросов 1С (ВЫБРАТЬ ... ИЗ ...)." + Символы.ПС +
	"Если имена таблиц или полей неизвестны, СНАЧАЛА используй GetMetadata и GetObjectFields." + Символы.ПС +
	"Результат выводи через ShowInfo в понятном пользователю виде.";
	
	Возврат СистемныйПромпт;
	
КонецФункции

#КонецОбласти
