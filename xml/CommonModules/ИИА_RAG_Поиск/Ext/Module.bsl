// Модуль для выполнения поиска по индексу метаданных

// Выполняет поиск по текстовому запросу и возвращает результат в виде JSON-строки.
// Предназначено для вызова через COM (automation/rag_search.py).
//
// Параметры:
//  ЗапросТекст - Строка - Поисковый запрос (напр. "остатки склад", "запасы склад")
//  TopK - Число - Количество возвращаемых результатов (по умолчанию 10)
//
// Возвращаемое значение:
//  Строка - JSON-массив объектов {Rank, Score, Тип, Имя, Синоним, Путь}
//
Функция ВыполнитьПоискПоТексту(Знач ЗапросТекст, Знач TopK = 10) Экспорт
	
	Результаты = ВыполнитьПоиск(ЗапросТекст, TopK, , Неопределено);
	Массив = Новый Массив;
	Для Каждого Строка Из Результаты Цикл
		Элемент = Новый Структура;
		Элемент.Вставить("Rank", Строка.Rank);
		Элемент.Вставить("Score", Строка.Score);
		Элемент.Вставить("Тип", Строка.Тип);
		Элемент.Вставить("Имя", Строка.Имя);
		Элемент.Вставить("Синоним", Строка.Синоним);
		Элемент.Вставить("Путь", Строка.Путь);
		Массив.Добавить(Элемент);
	КонецЦикла;
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, Массив);
	Возврат ЗаписьJSON.Закрыть();
	
КонецФункции

// Выполняет поиск по текстовому запросу
//
// Параметры:
//  ЗапросТекст - Строка - Поисковый запрос пользователя
//  TopK - Число - Количество возвращаемых результатов
//  Контекст - Структура - Дополнительный контекст для бустинга (ActiveObjectName, ActiveSection)
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - (опционально) ссылка на диалог для логирования
//
// Возвращаемое значение:
//  ТаблицаЗначений - Результаты поиска (Rank, Score, Тип, Имя, Синоним, Путь, КлючЧанка, Причины)
Функция ВыполнитьПоиск(Знач ЗапросТекст, Знач TopK = 10, Знач Контекст = Неопределено, Знач СсылкаДиалога = Неопределено) Экспорт
	
	Результаты = СформироватьТаблицуРезультатов();
	
	Если ПустаяСтрока(ЗапросТекст) Тогда
		Возврат Результаты;
	КонецЕсли;
	
	// Нормализация английских имен типов в русские для ИИ
	ЗапросТекст = СтрЗаменить(ЗапросТекст, "Document", "Документ");
	ЗапросТекст = СтрЗаменить(ЗапросТекст, "Catalog", "Справочник");
	ЗапросТекст = СтрЗаменить(ЗапросТекст, "Enum", "Перечисление");
	ЗапросТекст = СтрЗаменить(ЗапросТекст, "InfoReg", "РегистрСведений");
	ЗапросТекст = СтрЗаменить(ЗапросТекст, "AccumReg", "РегистрНакопления");
	
	// 1. Подготовка запроса
	СтопСлова = ИИА_RAG_Настройки.ПолучитьСтопСлова();
	Синонимы  = ИИА_RAG_Настройки.ПолучитьСинонимы();
	
	// Логируем входящий запрос для отладки
	ИИА_Сервер.ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "[RAG_SEARCH] Запрос: " + ЗапросТекст);
	
	НормЗапрос = ИИА_RAG_Текст.Нормализовать(ЗапросТекст);
	ТокеныЗапроса = ИИА_RAG_Текст.Токенизировать(НормЗапрос, СтопСлова);
	
	Если ТокеныЗапроса.Количество() = 0 Тогда
		ИИА_Сервер.ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "[RAG_SEARCH] Токены не найдены после нормализации.");
		Возврат Результаты;
	КонецЕсли;
	
	// Query Expansion (расширение синонимами)
	ВсеТокены = Новый Массив;
	Для каждого Токен Из ТокеныЗапроса Цикл
		ВсеТокены.Добавить(Токен);
		СписокСинонимов = Синонимы[Токен];
		Если СписокСинонимов <> Неопределено Тогда
			Для каждого Синоним Из СписокСинонимов Цикл
				Если ВсеТокены.Найти(Синоним) = Неопределено Тогда
					ВсеТокены.Добавить(Синоним);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	// 2. Поиск кандидатов и расчет базового Score (BM25-lite)
	// Score = sum(IDF * TF)
	Кандидаты = Новый Соответствие; // КлючЧанка -> Число (Score)
	Причины   = Новый Соответствие; // КлючЧанка -> Массив строк
	
	// Таблица токенов для одного запроса (избегаем CreateQueryInCycle)
	ТаблицаТокенов = Новый ТаблицаЗначений;
	ТаблицаТокенов.Колонки.Добавить("Токен", Новый ОписаниеТипов("Строка"));
	Для каждого Токен Из ВсеТокены Цикл
		СтрокаТокен = ТаблицаТокенов.Добавить();
		СтрокаТокен.Токен = Токен;
	КонецЦикла;
	
	// Получаем IDF для всех токенов
	СоответствиеIDF = Новый Соответствие;
	Для каждого Токен Из ВсеТокены Цикл
		IDF = ПолучитьIDF(Токен);
		Если IDF > 0 Тогда
			СоответствиеIDF.Вставить(Токен, IDF);
		КонецЕсли;
	КонецЦикла;
	
	Если СоответствиеIDF.Количество() = 0 Тогда
		ИИА_Сервер.ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "[RAG_SEARCH] Нет токенов с IDF > 0.");
		Возврат Результаты;
	КонецЕсли;
	
	// Пакетный запрос: таблица значений -> временная таблица, затем JOIN
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	ВЫРАЗИТЬ(Т.Токен КАК Строка(64)) КАК Токен
	|ПОМЕСТИТЬ ТокеныВТЧ
	|ИЗ
	|	&ТаблицаТокенов КАК Т
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ИИА_ТокенИндекс.КлючЧанка КАК КлючЧанка,
	|	ИИА_ТокенИндекс.Токен КАК Токен,
	|	ИИА_ТокенИндекс.TF КАК TF
	|ИЗ
	|	РегистрСведений.ИИА_ТокенИндекс КАК ИИА_ТокенИндекс
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ТокеныВТЧ КАК Токены
	|		ПО ИИА_ТокенИндекс.Токен = Токены.Токен");
	
	Запрос.УстановитьПараметр("ТаблицаТокенов", ТаблицаТокенов);
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Токен = Выборка.Токен;
		Ключ = Выборка.КлючЧанка;
		IDF = СоответствиеIDF[Токен];
		Если IDF = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		// Коэффициенты веса
		Коэфф = 1.0;
		
		// Понижающий коэффициент для стемов (s:...)
		Если Лев(Токен, 2) = "s:" Тогда
			Коэфф = Коэфф * 0.5;
		КонецЕсли;
		
		// Бонус за точное совпадение с оригинальным запросом (не синоним и не стем)
		Если ТокеныЗапроса.Найти(Токен) <> Неопределено Тогда
			Коэфф = Коэфф * 1.5;
		КонецЕсли;
		
		Score = IDF * Выборка.TF * Коэфф;
		
		Кандидаты.Вставить(Ключ, ?(Кандидаты[Ключ] = Неопределено, Score, Кандидаты[Ключ] + Score));
		
		// Сохраняем причину
		МассивПричин = Причины[Ключ];
		Если МассивПричин = Неопределено Тогда
			МассивПричин = Новый Массив;
			Причины.Вставить(Ключ, МассивПричин);
		КонецЕсли;
		МассивПричин.Добавить("токен:" + Токен);
		
	КонецЦикла;
	
	Если Кандидаты.Количество() = 0 Тогда
		ИИА_Сервер.ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "[RAG_SEARCH] Кандидаты не найдены в индексе.");
		Возврат Результаты;
	КонецЕсли;
	
	// 3. Дополнительное ранжирование (Бонусы)
	КлючиКандидатов = Новый Массив;
	Для каждого Пара Из Кандидаты Цикл
		КлючиКандидатов.Добавить(Пара.Ключ);
	КонецЦикла;
	
	// Получаем детали чанков пачкой
	ДеталиЧанков = ПолучитьДеталиЧанков(КлючиКандидатов);
	
	ИмяКонфигурации = Метаданные.Имя;
	ИдКонфигурации = ИИА_ЯдроМетаданных.ОпределитьИдКонфигурации(ИмяКонфигурации);
	ИИА_Сервер.ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "[RAG_SEARCH] Конфигурация: " + ИмяКонфигурации + " -> ядро: " + ИдКонфигурации);
	
	Для каждого СтрДетали Из ДеталиЧанков Цикл
		
		Ключ = СтрДетали.КлючЧанка;
		Бонус = 0;
		КоэффициентТипа = 1.0;
		
		// 1. Бустинг по типам объектов
		Если СтрДетали.Тип = "Document" Тогда
			КоэффициентТипа = 2.0; // Еще сильнее поднимаем документы
		ИначеЕсли СтрДетали.Тип = "Catalog" Или СтрДетали.Тип = "Report" Или СтрДетали.Тип = "DataProcessor" Тогда
			КоэффициентТипа = 1.5;
		ИначеЕсли СтрДетали.Тип = "Enum" Тогда
			КоэффициентТипа = 0.05; // Перечисления почти в ноль, если нет точного совпадения
		КонецЕсли;
		
	// 2. Пессимизация технического мусора
		Если Найти(СтрДетали.Имя, "ПрисоединенныеФайлы") > 0 
			Или Найти(СтрДетали.Имя, "Изменения") > 0 
			Или Найти(СтрДетали.Имя, "НаборыЗначений") > 0
			Или Найти(СтрДетали.Имя, "ИИА_") > 0 Тогда
			КоэффициентТипа = КоэффициентТипа * 0.01; // Радикально понижаем (был 0.1)
		КонецЕсли;
		
		// Пессимизация электронных документов (технический обмен), если в запросе нет слова "электронный"
		Если (Найти(СтрДетали.Имя, "Электронн") > 0 Или Найти(СтрДетали.Синоним, "Электронн") > 0) 
			И Найти(ВРег(ЗапросТекст), "ЭЛЕКТРОН") = 0 Тогда
			КоэффициентТипа = КоэффициентТипа * 0.3;
		КонецЕсли;
		
		// Пессимизация ЕГАИС/ВЕТИС/САТУРН, если в запросе нет этих слов
		ЗапросВРег = ВРег(ЗапросТекст);
		Если (Найти(СтрДетали.Имя, "ЕГАИС") > 0 Или Найти(СтрДетали.Имя, "ВЕТИС") > 0 Или Найти(СтрДетали.Имя, "САТУРН") > 0)
			И Найти(ЗапросВРег, "ЕГАИС") = 0 И Найти(ЗапросВРег, "ВЕТИС") = 0 И Найти(ЗапросВРег, "САТУРН") = 0 Тогда
			КоэффициентТипа = КоэффициентТипа * 0.2;
		КонецЕсли;
		// Пессимизация ЗЕРНО и МП в конце имени (ОстаткиПартийЗЕРНО, ОстаткиТоваровМП и т.п.), если в запросе нет этих слов
		ИмяВРег = ВРег(СтрДетали.Имя);
		ЗапросСодержитЗерно = Найти(ЗапросВРег, "ЗЕРНО") > 0;
		ЗапросСодержитМП = Найти(ЗапросВРег, "МАРКЕТПЛЕЙС") > 0 Или Найти(ЗапросВРег, " МП") > 0 Или Найти(ЗапросВРег, "МП ") > 0 Или Лев(ЗапросВРег, 2) = "МП";
		Если (Прав(ИмяВРег, 5) = "ЗЕРНО" Или Прав(ИмяВРег, 2) = "МП") И НЕ ЗапросСодержитЗерно И НЕ ЗапросСодержитМП Тогда
			КоэффициентТипа = КоэффициентТипа * 0.2;
		КонецЕсли;
		// Пессимизация Прослеживаемые*, если в запросе нет прослежива/ЕАЭС
		ЗапросСодержитПрослежива = Найти(ЗапросВРег, "ПРОСЛЕЖИВ") > 0 Или Найти(ЗапросВРег, "ЕАЭС") > 0;
		Если Найти(ИмяВРег, "ПРОСЛЕЖИВ") > 0 И НЕ ЗапросСодержитПрослежива Тогда
			КоэффициентТипа = КоэффициентТипа * 0.2;
		КонецЕсли;

		НормИмя = ИИА_RAG_Текст.Нормализовать(СтрДетали.Имя);
		НормСиноним = ИИА_RAG_Текст.Нормализовать(СтрДетали.Синоним);
		
		// 2a. Буст регистров остатков/запасов при запросе про остатки, запасы, склад
		// Только объекты с запас/остат/склад в имени, исключая Прослеживаемые*
		ЗапросНорм = ВРег(НормЗапрос);
		ЗапросПРОстатки = (Найти(ЗапросНорм, "ОСТАТК") > 0 Или Найти(ЗапросНорм, "ЗАПАС") > 0 Или Найти(ЗапросНорм, "СКЛАД") > 0);
		ОбъектРегистрОстатков = (СтрДетали.Тип = "AccumReg") И (Найти(НормИмя, "запас") > 0 Или Найти(НормИмя, "остат") > 0 Или Найти(НормИмя, "склад") > 0) И Найти(НормИмя, "прослежива") = 0;
		Если ЗапросПРОстатки И ОбъектРегистрОстатков Тогда
			Бонус = Бонус + 3500;
			Причины[Ключ].Добавить("ядро:остатки");
		КонецЕсли;
		
		// 2b. Буст AccumReg.Продажи при запросе про продажи, динамика
		ЗапросПРОпродажи = (Найти(ЗапросНорм, "ПРОДАЖ") > 0 Или Найти(ЗапросНорм, "ДИНАМИК") > 0);
		ОбъектРегистрПродаж = (СтрДетали.Тип = "AccumReg") И Найти(НормИмя, "продаж") > 0;
		Если ЗапросПРОпродажи И ОбъектРегистрПродаж Тогда
			Бонус = Бонус + 3500;
			Причины[Ключ].Добавить("ядро:продажи");
		КонецЕсли;
		
		// 2c. Буст InfoReg с «цены» при запросе про цены
		ЗапросПРОцены = (Найти(ЗапросНорм, "ЦЕН") > 0);
		ОбъектРегистрЦен = (СтрДетали.Тип = "InfoReg") И Найти(НормИмя, "цен") > 0;
		Если ЗапросПРОцены И ОбъектРегистрЦен Тогда
			Бонус = Бонус + 3500;
			Причины[Ключ].Добавить("ядро:цены");
		КонецЕсли;
		
		// 3. Бонус за количество совпавших уникальных токенов (Multi-token match)
		// Считаем только уникальные токены, игнорируя технические слова типа "документ"
		КоличествоТокенов = 0;
		МассивПричин = Причины[Ключ];
		УникальныеТокены = Новый Соответствие;
		Для каждого СтрПричины Из МассивПричин Цикл
			Если Лев(СтрПричины, 6) = "токен:" Тогда
				ТекТокен = Сред(СтрПричины, 7);
				// Игнорируем шум
				Если ТекТокен = "документ" Или ТекТокен = "s:документ" 
					Или ТекТокен = "текущий" Или ТекТокен = "s:текущ" Тогда
					Продолжить;
				КонецЕсли;
				УникальныеТокены.Вставить(ТекТокен, Истина);
			КонецЕсли;
		КонецЦикла;
		
		КоличествоТокенов = УникальныеТокены.Количество();
		Если КоличествоТокенов > 1 Тогда
			// Экспоненциальный бонус за совпадение нескольких значимых слов
			Бонус = Бонус + (Pow(КоличествоТокенов, 2) * 150); 
		КонецЕсли;
		
		// 4. Проверка вхождения всех значимых токенов запроса (Full Match Bonus)
		КоличествоСовпавших = 0;
		ЗначимыеТокены = Новый Массив;
		Для каждого Т Из ТокеныЗапроса Цикл
			// Игнорируем технические слова при проверке полноты совпадения
			Если Т = "документ" Или Т = "текущий" Или СтрДлина(Т) < 3 Тогда Продолжить; КонецЕсли;
			ЗначимыеТокены.Добавить(Т);
			
			Если Найти(НормИмя, Т) > 0 Или Найти(НормСиноним, Т) > 0 Тогда
				КоличествоСовпавших = КоличествоСовпавших + 1;
				
				// Дополнительный бонус, если имя НАЧИНАЕТСЯ с одного из токенов запроса
				Если Лев(НормИмя, СтрДлина(Т)) = Т Или Лев(НормСиноним, СтрДлина(Т)) = Т Тогда
					Бонус = Бонус + 100;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		Если ЗначимыеТокены.Количество() > 0 И КоличествоСовпавших = ЗначимыеТокены.Количество() Тогда
			Бонус = Бонус + 1500; // Еще более гигантский бонус за полное совпадение
			Причины[Ключ].Добавить("совпадение:полное");
		КонецЕсли;
		
		// 5. Бонус за точное совпадение фразы в имени или синониме
		// Ищем без слова "документ", если оно есть в запросе
		ЧистыйЗапрос = СтрЗаменить(НормЗапрос, "документ", "");
		ЧистыйЗапрос = СокрЛП(ЧистыйЗапрос);
		
		Если НЕ ПустаяСтрока(ЧистыйЗапрос) Тогда
			Если Найти(НормИмя, ЧистыйЗапрос) > 0 Тогда
				Бонус = Бонус + 500; 
				Причины[Ключ].Добавить("совпадение:имя");
			КонецЕсли;
			
			Если Найти(НормСиноним, ЧистыйЗапрос) > 0 Тогда
				Бонус = Бонус + 600;
				Причины[Ключ].Добавить("совпадение:синоним");
			КонецЕсли;
		КонецЕсли;
		
		// 5a. Бустинг: синоним запроса присутствует в имени/синониме объекта (например «расходная» в «Расходная накладная» при запросе «реализация»)
		НайденоСовпадениеСиноним = Ложь;
		Для Каждого ТокенЗапроса Из ТокеныЗапроса Цикл
			Если НайденоСовпадениеСиноним Тогда
				Прервать;
			КонецЕсли;
			СписокСинонимов = Синонимы[ТокенЗапроса];
			Если СписокСинонимов <> Неопределено Тогда
				Для Каждого СинонимТокен Из СписокСинонимов Цикл
					Если СтрДлина(СинонимТокен) >= 4 И (Найти(НормИмя, СинонимТокен) > 0 Или Найти(НормСиноним, СинонимТокен) > 0) Тогда
						Бонус = Бонус + 400;
						Причины[Ключ].Добавить("совпадение:синоним_в_объекте");
						НайденоСовпадениеСиноним = Истина;
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
		
		// 6. Контекстный бустинг
		Если Контекст <> Неопределено Тогда
			// Бустинг активного объекта
			Если Контекст.Свойство("ActiveObjectName") И Контекст.ActiveObjectName = СтрДетали.Имя Тогда
				Бонус = Бонус + 80;
				Причины[Ключ].Добавить("контекст:активный объект");
			КонецЕсли;
		КонецЕсли;
		
		// 7. Буст для объектов из ядра метаданных типовых конфигураций
		Если ИИА_ЯдроМетаданных.ОбъектВЯдре(СтрДетали.Тип, СтрДетали.Имя, ИмяКонфигурации) Тогда
			Бонус = Бонус + 2000;
			Причины[Ключ].Добавить("ядро");
		КонецЕсли;
		
		Кандидаты.Вставить(Ключ, (Кандидаты[Ключ] + Бонус) * КоэффициентТипа);
		
	КонецЦикла;
	
	// 4. Формирование финальной таблицы и сортировка
	Для каждого Пара Из Кандидаты Цикл
		
		Ключ = Пара.Ключ;
		Score = Пара.Значение;
		
		СтрДетали = ДеталиЧанков.Найти(Ключ, "КлючЧанка");
		
		НоваяСтрока = Результаты.Добавить();
		НоваяСтрока.Score = Score;
		НоваяСтрока.КлючЧанка = Ключ;
		
		Если СтрДетали <> Неопределено Тогда
			НоваяСтрока.Тип = СтрДетали.Тип;
			НоваяСтрока.Имя = СтрДетали.Имя;
			НоваяСтрока.Синоним = СтрДетали.Синоним;
			НоваяСтрока.Путь = СтрДетали.Путь;
		КонецЕсли;
		
		НоваяСтрока.Причины = СтрСоединить(Причины[Ключ], "; ");
		
	КонецЦикла;
	
	Результаты.Сортировать("Score Убыв");
	
	ИИА_Сервер.ДобавитьЗаписьВЛогДиалога(СсылкаДиалога, "[RAG_SEARCH] Найдено кандидатов: " + Результаты.Количество());
	
	// Оставляем только TopK и проставляем Rank
	Пока Результаты.Количество() > TopK Цикл
		Результаты.Удалить(Результаты.Количество() - 1);
	КонецЦикла;
	
	Для Индекс = 0 По Результаты.Количество() - 1 Цикл
		Результаты[Индекс].Rank = Индекс + 1;
	КонецЦикла;
	
	Возврат Результаты;
	
КонецФункции

// Возвращает структуру с данными чанка для отображения пользователю или передачи в LLM
//
// Параметры:
//  КлючЧанка - Строка - Идентификатор чанка
//
// Возвращаемое значение:
//  Структура - Данные чанка (Заголовок, Текст, Путь, Тип)
Функция ПолучитьКонтекст(Знач КлючЧанка) Экспорт
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	ИИА_Чанки.Тип КАК Тип,
	|	ИИА_Чанки.Имя КАК Имя,
	|	ИИА_Чанки.Синоним КАК Синоним,
	|	ИИА_Чанки.Путь КАК Путь,
	|	ИИА_Чанки.Текст КАК Текст
	|ИЗ
	|	РегистрСведений.ИИА_Чанки КАК ИИА_Чанки
	|ГДЕ
	|	ИИА_Чанки.КлючЧанка = &КлючЧанка");
	
	Запрос.УстановитьПараметр("КлючЧанка", КлючЧанка);
	Выполнение = Запрос.Выполнить();
	
	Если Выполнение.Пустой() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Выборка = Выполнение.Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Результат.Вставить("Тип", Выборка.Тип);
	Результат.Вставить("Имя", Выборка.Имя);
	Результат.Вставить("Синоним", Выборка.Синоним);
	Результат.Вставить("Путь", Выборка.Путь);
	
	Текст = "";
	Если ТипЗнч(Выборка.Текст) = Тип("ХранилищеЗначения") Тогда
		Текст = Выборка.Текст.Получить();
	КонецЕсли;
	Результат.Вставить("Текст", Текст);
	
	Результат.Вставить("Заголовок", СтрШаблон("%1: %2 (%3)", Выборка.Тип, Выборка.Синоним, Выборка.Имя));
	
	Возврат Результат;
	
КонецФункции

// Вспомогательные функции

Функция СформироватьТаблицуРезультатов()
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Rank", Новый ОписаниеТипов("Число"));
	Таблица.Колонки.Добавить("Score", Новый ОписаниеТипов("Число"));
	Таблица.Колонки.Добавить("Тип", Новый ОписаниеТипов("Строка"));
	Таблица.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
	Таблица.Колонки.Добавить("Синоним", Новый ОписаниеТипов("Строка"));
	Таблица.Колонки.Добавить("Путь", Новый ОписаниеТипов("Строка"));
	Таблица.Колонки.Добавить("КлючЧанка", Новый ОписаниеТипов("Строка"));
	Таблица.Колонки.Добавить("Причины", Новый ОписаниеТипов("Строка"));
	
	Возврат Таблица;
	
КонецФункции

Функция ПолучитьIDF(Токен)
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	ИИА_ТокенСтатистика.IDF КАК IDF
	|ИЗ
	|	РегистрСведений.ИИА_ТокенСтатистика КАК ИИА_ТокенСтатистика
	|ГДЕ
	|	ИИА_ТокенСтатистика.Токен = &Токен");
	
	Запрос.УстановитьПараметр("Токен", Токен);
	Выполнение = Запрос.Выполнить();
	
	Если Выполнение.Пустой() Тогда
		Возврат 0;
	КонецЕсли;
	
	Выборка = Выполнение.Выбрать();
	Выборка.Следующий();
	
	Возврат Выборка.IDF;
	
КонецФункции

Функция ПолучитьДеталиЧанков(Ключи)
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	ИИА_Чанки.КлючЧанка КАК КлючЧанка,
	|	ИИА_Чанки.Тип КАК Тип,
	|	ИИА_Чанки.Имя КАК Имя,
	|	ИИА_Чанки.Синоним КАК Синоним,
	|	ИИА_Чанки.Путь КАК Путь
	|ИЗ
	|	РегистрСведений.ИИА_Чанки КАК ИИА_Чанки
	|ГДЕ
	|	ИИА_Чанки.КлючЧанка В(&Ключи)");
	
	Запрос.УстановитьПараметр("Ключи", Ключи);
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции
