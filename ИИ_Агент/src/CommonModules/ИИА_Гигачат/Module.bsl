#Область ПрограммныйИнтерфейс

// Получает токен доступа для Гигачат (с кешированием на 30 минут)
//
// Параметры:
//  Настройки - Структура - настройки пользователя
//
// Возвращаемое значение:
//  Строка - токен доступа
//
Функция ПолучитьТокенДоступа(Настройки) Экспорт
	
	// Если токен еще действует (30 минут), возвращаем его
	// В Python коде используется: datetime.now() + timedelta(seconds=expires_at / 1000 - 60)
	// То есть токен считается действительным до expires_at минус 60 секунд
	// Сравниваем в локальном времени (так как ОкончаниеТокена хранится в локальном времени)
	ТекущееВремя = ТекущаяДата();
	
	Если ЗначениеЗаполнено(Настройки.Токен) 
		И ЗначениеЗаполнено(Настройки.ОкончаниеТокена)
		И Настройки.ОкончаниеТокена > ТекущееВремя Тогда
		// Токен еще действует
		Возврат Настройки.Токен;
	КонецЕсли;
	
	// Получаем новый токен
	Возврат ПолучитьНовыйТокенДоступа(Настройки);
	
КонецФункции

// Получает новый токен доступа через OAuth
//
// Параметры:
//  Настройки - Структура - настройки пользователя (входной/выходной)
//
// Возвращаемое значение:
//  Строка - новый токен доступа
//
Функция ПолучитьНовыйТокенДоступа(Настройки)
	
	// Проверяем наличие авторизационных данных
	Если ПустаяСтрока(Настройки.АвторизационныеДанные) Тогда
		// Если нет авторизационных данных, используем Provider_ApiKey напрямую
		Возврат Настройки.Provider_ApiKey;
	КонецЕсли;
	
	Попытка
		
		// Подключаемся к OAuth серверу
		Соединение = Новый HTTPСоединение("ngw.devices.sberbank.ru:9443", , , , , , Новый ЗащищенноеСоединениеOpenSSL());
		
		Заголовки = Новый Соответствие;
		Заголовки.Вставить("RqUID", Строка(Новый УникальныйИдентификатор));
		Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
		Заголовки.Вставить("Accept", "application/json");
		// Для получения токена используется Basic авторизация, а не Bearer!
		Заголовки.Вставить("Authorization", "Basic " + Настройки.АвторизационныеДанные);
		
		Scope = "GIGACHAT_API_PERS";
		Если НЕ ПустаяСтрока(Настройки.Scope) Тогда
			Scope = Настройки.Scope;
		КонецЕсли;
		
		Запрос = Новый HTTPЗапрос("/api/v2/oauth", Заголовки);
		Запрос.УстановитьТелоИзСтроки("scope=" + Scope);
		Результат = Соединение.ОтправитьДляОбработки(Запрос);
		
		Если Результат.КодСостояния = 200 Тогда
			
			ТекстОтвета = Результат.ПолучитьТелоКакСтроку();
			ЧтениеJson = Новый ЧтениеJson;
			ЧтениеJson.УстановитьСтроку(ТекстОтвета);
			РезСтруктура = ПрочитатьJSON(ЧтениеJson);
			ЧтениеJson.Закрыть();
			
			// Проверяем наличие access_token в ответе
			Если НЕ РезСтруктура.Свойство("access_token") Тогда
				ВызватьИсключение "В ответе OAuth отсутствует access_token. Ответ: " + ТекстОтвета;
			КонецЕсли;
			
			НовыйТокен = РезСтруктура.access_token;
			
			// Проверяем, что токен не пустой
			Если ПустаяСтрока(НовыйТокен) Тогда
				ВызватьИсключение "Получен пустой access_token. Ответ: " + ТекстОтвета;
			КонецЕсли;
			ДатаОкончания = ПреобразоватьДатуUnix(РезСтруктура.expires_at);
			
			// Сохраняем токен в настройках (если есть возможность)
			Настройки.Вставить("Токен", НовыйТокен);
			Настройки.Вставить("ОкончаниеТокена", ДатаОкончания);
			
			// Пытаемся сохранить в регистр сведений
			Попытка
				СохранитьТокенВНастройки(Настройки);
			Исключение
				// Если не удалось сохранить, продолжаем работу
			КонецПопытки;
			
			Возврат НовыйТокен;
			
		Иначе
			
			ТекстОшибки = Результат.ПолучитьТелоКакСтроку();
			ВызватьИсключение "Не удалось получить токен доступа. Код ошибки: " + Формат(Результат.КодСостояния, "ЧН=0") + " " + ТекстОшибки;
			
		КонецЕсли;
		
	Исключение
		
		// Если ошибка при получении токена, используем Provider_ApiKey напрямую
		Если НЕ ПустаяСтрока(Настройки.Provider_ApiKey) Тогда
			Возврат Настройки.Provider_ApiKey;
		Иначе
			ВызватьИсключение "Ошибка при получении токена доступа: " + ОписаниеОшибки();
		КонецЕсли;
		
	КонецПопытки;
	
КонецФункции

// Преобразует дату из формата Unix timestamp в дату 1С
//
// Параметры:
//  Значение - Число - Unix timestamp в миллисекундах (как в GigaChat API)
//
// Возвращаемое значение:
//  Дата - дата в формате 1С
//
Функция ПреобразоватьДатуUnix(Значение)
	
	Результат = Дата(1, 1, 1);
	Если ЗначениеЗаполнено(Значение) Тогда
		// GigaChat возвращает expires_at в миллисекундах как Unix timestamp (абсолютное время в UTC)
		// Преобразуем в дату 1С, вычитая 60 секунд для безопасности
		ЗначениеВСекундах = Значение / 1000 - 60;
		
		// Преобразуем Unix timestamp в дату 1С
		// Unix timestamp - это количество секунд с 1 января 1970 года 00:00:00 UTC
		// В 1С дата хранится в локальном времени
		// Вычисляем смещение часового пояса (разница между локальным и UTC)
		ТекущееЛокальное = ТекущаяДата();
		ТекущееUTC = УниверсальноеВремя(ТекущееЛокальное);
		СмещениеСекунд = ТекущееЛокальное - ТекущееUTC;
		
		// Начало эпохи Unix в UTC: 1970-01-01 00:00:00 UTC
		// Преобразуем в локальное время: прибавляем смещение часового пояса
		НачалоЭпохиUnixUTC = Дата(1970, 1, 1, 0, 0, 0);
		НачалоЭпохиUnixЛокальное = НачалоЭпохиUnixUTC + СмещениеСекунд;
		
		// Добавляем секунды Unix timestamp и получаем дату в локальном времени
		Результат = НачалоЭпохиUnixЛокальное + ЗначениеВСекундах;
		
	КонецЕсли;
	Возврат Результат;
	
КонецФункции

// Сохраняет токен в регистр сведений настроек пользователя
//
// Параметры:
//  Настройки - Структура - настройки пользователя (входной/выходной)
//
Процедура СохранитьТокенВНастройки(Настройки)
	
	// Получаем пользователя из настроек
	Если НЕ Настройки.Свойство("Пользователь") Тогда
		Возврат;
	КонецЕсли;
	
	Пользователь = Настройки.Пользователь;
	
	// Получаем набор записей
	НаборЗаписей = РегистрыСведений.ИИА_НастройкиПользователей.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Пользователь.Установить(Пользователь);
	
	// Ищем существующую запись
	НаборЗаписей.Прочитать();
	
	Если НаборЗаписей.Количество() = 0 Тогда
		// Создаем новую запись
		НоваяЗапись = НаборЗаписей.Добавить();
		НоваяЗапись.Пользователь = Пользователь;
	Иначе
		// Используем существующую запись
		НоваяЗапись = НаборЗаписей[0];
	КонецЕсли;
	
	// Обновляем токен и дату окончания
	НоваяЗапись.Токен = Настройки.Токен;
	НоваяЗапись.ОкончаниеТокена = Настройки.ОкончаниеТокена;
	
	НаборЗаписей.Записать();
	
КонецПроцедуры

// Вызывает API Гигачат
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  Настройки - Структура - настройки пользователя
//
// Возвращаемое значение:
//  Структура - структура ответа от ИИ
//
Функция ВызватьГигачат(ТипСообщения, ТекстПользователя, История, Настройки) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", "");
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	Результат.Вставить("Usage", Неопределено);
	Результат.Вставить("Ошибки", Неопределено);
	
	// Формируем URL для запроса (как в Python коде)
	URLИзНастроек = Настройки.Provider_BaseUrl;
	Если ПустаяСтрока(URLИзНастроек) Тогда
		URLИзНастроек = "https://gigachat.devices.sberbank.ru/api/v1";
	КонецЕсли;
	
	// Если в URL нет /api/v1, добавляем его
	Если СтрНайти(ВРег(URLИзНастроек), "/API/V1") = 0 Тогда
		// Убираем завершающий слеш, если есть
		Если Прав(URLИзНастроек, 1) = "/" Тогда
			URLИзНастроек = Лев(URLИзНастроек, СтрДлина(URLИзНастроек) - 1);
		КонецЕсли;
		URLИзНастроек = URLИзНастроек + "/api/v1";
	КонецЕсли;
	
	// Убираем завершающий слеш, если есть (как в Python: rstrip('/'))
	Если Прав(URLИзНастроек, 1) = "/" Тогда
		URLИзНастроек = Лев(URLИзНастроек, СтрДлина(URLИзНастроек) - 1);
	КонецЕсли;
	
	// Формируем полный URL (как в Python: f"{base_url.rstrip('/')}/chat/completions")
	ПолныйURL = URLИзНастроек + "/chat/completions";
	
	// Разделяем на домен и путь для HTTPСоединение
	// Убираем протокол https:// если есть
	URLБезПротокола = СтрЗаменить(URLИзНастроек, "https://", "");
	URLБезПротокола = СтрЗаменить(URLБезПротокола, "http://", "");
	
	// Разделяем на домен и путь для HTTPСоединение
	// В Python используется полный URL, но в 1С HTTPСоединение требует домен и путь отдельно
	ПозицияСлеша = СтрНайти(URLБезПротокола, "/");
	Если ПозицияСлеша > 0 Тогда
		БазовыйДомен = Лев(URLБезПротокола, ПозицияСлеша - 1);
		// Путь должен быть "/api/v1/chat/completions" (с начальным слешем)
		БазовыйПуть = Сред(URLБезПротокола, ПозицияСлеша);
		URLПуть = БазовыйПуть + "/chat/completions";
	Иначе
		БазовыйДомен = URLБезПротокола;
		URLПуть = "/api/v1/chat/completions";
	КонецЕсли;
	
	// Получаем токен доступа (с кешированием на 30 минут)
	// Для GigaChat API всегда нужен OAuth Access token, даже для режима "Свой ключ напрямую"
	// Если есть авторизационные данные, используем их для получения OAuth токена
	// Иначе используем Provider_ApiKey (для обратной совместимости, но это может не работать)
	Если НЕ ПустаяСтрока(Настройки.АвторизационныеДанные) Тогда
		// Используем OAuth токен (получается автоматически через авторизационные данные)
		ТокенДоступа = ПолучитьТокенДоступа(Настройки);
	ИначеЕсли НЕ ПустаяСтрока(Настройки.Provider_ApiKey) Тогда
		// Fallback: используем Provider_ApiKey напрямую (может не работать для GigaChat)
		ТокенДоступа = Настройки.Provider_ApiKey;
	Иначе
		ВызватьИсключение "Не указан Provider_ApiKey или АвторизационныеДанные для подключения к GigaChat";
	КонецЕсли;
	
	// Формируем промпт с учетом типа сообщения и типа диалога
	ТипДиалога = Неопределено;
	Если Настройки.Свойство("ТипДиалога") Тогда
		ТипДиалога = Настройки.ТипДиалога;
	КонецЕсли;
	
	Промпт = ИИА_Промты.СформироватьПромпт(ТипДиалога, ТипСообщения, ТекстПользователя, История);
	
	// Преобразуем промпт в читаемый текст для лога
	ТекстПромпта = "";
	Для Каждого Сообщение Из Промпт.Сообщения Цикл
		Роль = "";
		Если Сообщение.Свойство("role") Тогда
			Роль = Сообщение.role;
		КонецЕсли;
		Содержимое = "";
		Если Сообщение.Свойство("content") Тогда
			Содержимое = Сообщение.content;
		КонецЕсли;
		ТекстПромпта = ТекстПромпта + "[" + Роль + "]" + Символы.ПС + Содержимое + Символы.ПС + Символы.ПС;
	КонецЦикла;
	
	// Добавляем промпт в результат для вывода в лог
	Результат.Вставить("Промпт", ТекстПромпта);
	
	// Формируем тело запроса
	ТелоЗапроса = Новый Структура;
	ТелоЗапроса.Вставить("model", "GigaChat:latest");
	ТелоЗапроса.Вставить("messages", Промпт.Сообщения);
	ТелоЗапроса.Вставить("temperature", 0.7);
	ТелоЗапроса.Вставить("max_tokens", 2000);
	
	// Преобразуем в JSON
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, ТелоЗапроса);
	JSONТело = ЗаписьJSON.Закрыть();
	
	// Выполняем HTTP-запрос
	Попытка
		
		// Используем защищенное соединение OpenSSL для HTTPS
		// БазовыйДомен уже без протокола (например, "gigachat.devices.sberbank.ru")
		HTTPСоединение = Новый HTTPСоединение(БазовыйДомен, , , , , , Новый ЗащищенноеСоединениеOpenSSL());
		
		Заголовки = Новый Соответствие;
		// Host заголовок не нужен при использовании HTTPСоединение - он устанавливается автоматически
		// Заголовки.Вставить("Host", БазовыйДомен);
		Заголовки.Вставить("Content-Type", "application/json");
		Заголовки.Вставить("Accept", "application/json");
		Заголовки.Вставить("Cache-Control", "no-cache");
		
		// Для GigaChat используется формат "Bearer {токен}" для Access token
		ЗаголовокАвторизации = "Bearer " + ТокенДоступа;
		Заголовки.Вставить("Authorization", ЗаголовокАвторизации);
		
		
		HTTPЗапрос = Новый HTTPЗапрос(URLПуть, Заголовки);
		HTTPЗапрос.УстановитьТелоИзСтроки(JSONТело);
		
		HTTPОтвет = HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);
		
		Если HTTPОтвет.КодСостояния <> 200 Тогда
			
			ТекстОшибки = HTTPОтвет.ПолучитьТелоКакСтроку();
			
			// Если токен истек (401), пытаемся получить новый токен и повторить запрос
			Если HTTPОтвет.КодСостояния = 401 И (СтрНайти(ТекстОшибки, "expired") > 0 Или СтрНайти(ТекстОшибки, "Token") > 0) Тогда
				
				// Запрашиваем новый токен
				Попытка
					
					НовыйТокен = ПолучитьНовыйТокенДоступа(Настройки);
					
					// Обновляем заголовок авторизации
					Заголовки.Установить("Authorization", "Bearer " + НовыйТокен);
					
					// Повторяем запрос с новым токеном
					HTTPЗапрос = Новый HTTPЗапрос(URLПуть, Заголовки);
					HTTPЗапрос.УстановитьТелоИзСтроки(JSONТело);
					
					HTTPОтвет = HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);
					
					// Если повторный запрос тоже не удался, возвращаем ошибку
					Если HTTPОтвет.КодСостояния <> 200 Тогда
						ТекстОшибки = HTTPОтвет.ПолучитьТелоКакСтроку();
						Результат.Текст = "Ошибка API Гигачат после обновления токена: " + Формат(HTTPОтвет.КодСостояния, "ЧН=0") + " - " + ТекстОшибки;
						
						Если НЕ Результат.Свойство("Ошибки") Тогда
							Результат.Вставить("Ошибки", "");
						КонецЕсли;
						Результат.Ошибки = ТекстОшибки;
						
						Возврат Результат;
					КонецЕсли;
					
					// Если повторный запрос успешен, продолжаем обработку ответа
					
				Исключение
					
					// Если не удалось получить новый токен, возвращаем исходную ошибку
					Результат.Текст = "Ошибка API Гигачат: " + Формат(HTTPОтвет.КодСостояния, "ЧН=0") + " - " + ТекстОшибки + 
						Символы.ПС + "Не удалось обновить токен: " + ОписаниеОшибки();
					
					Если НЕ Результат.Свойство("Ошибки") Тогда
						Результат.Вставить("Ошибки", "");
					КонецЕсли;
					Результат.Ошибки = ТекстОшибки;
					
					Возврат Результат;
					
				КонецПопытки;
				
			Иначе
				
				// Для других ошибок возвращаем как обычно
				Результат.Текст = "Ошибка API Гигачат: " + Формат(HTTPОтвет.КодСостояния, "ЧН=0") + " - " + ТекстОшибки;
				
				Если НЕ Результат.Свойство("Ошибки") Тогда
					Результат.Вставить("Ошибки", "");
				КонецЕсли;
				Результат.Ошибки = ТекстОшибки;
				
				Возврат Результат;
				
			КонецЕсли;
			
		КонецЕсли;
		
		// Парсим ответ
		ТекстОтвета = HTTPОтвет.ПолучитьТелоКакСтроку();
		
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ТекстОтвета);
		ОтветJSON = ПрочитатьJSON(ЧтениеJSON);
		ЧтениеJSON.Закрыть();
		
		// Извлекаем ответ от ИИ
		Если ОтветJSON.Свойство("choices") И ОтветJSON.choices.Количество() > 0 Тогда
			
			Выбор = ОтветJSON.choices[0];
			Если Выбор.Свойство("message") И Выбор.message.Свойство("content") Тогда
				
				ТекстОтветаИИ = Выбор.message.content;
				
				// Определяем тип ответа и парсим его
				РезультатРаспознавания = ИИА_Провайдеры.РаспознатьОтветИИ(ТекстОтветаИИ, ТипСообщения);
				
				// Копируем поля из результата распознавания, сохраняя существующие поля
				Для Каждого КлючЗначение Из РезультатРаспознавания Цикл
					Результат.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЕсли;
		
		// Извлекаем информацию об использовании токенов
		Если ОтветJSON.Свойство("usage") Тогда
			
			UsageStruct = Новый Структура;
			Если ОтветJSON.usage.Свойство("prompt_tokens") Тогда
				UsageStruct.Вставить("PromptTokens", ОтветJSON.usage.prompt_tokens);
			Иначе
				UsageStruct.Вставить("PromptTokens", 0);
			КонецЕсли;
			
			Если ОтветJSON.usage.Свойство("completion_tokens") Тогда
				UsageStruct.Вставить("CompletionTokens", ОтветJSON.usage.completion_tokens);
			Иначе
				UsageStruct.Вставить("CompletionTokens", 0);
			КонецЕсли;
			
			Если ОтветJSON.usage.Свойство("total_tokens") Тогда
				UsageStruct.Вставить("TotalTokens", ОтветJSON.usage.total_tokens);
			Иначе
				UsageStruct.Вставить("TotalTokens", 0);
			КонецЕсли;
			
			UsageStruct.Вставить("ОстатокКредитов", 0); // Гигачат не возвращает информацию о балансе
			
			// Убеждаемся, что поле Usage существует
			Если НЕ Результат.Свойство("Usage") Тогда
				Результат.Вставить("Usage", Неопределено);
			КонецЕсли;
			Результат.Usage = UsageStruct;
			
		КонецЕсли;
		
	Исключение
		
		ТекстОшибки = ОписаниеОшибки();
		Результат.Текст = "Ошибка при вызове API Гигачат: " + ТекстОшибки + 
			Символы.ПС + "БазовыйДомен: " + БазовыйДомен + 
			Символы.ПС + "URLПуть: " + URLПуть;
		
		// Убеждаемся, что поле Ошибки существует
		Если НЕ Результат.Свойство("Ошибки") Тогда
			Результат.Вставить("Ошибки", "");
		КонецЕсли;
		Результат.Ошибки = ОписаниеОшибки();
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти
