#Область ПрограммныйИнтерфейс

// Получает настройки пользователя из регистра сведений
//
// Параметры:
//  Пользователь - СправочникСсылка.Пользователи - пользователь, для которого получить настройки
//
// Возвращаемое значение:
//  Структура - структура с настройками:
//   * РежимПодключения - ПеречислениеСсылка.ИИА_РежимПодключения
//   * Gitsell_Endpoint - Строка
//   * Gitsell_AccessToken - Строка
//   * Provider_BaseURL - Строка
//   * Provider_ApiKey - Строка
//   * ProviderType - Строка
//
Функция ПолучитьНастройкиПользователя(Пользователь) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("РежимПодключения", Неопределено);
	Результат.Вставить("Gitsell_Endpoint", "");
	Результат.Вставить("Gitsell_AccessToken", "");
	Результат.Вставить("Provider_BaseUrl", "");
	Результат.Вставить("Provider_ApiKey", "");
	Результат.Вставить("Provider_Type", "");
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	НастройкиПользователя.РежимПодключения,
	|	НастройкиПользователя.Gitsell_Endpoint,
	|	НастройкиПользователя.Gitsell_AccessToken,
	|	НастройкиПользователя.Provider_BaseUrl,
	|	НастройкиПользователя.Provider_ApiKey,
	|	НастройкиПользователя.Provider_Type,
	|	НастройкиПользователя.Токен,
	|	НастройкиПользователя.ОкончаниеТокена,
	|	НастройкиПользователя.АвторизационныеДанные,
	|	НастройкиПользователя.Scope
	|ИЗ
	|	РегистрСведений.ИИА_НастройкиПользователей КАК НастройкиПользователя
	|ГДЕ
	|	НастройкиПользователя.Пользователь = &Пользователь";
	
	Запрос.УстановитьПараметр("Пользователь", Пользователь);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат Результат;
	КонецЕсли;
	
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	
	Результат.РежимПодключения = Выборка.РежимПодключения;
	Результат.Gitsell_Endpoint = Выборка.Gitsell_Endpoint;
	Результат.Gitsell_AccessToken = Выборка.Gitsell_AccessToken;
	Результат.Вставить("Provider_BaseUrl", Выборка.Provider_BaseUrl);
	Результат.Вставить("Provider_ApiKey", Выборка.Provider_ApiKey);
	Результат.Вставить("Provider_Type", Выборка.Provider_Type);
	Результат.Вставить("Токен", Выборка.Токен);
	Результат.Вставить("ОкончаниеТокена", Выборка.ОкончаниеТокена);
	Результат.Вставить("АвторизационныеДанные", Выборка.АвторизационныеДанные);
	Результат.Вставить("Scope", Выборка.Scope);
	
	Возврат Результат;
	
КонецФункции

// Получает токен доступа для Гигачат (с кешированием на 30 минут)
//
// Параметры:
//  Настройки - Структура - настройки пользователя
//
// Возвращаемое значение:
//  Строка - токен доступа
//
Функция ПолучитьТокенДоступа(Настройки) Экспорт
	
	// Если токен еще действует (30 минут), возвращаем его
	// В Python коде используется: datetime.now() + timedelta(seconds=expires_at / 1000 - 60)
	// То есть токен считается действительным до expires_at минус 60 секунд
	ТекущееВремя = УниверсальноеВремя(ТекущаяДата());
	
	Если ЗначениеЗаполнено(Настройки.Токен) 
		И ЗначениеЗаполнено(Настройки.ОкончаниеТокена)
		И Настройки.ОкончаниеТокена > ТекущееВремя Тогда
		// Токен еще действует
		Возврат Настройки.Токен;
	КонецЕсли;
	
	// Получаем новый токен
	Возврат ПолучитьНовыйТокенДоступа(Настройки);
	
КонецФункции

// Получает новый токен доступа через OAuth
//
// Параметры:
//  Настройки - Структура - настройки пользователя (входной/выходной)
//
// Возвращаемое значение:
//  Строка - новый токен доступа
//
Функция ПолучитьНовыйТокенДоступа(Настройки)
	
	// Проверяем наличие авторизационных данных
	Если ПустаяСтрока(Настройки.АвторизационныеДанные) Тогда
		// Если нет авторизационных данных, используем Provider_ApiKey напрямую
		Возврат Настройки.Provider_ApiKey;
	КонецЕсли;
	
	Попытка
		
		// Подключаемся к OAuth серверу
		Соединение = Новый HTTPСоединение("ngw.devices.sberbank.ru:9443", , , , , , Новый ЗащищенноеСоединениеOpenSSL());
		
		Заголовки = Новый Соответствие;
		Заголовки.Вставить("RqUID", Строка(Новый УникальныйИдентификатор));
		Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
		Заголовки.Вставить("Accept", "application/json");
		// Для получения токена используется Basic авторизация, а не Bearer!
		Заголовки.Вставить("Authorization", "Basic " + Настройки.АвторизационныеДанные);
		
		Scope = "GIGACHAT_API_PERS";
		Если НЕ ПустаяСтрока(Настройки.Scope) Тогда
			Scope = Настройки.Scope;
		КонецЕсли;
		
		Запрос = Новый HTTPЗапрос("/api/v2/oauth", Заголовки);
		Запрос.УстановитьТелоИзСтроки("scope=" + Scope);
		Результат = Соединение.ОтправитьДляОбработки(Запрос);
		
		Если Результат.КодСостояния = 200 Тогда
			
			ТекстОтвета = Результат.ПолучитьТелоКакСтроку();
			ЧтениеJson = Новый ЧтениеJson;
			ЧтениеJson.УстановитьСтроку(ТекстОтвета);
			РезСтруктура = ПрочитатьJSON(ЧтениеJson);
			ЧтениеJson.Закрыть();
			
			// Проверяем наличие access_token в ответе
			Если НЕ РезСтруктура.Свойство("access_token") Тогда
				ВызватьИсключение "В ответе OAuth отсутствует access_token. Ответ: " + ТекстОтвета;
			КонецЕсли;
			
			НовыйТокен = РезСтруктура.access_token;
			
			// Проверяем, что токен не пустой
			Если ПустаяСтрока(НовыйТокен) Тогда
				ВызватьИсключение "Получен пустой access_token. Ответ: " + ТекстОтвета;
			КонецЕсли;
			ДатаОкончания = ПреобразоватьДатуUnix(РезСтруктура.expires_at);
			
			// Сохраняем токен в настройках (если есть возможность)
			Настройки.Вставить("Токен", НовыйТокен);
			Настройки.Вставить("ОкончаниеТокена", ДатаОкончания);
			
			// Пытаемся сохранить в регистр сведений
			Попытка
				СохранитьТокенВНастройки(Настройки);
			Исключение
				// Если не удалось сохранить, продолжаем работу
			КонецПопытки;
			
			Возврат НовыйТокен;
			
		Иначе
			
			ТекстОшибки = Результат.ПолучитьТелоКакСтроку();
			ВызватьИсключение "Не удалось получить токен доступа. Код ошибки: " + Формат(Результат.КодСостояния, "ЧН=0") + " " + ТекстОшибки;
			
		КонецЕсли;
		
	Исключение
		
		// Если ошибка при получении токена, используем Provider_ApiKey напрямую
		Если НЕ ПустаяСтрока(Настройки.Provider_ApiKey) Тогда
			Возврат Настройки.Provider_ApiKey;
		Иначе
			ВызватьИсключение "Ошибка при получении токена доступа: " + ОписаниеОшибки();
		КонецЕсли;
		
	КонецПопытки;
	
КонецФункции

// Преобразует дату из формата Unix timestamp в дату 1С
//
// Параметры:
//  Значение - Число - Unix timestamp в миллисекундах (как в GigaChat API)
//
// Возвращаемое значение:
//  Дата - дата в формате 1С
//
Функция ПреобразоватьДатуUnix(Значение)
	
	Результат = Дата(1, 1, 1);
	Если ЗначениеЗаполнено(Значение) Тогда
		// GigaChat возвращает expires_at в миллисекундах, нужно делить на 1000
		// И вычитаем 60 секунд для безопасности (как в Python коде)
		ЗначениеВСекундах = Значение / 1000 - 60;
		ТекущееВремя = УниверсальноеВремя(ТекущаяДата());
		Результат = ТекущееВремя + ЗначениеВСекундах;
	КонецЕсли;
	Возврат Результат;
	
КонецФункции

// Сохраняет токен в регистр сведений настроек пользователя
//
// Параметры:
//  Настройки - Структура - настройки пользователя (входной/выходной)
//
Процедура СохранитьТокенВНастройки(Настройки)
	
	// Получаем пользователя из настроек
	Если НЕ Настройки.Свойство("Пользователь") Тогда
		Возврат;
	КонецЕсли;
	
	Пользователь = Настройки.Пользователь;
	
	// Получаем набор записей
	НаборЗаписей = РегистрыСведений.ИИА_НастройкиПользователей.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Пользователь.Установить(Пользователь);
	
	// Ищем существующую запись
	НаборЗаписей.Прочитать();
	
	Если НаборЗаписей.Количество() = 0 Тогда
		// Создаем новую запись
		НоваяЗапись = НаборЗаписей.Добавить();
		НоваяЗапись.Пользователь = Пользователь;
	Иначе
		// Используем существующую запись
		НоваяЗапись = НаборЗаписей[0];
	КонецЕсли;
	
	// Обновляем токен и дату окончания
	НоваяЗапись.Токен = Настройки.Токен;
	НоваяЗапись.ОкончаниеТокена = Настройки.ОкончаниеТокена;
	
	НаборЗаписей.Записать();
	
КонецПроцедуры

// Находит активный диалог пользователя или создает новый
//
// Параметры:
//  Пользователь - СправочникСсылка.Пользователи - пользователь
//
// Возвращаемое значение:
//  СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
Функция НайтиИлиСоздатьДиалогПользователя(Пользователь) Экспорт
	
	// Ищем активный диалог
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Диалоги.Ссылка
	|ИЗ
	|	Справочник.ИИА_Диалоги КАК Диалоги
	|ГДЕ
	|	Диалоги.Пользователь = &Пользователь
	|	И Диалоги.Активный = ИСТИНА
	|УПОРЯДОЧИТЬ ПО
	|	Диалоги.ДатаСоздания УБЫВ";
	
	Запрос.УстановитьПараметр("Пользователь", Пользователь);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат Выборка.Ссылка;
	КонецЕсли;
	
	// Создаем новый диалог
	НовыйДиалог = Справочники.ИИА_Диалоги.СоздатьЭлемент();
	НовыйДиалог.Пользователь = Пользователь;
	НовыйДиалог.Имя = "Диалог ИИ от " + Формат(ТекущаяДата(), "ДФ=dd.MM.yyyy HH:mm:ss");
	НовыйДиалог.ДатаСоздания = ТекущаяДата();
	НовыйДиалог.Активный = Истина;
	НовыйДиалог.Записать();
	
	Возврат НовыйДиалог.Ссылка;
	
КонецФункции

// Получает сообщения диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  Количество - Число - количество последних сообщений
//
// Возвращаемое значение:
//  Массив - массив структур с сообщениями
//
Функция ПолучитьСообщенияДиалога(СсылкаДиалога, Количество = 50) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	МассивСообщений = Новый Массив;
	
	ИндексНачала = Макс(0, Диалог.Сообщения.Количество() - Количество);
	
	Для Индекс = ИндексНачала По Диалог.Сообщения.Количество() - 1 Цикл
		
		Строка = Диалог.Сообщения[Индекс];
		
		СтруктураСообщения = Новый Структура;
		СтруктураСообщения.Вставить("Время", Строка.Время);
		СтруктураСообщения.Вставить("Автор", Строка.Автор);
		СтруктураСообщения.Вставить("ТипСообщения", Строка.ТипСообщения);
		СтруктураСообщения.Вставить("Текст", Строка.Текст);
		СтруктураСообщения.Вставить("ТекстКода", Строка.ТекстКода);
		СтруктураСообщения.Вставить("Статус", Строка.Статус);
		СтруктураСообщения.Вставить("UsageTokens", Строка.UsageTokens);
		
		МассивСообщений.Добавить(СтруктураСообщения);
		
	КонецЦикла;
	
	Возврат МассивСообщений;
	
КонецФункции

// Добавляет сообщение в диалог
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  Автор - ПеречислениеСсылка.ИИА_АвторСообщения - автор сообщения
//  ТипСообщения - ПеречислениеСсылка.ИИА_ТипСообщения - тип сообщения
//  Текст - Строка - текст сообщения
//  ТекстКода - Строка - текст кода (для запросов)
//  Статус - Строка - статус сообщения
//  UsageTokens - Число - количество использованных токенов
//
Процедура ДобавитьСообщениеВДиалог(СсылкаДиалога, Автор, ТипСообщения, Текст, ТекстКода = "", Статус = "", UsageTokens = 0) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	НоваяСтрока = Диалог.Сообщения.Добавить();
	НоваяСтрока.Время = ТекущаяДата();
	НоваяСтрока.Автор = Автор;
	НоваяСтрока.ТипСообщения = ТипСообщения;
	НоваяСтрока.Текст = Текст;
	НоваяСтрока.ТекстКода = ТекстКода;
	НоваяСтрока.Статус = Статус;
	НоваяСтрока.UsageTokens = UsageTokens;
	
	Диалог.Записать();
	
КонецПроцедуры

// Вызывает ИИ для получения ответа (заглушка)
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  Настройки - Структура - настройки пользователя
//
// Возвращаемое значение:
//  Структура - структура ответа:
//   * ТипОтвета - Строка ("Текст", "Запрос" или "DSL")
//   * Текст - Строка - текст ответа
//   * Запрос - Строка - текст запроса (для типа "Запрос")
//   * DSL - Строка - JSON с DSL-сценарием (для типа "DSL")
//   * ВыполнитьDSL - Булево - выполнить ли DSL сразу (для типа "DSL")
//   * Usage - Структура - информация об использовании токенов
//   * Ошибки - ОписаниеОшибки - информация об ошибках
//
Функция ВызватьИИ(ТипСообщения, ТекстПользователя, История, Настройки) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", "");
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	Результат.Вставить("Usage", Неопределено);
	Результат.Вставить("Ошибки", Неопределено);
	
	// Проверяем настройки подключения
	Если ПустаяСтрока(Настройки.Provider_ApiKey) ИЛИ ПустаяСтрока(Настройки.Provider_BaseUrl) Тогда
		
		Результат.Текст = "Не настроен API ключ или URL провайдера. Настройте подключение к ИИ провайдеру.";
		Возврат Результат;
		
	КонецЕсли;
	
	// Определяем тип провайдера
	ТипПровайдера = "";
	Если Настройки.Свойство("Provider_Type") Тогда
		ТипПровайдера = Настройки.Provider_Type;
	КонецЕсли;
	
	// Если провайдер Гигачат, вызываем его API
	Если ВРег(ТипПровайдера) = "GIGACHAT" ИЛИ ВРег(ТипПровайдера) = "ГИГАЧАТ" ИЛИ ПустаяСтрока(ТипПровайдера) Тогда
		
		Результат = ВызватьГигачат(ТипСообщения, ТекстПользователя, История, Настройки);
		
	Иначе
		
		// Для других провайдеров можно добавить аналогичную логику
		Результат.Текст = "Неподдерживаемый тип провайдера: " + ТипПровайдера;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Вызывает API Гигачат
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  Настройки - Структура - настройки пользователя
//
// Возвращаемое значение:
//  Структура - структура ответа от ИИ
//
Функция ВызватьГигачат(ТипСообщения, ТекстПользователя, История, Настройки)
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", "");
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	Результат.Вставить("Usage", Неопределено);
	Результат.Вставить("Ошибки", Неопределено);
	
	// Формируем URL для запроса (как в Python коде)
	URLИзНастроек = Настройки.Provider_BaseUrl;
	Если ПустаяСтрока(URLИзНастроек) Тогда
		URLИзНастроек = "https://gigachat.devices.sberbank.ru/api/v1";
	КонецЕсли;
	
	// Если в URL нет /api/v1, добавляем его
	Если СтрНайти(ВРег(URLИзНастроек), "/API/V1") = 0 Тогда
		// Убираем завершающий слеш, если есть
		Если Прав(URLИзНастроек, 1) = "/" Тогда
			URLИзНастроек = Лев(URLИзНастроек, СтрДлина(URLИзНастроек) - 1);
		КонецЕсли;
		URLИзНастроек = URLИзНастроек + "/api/v1";
	КонецЕсли;
	
	// Убираем завершающий слеш, если есть (как в Python: rstrip('/'))
	Если Прав(URLИзНастроек, 1) = "/" Тогда
		URLИзНастроек = Лев(URLИзНастроек, СтрДлина(URLИзНастроек) - 1);
	КонецЕсли;
	
	// Формируем полный URL (как в Python: f"{base_url.rstrip('/')}/chat/completions")
	ПолныйURL = URLИзНастроек + "/chat/completions";
	
	// Разделяем на домен и путь для HTTPСоединение
	// Убираем протокол https:// если есть
	URLБезПротокола = СтрЗаменить(URLИзНастроек, "https://", "");
	URLБезПротокола = СтрЗаменить(URLБезПротокола, "http://", "");
	
	// Разделяем на домен и путь для HTTPСоединение
	// В Python используется полный URL, но в 1С HTTPСоединение требует домен и путь отдельно
	ПозицияСлеша = СтрНайти(URLБезПротокола, "/");
	Если ПозицияСлеша > 0 Тогда
		БазовыйДомен = Лев(URLБезПротокола, ПозицияСлеша - 1);
		// Путь должен быть "/api/v1/chat/completions" (с начальным слешем)
		БазовыйПуть = Сред(URLБезПротокола, ПозицияСлеша);
		URLПуть = БазовыйПуть + "/chat/completions";
	Иначе
		БазовыйДомен = URLБезПротокола;
		URLПуть = "/api/v1/chat/completions";
	КонецЕсли;
	
	// Получаем токен доступа (с кешированием на 30 минут)
	// Для GigaChat API всегда нужен OAuth Access token, даже для режима "Свой ключ напрямую"
	// Если есть авторизационные данные, используем их для получения OAuth токена
	// Иначе используем Provider_ApiKey (для обратной совместимости, но это может не работать)
	Если НЕ ПустаяСтрока(Настройки.АвторизационныеДанные) Тогда
		// Используем OAuth токен (получается автоматически через авторизационные данные)
		ТокенДоступа = ПолучитьТокенДоступа(Настройки);
	ИначеЕсли НЕ ПустаяСтрока(Настройки.Provider_ApiKey) Тогда
		// Fallback: используем Provider_ApiKey напрямую (может не работать для GigaChat)
		ТокенДоступа = Настройки.Provider_ApiKey;
	Иначе
		ВызватьИсключение "Не указан Provider_ApiKey или АвторизационныеДанные для подключения к GigaChat";
	КонецЕсли;
	
	// Получаем метаданные для контекста
	МетаданныеКонтекст = ПолучитьМетаданныеДляИИ();
	
	// Формируем промпт с учетом типа сообщения и метаданных
	Промпт = СформироватьПромптДляИИ(ТипСообщения, ТекстПользователя, История, МетаданныеКонтекст);
	
	// Формируем тело запроса
	ТелоЗапроса = Новый Структура;
	ТелоЗапроса.Вставить("model", "GigaChat:latest");
	ТелоЗапроса.Вставить("messages", Промпт.Сообщения);
	ТелоЗапроса.Вставить("temperature", 0.7);
	ТелоЗапроса.Вставить("max_tokens", 2000);
	
	// Преобразуем в JSON
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, ТелоЗапроса);
	JSONТело = ЗаписьJSON.Закрыть();
	
	// Выполняем HTTP-запрос
	Попытка
		
		// Используем защищенное соединение OpenSSL для HTTPS
		// БазовыйДомен уже без протокола (например, "gigachat.devices.sberbank.ru")
		HTTPСоединение = Новый HTTPСоединение(БазовыйДомен, , , , , , Новый ЗащищенноеСоединениеOpenSSL());
		
		Заголовки = Новый Соответствие;
		// Host заголовок не нужен при использовании HTTPСоединение - он устанавливается автоматически
		// Заголовки.Вставить("Host", БазовыйДомен);
		Заголовки.Вставить("Content-Type", "application/json");
		Заголовки.Вставить("Accept", "application/json");
		Заголовки.Вставить("Cache-Control", "no-cache");
		
		// Для GigaChat используется формат "Bearer {токен}" для Access token
		ЗаголовокАвторизации = "Bearer " + ТокенДоступа;
		Заголовки.Вставить("Authorization", ЗаголовокАвторизации);
		
		
		HTTPЗапрос = Новый HTTPЗапрос(URLПуть, Заголовки);
		HTTPЗапрос.УстановитьТелоИзСтроки(JSONТело);
		
		HTTPОтвет = HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);
		
		Если HTTPОтвет.КодСостояния <> 200 Тогда
			
			ТекстОшибки = HTTPОтвет.ПолучитьТелоКакСтроку();
			Результат.Текст = "Ошибка API Гигачат: " + Формат(HTTPОтвет.КодСостояния, "ЧН=0") + " - " + ТекстОшибки;
			
			// Убеждаемся, что поле Ошибки существует
			Если НЕ Результат.Свойство("Ошибки") Тогда
				Результат.Вставить("Ошибки", "");
			КонецЕсли;
			Результат.Ошибки = ТекстОшибки;
			
			Возврат Результат;
			
		КонецЕсли;
		
		// Парсим ответ
		ТекстОтвета = HTTPОтвет.ПолучитьТелоКакСтроку();
		
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ТекстОтвета);
		ОтветJSON = ПрочитатьJSON(ЧтениеJSON);
		ЧтениеJSON.Закрыть();
		
		// Извлекаем ответ от ИИ
		Если ОтветJSON.Свойство("choices") И ОтветJSON.choices.Количество() > 0 Тогда
			
			Выбор = ОтветJSON.choices[0];
			Если Выбор.Свойство("message") И Выбор.message.Свойство("content") Тогда
				
				ТекстОтветаИИ = Выбор.message.content;
				
				// Определяем тип ответа и парсим его
				РезультатРаспознавания = РаспознатьОтветИИ(ТекстОтветаИИ, ТипСообщения);
				
				// Копируем поля из результата распознавания, сохраняя существующие поля
				Для Каждого КлючЗначение Из РезультатРаспознавания Цикл
					Результат.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЕсли;
		
		// Извлекаем информацию об использовании токенов
		Если ОтветJSON.Свойство("usage") Тогда
			
			UsageStruct = Новый Структура;
			Если ОтветJSON.usage.Свойство("prompt_tokens") Тогда
				UsageStruct.Вставить("PromptTokens", ОтветJSON.usage.prompt_tokens);
			Иначе
				UsageStruct.Вставить("PromptTokens", 0);
			КонецЕсли;
			
			Если ОтветJSON.usage.Свойство("completion_tokens") Тогда
				UsageStruct.Вставить("CompletionTokens", ОтветJSON.usage.completion_tokens);
			Иначе
				UsageStruct.Вставить("CompletionTokens", 0);
			КонецЕсли;
			
			Если ОтветJSON.usage.Свойство("total_tokens") Тогда
				UsageStruct.Вставить("TotalTokens", ОтветJSON.usage.total_tokens);
			Иначе
				UsageStruct.Вставить("TotalTokens", 0);
			КонецЕсли;
			
			UsageStruct.Вставить("ОстатокКредитов", 0); // Гигачат не возвращает информацию о балансе
			
			// Убеждаемся, что поле Usage существует
			Если НЕ Результат.Свойство("Usage") Тогда
				Результат.Вставить("Usage", Неопределено);
			КонецЕсли;
			Результат.Usage = UsageStruct;
			
		КонецЕсли;
		
	Исключение
		
		ТекстОшибки = ОписаниеОшибки();
		Результат.Текст = "Ошибка при вызове API Гигачат: " + ТекстОшибки + 
			Символы.ПС + "БазовыйДомен: " + БазовыйДомен + 
			Символы.ПС + "URLПуть: " + URLПуть;
		
		// Убеждаемся, что поле Ошибки существует
		Если НЕ Результат.Свойство("Ошибки") Тогда
			Результат.Вставить("Ошибки", "");
		КонецЕсли;
		Результат.Ошибки = ОписаниеОшибки();
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Получает метаданные конфигурации для передачи в ИИ
//
// Возвращаемое значение:
//  Структура - структура с метаданными
//
Функция ПолучитьМетаданныеДляИИ()
	
	Результат = Новый Структура;
	
	// Получаем списки объектов
	Результат.Вставить("Справочники", ИИА_Метаданные.ПолучитьСписокСправочников());
	Результат.Вставить("Документы", ИИА_Метаданные.ПолучитьСписокДокументов());
	Результат.Вставить("РегистрыСведений", ИИА_Метаданные.ПолучитьСписокРегистровСведений());
	Результат.Вставить("РегистрыНакопления", ИИА_Метаданные.ПолучитьСписокРегистровНакопления());
	Результат.Вставить("РегистрыБухгалтерии", ИИА_Метаданные.ПолучитьСписокРегистровБухгалтерии());
	
	Возврат Результат;
	
КонецФункции

// Формирует промпт для ИИ с учетом контекста
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  МетаданныеКонтекст - Структура - метаданные конфигурации
//
// Возвращаемое значение:
//  Структура - структура с сообщениями для ИИ
//
Функция СформироватьПромптДляИИ(ТипСообщения, ТекстПользователя, История, МетаданныеКонтекст)
	
	Результат = Новый Структура;
	Сообщения = Новый Массив;
	
	// Системный промпт
	СистемноеСообщение = Новый Структура;
	СистемноеСообщение.Вставить("role", "system");
	
	СистемныйПромпт = "Ты - ИИ-ассистент для работы с системой 1С:Предприятие. " + Символы.ПС +
		"Твоя задача - понимать команды пользователя и генерировать безопасные DSL-сценарии или запросы на языке запросов 1С." + Символы.ПС +
		Символы.ПС +
		"Доступные объекты конфигурации:" + Символы.ПС;
	
	// Добавляем информацию о справочниках
	Если МетаданныеКонтекст.Свойство("Справочники") Тогда
		СистемныйПромпт = СистемныйПромпт + "Справочники: ";
		Для Каждого Справочник Из МетаданныеКонтекст.Справочники Цикл
			СистемныйПромпт = СистемныйПромпт + Справочник.Имя + " (" + Справочник.Синоним + "), ";
		КонецЦикла;
		СистемныйПромпт = Лев(СистемныйПромпт, СтрДлина(СистемныйПромпт) - 2) + Символы.ПС;
	КонецЕсли;
	
	// Добавляем информацию о документах
	Если МетаданныеКонтекст.Свойство("Документы") Тогда
		СистемныйПромпт = СистемныйПромпт + "Документы: ";
		Для Каждого Документ Из МетаданныеКонтекст.Документы Цикл
			СистемныйПромпт = СистемныйПромпт + Документ.Имя + " (" + Документ.Синоним + "), ";
		КонецЦикла;
		СистемныйПромпт = Лев(СистемныйПромпт, СтрДлина(СистемныйПромпт) - 2) + Символы.ПС;
	КонецЕсли;
	
	СистемныйПромпт = СистемныйПромпт + Символы.ПС +
		"Формат DSL-сценария:" + Символы.ПС +
		"{""dsl_version"": 1, ""steps"": [{""action"": ""CreateReference"", ""object_name"": ""ИмяСправочника""}, ...]}" + Символы.ПС +
		"Доступные действия: CreateReference, CreateDocument, FindReferenceByName, SetField, Write, RunQuery, ShowInfo" + Символы.ПС +
		Символы.ПС +
		"Если пользователь просит создать или найти объект, генерируй DSL-сценарий в формате JSON." + Символы.ПС +
		"Если пользователь просит выполнить запрос, генерируй запрос на языке запросов 1С.";
	
	СистемноеСообщение.Вставить("content", СистемныйПромпт);
	Сообщения.Добавить(СистемноеСообщение);
	
	// Добавляем историю диалога
	Для Каждого СтрокаИстории Из История Цикл
		
		Сообщение = Новый Структура;
		
		Если СтрокаИстории.Автор = Перечисления.ИИА_АвторСообщения.Пользователь Тогда
			Сообщение.Вставить("role", "user");
		Иначе
			Сообщение.Вставить("role", "assistant");
		КонецЕсли;
		
		ТекстСообщения = СтрокаИстории.Текст;
		Если НЕ ПустаяСтрока(СтрокаИстории.ТекстКода) Тогда
			ТекстСообщения = ТекстСообщения + Символы.ПС + "```" + Символы.ПС + СтрокаИстории.ТекстКода + Символы.ПС + "```";
		КонецЕсли;
		
		Сообщение.Вставить("content", ТекстСообщения);
		Сообщения.Добавить(Сообщение);
		
	КонецЦикла;
	
	// Добавляем текущее сообщение пользователя
	ТекущееСообщение = Новый Структура;
	ТекущееСообщение.Вставить("role", "user");
	ТекущееСообщение.Вставить("content", ТекстПользователя);
	Сообщения.Добавить(ТекущееСообщение);
	
	Результат.Вставить("Сообщения", Сообщения);
	
	Возврат Результат;
	
КонецФункции

// Распознает ответ ИИ и определяет его тип
//
// Параметры:
//  ТекстОтветаИИ - Строка - текст ответа от ИИ
//  ТипСообщения - Строка - тип исходного сообщения
//
// Возвращаемое значение:
//  Структура - структура результата с распознанным типом и данными
//
Функция РаспознатьОтветИИ(ТекстОтветаИИ, ТипСообщения)
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", ТекстОтветаИИ);
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	
	// Пытаемся найти JSON в ответе (DSL-сценарий)
	НачалоОткрывающейСкобки = СтрНайти(ТекстОтветаИИ, "{");
	Если НачалоОткрывающейСкобки > 0 Тогда
		// Ищем закрывающую скобку, начиная с позиции после открывающей
		КонецЗакрывающейСкобки = СтрНайти(ТекстОтветаИИ, "}", НаправлениеПоиска.СКонца);
	Иначе
		КонецЗакрывающейСкобки = 0;
	КонецЕсли;
	
	Если НачалоОткрывающейСкобки > 0 И КонецЗакрывающейСкобки > 0 Тогда
		
		ВозможныйJSON = Сред(ТекстОтветаИИ, НачалоОткрывающейСкобки, КонецЗакрывающейСкобки - НачалоОткрывающейСкобки + 1);
		
		Попытка
			
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ВозможныйJSON);
			ПроверкаJSON = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			
			// Проверяем, что это DSL-сценарий
			Если ПроверкаJSON.Свойство("dsl_version") И ПроверкаJSON.Свойство("steps") Тогда
				
				Результат.ТипОтвета = "DSL";
				Результат.DSL = ВозможныйJSON;
				Результат.Текст = "Сгенерирован DSL-сценарий:";
				Результат.ВыполнитьDSL = Ложь; // По умолчанию не выполняем автоматически
				
				Возврат Результат;
				
			КонецЕсли;
			
		Исключение
			// Не JSON или не DSL - продолжаем как обычный текст
		КонецПопытки;
		
	КонецЕсли;
	
	// Если тип сообщения "Запрос", пытаемся найти запрос в ответе
	Если ТипСообщения = "Запрос" Тогда
		
		// Ищем блок кода с запросом
		НачалоБлока = СтрНайти(ТекстОтветаИИ, "```");
		Если НачалоБлока > 0 Тогда
			
			КонецБлока = СтрНайти(ТекстОтветаИИ, "```", НачалоБлока + 3);
			Если КонецБлока > 0 Тогда
				
				ТекстЗапроса = Сред(ТекстОтветаИИ, НачалоБлока + 3, КонецБлока - НачалоБлока - 3);
				ТекстЗапроса = СокрЛП(ТекстЗапроса);
				
				// Проверяем, что это похоже на запрос 1С
				Если СтрНайти(ВРег(ТекстЗапроса), "ВЫБРАТЬ") > 0 Тогда
					
					Результат.ТипОтвета = "Запрос";
					Результат.Запрос = ТекстЗапроса;
					Результат.Текст = "Сгенерирован запрос:";
					
					Возврат Результат;
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// По умолчанию возвращаем как текст
	Возврат Результат;
	
КонецФункции

// Исправляет DSL-сценарий через ИИ при ошибке выполнения
//
// Параметры:
//  DSLJSON - Строка - исходный DSL-сценарий с ошибкой
//  ТекстОшибки - Строка - текст ошибки выполнения
//  Настройки - Структура - настройки пользователя
//
// Возвращаемое значение:
//  Структура - структура результата:
//   * Успех - Булево
//   * Сообщение - Строка
//   * ИсправленныйDSL - Строка - исправленный DSL-сценарий
//
Функция ИсправитьDSLЧерезИИ(DSLJSON, ТекстОшибки, Настройки)
	
	Результат = Новый Структура;
	Результат.Вставить("Успех", Ложь);
	Результат.Вставить("Сообщение", "");
	Результат.Вставить("ИсправленныйDSL", "");
	
	// Формируем промпт для исправления
	ПромптИсправления = "Исправь следующий DSL-сценарий, который вызвал ошибку:" + Символы.ПС +
		"Ошибка: " + ТекстОшибки + Символы.ПС +
		"Исходный DSL:" + Символы.ПС +
		DSLJSON + Символы.ПС +
		"Верни только исправленный JSON без дополнительных комментариев.";
	
	// Вызываем ИИ для исправления
	Попытка
		
		БазовыйURL = Настройки.Provider_BaseUrl;
		Если ПустаяСтрока(БазовыйURL) Тогда
			БазовыйURL = "https://gigachat.devices.sberbank.ru";
		КонецЕсли;
		
		URLПуть = "/api/v1/chat/completions";
		
		Сообщения = Новый Массив;
		Сообщение = Новый Структура;
		Сообщение.Вставить("role", "user");
		Сообщение.Вставить("content", ПромптИсправления);
		Сообщения.Добавить(Сообщение);
		
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("model", "GigaChat");
		ТелоЗапроса.Вставить("messages", Сообщения);
		ТелоЗапроса.Вставить("temperature", 0.3); // Низкая температура для более точного исправления
		ТелоЗапроса.Вставить("max_tokens", 2000);
		
		ЗаписьJSON = Новый ЗаписьJSON;
		ЗаписьJSON.УстановитьСтроку();
		ЗаписатьJSON(ЗаписьJSON, ТелоЗапроса);
		JSONТело = ЗаписьJSON.Закрыть();
		
		HTTPСоединение = Новый HTTPСоединение(БазовыйURL);
		
		Заголовки = Новый Соответствие;
		Заголовки.Вставить("Content-Type", "application/json");
		Заголовки.Вставить("Authorization", "Bearer " + Настройки.Provider_ApiKey);
		
		HTTPЗапрос = Новый HTTPЗапрос(URLПуть, Заголовки);
		HTTPЗапрос.УстановитьТелоИзСтроки(JSONТело);
		
		HTTPОтвет = HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);
		
		Если HTTPОтвет.КодСостояния = 200 Тогда
			
			ТекстОтвета = HTTPОтвет.ПолучитьТелоКакСтроку();
			
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ТекстОтвета);
			ОтветJSON = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			
			Если ОтветJSON.Свойство("choices") И ОтветJSON.choices.Количество() > 0 Тогда
				
				Выбор = ОтветJSON.choices[0];
				Если Выбор.Свойство("message") И Выбор.message.Свойство("content") Тогда
					
					ТекстИсправления = Выбор.message.content;
					
					// Извлекаем JSON из ответа
					НачалоОткрывающейСкобки = СтрНайти(ТекстИсправления, "{");
					КонецЗакрывающейСкобки = СтрНайти(ТекстИсправления, "}", , НачалоОткрывающейСкобки);
					
					Если НачалоОткрывающейСкобки > 0 И КонецЗакрывающейСкобки > 0 Тогда
						
						ИсправленныйJSON = Сред(ТекстИсправления, НачалоОткрывающейСкобки, КонецЗакрывающейСкобки - НачалоОткрывающейСкобки + 1);
						
						// Проверяем исправленный DSL
						РезультатПроверки = ПроверитьDSLСценарий(ИсправленныйJSON);
						Если РезультатПроверки.Успех Тогда
							
							Результат.Успех = Истина;
							Результат.ИсправленныйDSL = ИсправленныйJSON;
							Результат.Сообщение = "DSL-сценарий исправлен";
							
						Иначе
							
							Результат.Сообщение = "Исправленный DSL также содержит ошибки: " + РезультатПроверки.Сообщение;
							
						КонецЕсли;
						
					Иначе
						
						Результат.Сообщение = "Не удалось извлечь JSON из ответа ИИ";
						
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЕсли;
			
		Иначе
			
			Результат.Сообщение = "Ошибка API при исправлении: " + Формат(HTTPОтвет.КодСостояния, "ЧН=0");
			
		КонецЕсли;
		
	Исключение
		
		Результат.Сообщение = "Ошибка при исправлении DSL: " + ОписаниеОшибки();
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Получает пример DSL-сценария (заглушка для демонстрации)
//
// Параметры:
//  ТекстПользователя - Строка - текст команды пользователя
//
// Возвращаемое значение:
//  Строка - JSON с DSL-сценарием
//
Функция ПолучитьПримерDSLСценария(ТекстПользователя)
	
	// Это заглушка - в реальной реализации ИИ должен генерировать DSL на основе команды пользователя
	// и метаданных конфигурации
	
	ПримерСценария = Новый Структура;
	ПримерСценария.Вставить("dsl_version", 1);
	
	Шаги = Новый Массив;
	
	// Пример: создание элемента справочника
	Если СтрНайти(ВРег(ТекстПользователя), "КОНТРАГЕНТ") > 0 Тогда
		
		Шаг1 = Новый Структура;
		Шаг1.Вставить("action", "CreateReference");
		Шаг1.Вставить("object_name", "Контрагенты");
		Шаги.Добавить(Шаг1);
		
		Шаг2 = Новый Структура;
		Шаг2.Вставить("action", "SetField");
		Шаг2.Вставить("field", "Наименование");
		Шаг2.Вставить("value", "Новый контрагент");
		Шаги.Добавить(Шаг2);
		
		Шаг3 = Новый Структура;
		Шаг3.Вставить("action", "Write");
		Шаги.Добавить(Шаг3);
		
	Иначе
		
		// Общий пример
		Шаг1 = Новый Структура;
		Шаг1.Вставить("action", "ShowInfo");
		Шаг1.Вставить("message", "Пример DSL-сценария. Настройте ИИ для генерации реальных сценариев.");
		Шаги.Добавить(Шаг1);
		
	КонецЕсли;
	
	ПримерСценария.Вставить("steps", Шаги);
	
	// Преобразуем в JSON
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, ПримерСценария);
	JSONСтрока = ЗаписьJSON.Закрыть();
	
	Возврат JSONСтрока;
	
КонецФункции

// Отправляет сообщение и получает ответ от ИИ
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//
// Возвращаемое значение:
//  Структура - структура ответа от ВызватьИИ
//
Функция ОтправитьСообщениеСервера(СсылкаДиалога, ТипСообщения, ТекстПользователя) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	Пользователь = Диалог.Пользователь;
	
	// Получаем настройки пользователя
	Настройки = ПолучитьНастройкиПользователя(Пользователь);
	Настройки.Вставить("Пользователь", Пользователь);
	
	// Загружаем историю диалога
	МассивИстории = ПолучитьСообщенияДиалога(СсылкаДиалога, 10);
	
	// Преобразуем массив в таблицу значений для функции ВызватьИИ
	История = Новый ТаблицаЗначений;
	История.Колонки.Добавить("Время", Новый ОписаниеТипов("Дата"));
	История.Колонки.Добавить("Автор", Новый ОписаниеТипов("ПеречислениеСсылка.ИИА_АвторСообщения"));
	История.Колонки.Добавить("ТипСообщения", Новый ОписаниеТипов("ПеречислениеСсылка.ИИА_ТипСообщения"));
	История.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка"));
	История.Колонки.Добавить("ТекстКода", Новый ОписаниеТипов("Строка"));
	
	Для Каждого СтруктураСообщения Из МассивИстории Цикл
		
		НоваяСтрока = История.Добавить();
		НоваяСтрока.Время = СтруктураСообщения.Время;
		НоваяСтрока.Автор = СтруктураСообщения.Автор;
		НоваяСтрока.ТипСообщения = СтруктураСообщения.ТипСообщения;
		НоваяСтрока.Текст = СтруктураСообщения.Текст;
		
	КонецЦикла;
	
	// Определяем тип сообщения для хранения
	Если ТипСообщения = "Запрос" Тогда
		ТипСообщенияДляХранения = Перечисления.ИИА_ТипСообщения.Запрос;
	Иначе
		ТипСообщенияДляХранения = Перечисления.ИИА_ТипСообщения.Текст;
	КонецЕсли;
	
	// Добавляем сообщение пользователя
	ДобавитьСообщениеВДиалог(
		СсылкаДиалога,
		Перечисления.ИИА_АвторСообщения.Пользователь,
		ТипСообщенияДляХранения,
		ТекстПользователя
	);
	
	// Вызываем ИИ
	ОтветИИ = ВызватьИИ(ТипСообщения, ТекстПользователя, История, Настройки);
	
	// Определяем тип ответа для хранения
	Если ОтветИИ.ТипОтвета = "Запрос" Тогда
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Запрос;
		ТекстОтвета = ОтветИИ.Текст;
		ТекстКодаОтвета = ОтветИИ.Запрос;
	ИначеЕсли ОтветИИ.ТипОтвета = "DSL" Тогда
		// Обрабатываем DSL-сценарий
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Код;
		ТекстОтвета = ОтветИИ.Текст;
		ТекстКодаОтвета = ОтветИИ.DSL;
		
		// Выполняем DSL, если требуется
		Если ОтветИИ.Свойство("ВыполнитьDSL") И ОтветИИ.ВыполнитьDSL Тогда
			
			РезультатDSL = ВыполнитьDSLСценарий(ОтветИИ.DSL);
			
			Если РезультатDSL.Успех Тогда
				ТекстОтвета = ТекстОтвета + Символы.ПС + "DSL-сценарий выполнен успешно.";
				
				// Добавляем информацию о результатах
				Если РезультатDSL.Результаты.Количество() > 0 Тогда
					Для Каждого РезультатШага Из РезультатDSL.Результаты Цикл
						ТекстОтвета = ТекстОтвета + Символы.ПС + "- " + РезультатШага.Сообщение;
					КонецЦикла;
				КонецЕсли;
				
			Иначе
				// Пытаемся исправить ошибку через ИИ
				ТекстОтвета = ТекстОтвета + Символы.ПС + "Ошибка выполнения DSL: " + РезультатDSL.Сообщение;
				
				РезультатКоррекции = ИсправитьDSLЧерезИИ(ОтветИИ.DSL, РезультатDSL.Сообщение, Настройки);
				Если РезультатКоррекции.Успех Тогда
					ТекстОтвета = ТекстОтвета + Символы.ПС + "Попытка исправления: " + РезультатКоррекции.Сообщение;
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	Иначе
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Текст;
		ТекстОтвета = ОтветИИ.Текст;
		ТекстКодаОтвета = "";
	КонецЕсли;
	
	// Получаем UsageTokens
	UsageTokens = 0;
	Если ОтветИИ.Свойство("Usage") И ОтветИИ.Usage <> Неопределено Тогда
		Если ТипЗнч(ОтветИИ.Usage) = Тип("Структура") И ОтветИИ.Usage.Свойство("TotalTokens") Тогда
			UsageTokens = ОтветИИ.Usage.TotalTokens;
		КонецЕсли;
	КонецЕсли;
	
	// Добавляем ответ ИИ
	ДобавитьСообщениеВДиалог(
		СсылкаДиалога,
		Перечисления.ИИА_АвторСообщения.ИИ,
		ТипСообщенияОтвета,
		ТекстОтвета,
		ТекстКодаОтвета,
		"",
		UsageTokens
	);
	
	Возврат ОтветИИ;
	
КонецФункции

// Проверяет запрос 1С на выполнимость
//
// Параметры:
//  ТекстЗапроса - Строка - текст запроса
//
// Возвращаемое значение:
//  Структура - структура результата:
//   * Успех - Булево - успешность выполнения
//   * Сообщение - Строка - текст ошибки или пусто
//
Функция ПроверитьЗапрос(ТекстЗапроса) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Успех", Ложь);
	Результат.Вставить("Сообщение", "");
	
	Попытка
		
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.Выполнить();
		
		Результат.Успех = Истина;
		
	Исключение
		
		Результат.Сообщение = ОписаниеОшибки();
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Выполняет DSL сценарий
//
// Параметры:
//  DSLJSON - Строка - JSON с DSL командами
//
// Возвращаемое значение:
//  Структура - структура результата выполнения DSL
//
Функция ВыполнитьDSLСценарий(DSLJSON) Экспорт
	
	Возврат ИИА_DSL.ВыполнитьDSL(DSLJSON);
	
КонецФункции

// Проверяет DSL сценарий
//
// Параметры:
//  DSLJSON - Строка - JSON с DSL командами
//
// Возвращаемое значение:
//  Структура - структура результата проверки DSL
//
Функция ПроверитьDSLСценарий(DSLJSON) Экспорт
	
	Возврат ИИА_DSL.ПроверитьDSL(DSLJSON);
	
КонецФункции

#КонецОбласти


