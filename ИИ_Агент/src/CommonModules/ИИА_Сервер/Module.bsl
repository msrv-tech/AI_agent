#Область ПрограммныйИнтерфейс

// Получает настройки пользователя из регистра сведений
//
// Параметры:
//  Пользователь - СправочникСсылка.Пользователи - пользователь, для которого получить настройки
//
// Возвращаемое значение:
//  Структура - структура с настройками:
//   * РежимПодключения - ПеречислениеСсылка.ИИА_РежимПодключения
//   * Gitsell_Endpoint - Строка
//   * Gitsell_AccessToken - Строка
//   * Provider_BaseURL - Строка
//   * Provider_ApiKey - Строка
//   * ProviderType - Строка
//
Функция ПолучитьНастройкиПользователя(Пользователь) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("РежимПодключения", Неопределено);
	Результат.Вставить("Gitsell_Endpoint", "");
	Результат.Вставить("Gitsell_AccessToken", "");
	Результат.Вставить("Provider_BaseUrl", "");
	Результат.Вставить("Provider_ApiKey", "");
	Результат.Вставить("Provider_Type", "");
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	НастройкиПользователя.РежимПодключения,
	|	НастройкиПользователя.Gitsell_Endpoint,
	|	НастройкиПользователя.Gitsell_AccessToken,
	|	НастройкиПользователя.Provider_BaseUrl,
	|	НастройкиПользователя.Provider_ApiKey,
	|	НастройкиПользователя.Provider_Type
	|ИЗ
	|	РегистрСведений.ИИА_НастройкиПользователей КАК НастройкиПользователя
	|ГДЕ
	|	НастройкиПользователя.Пользователь = &Пользователь";
	
	Запрос.УстановитьПараметр("Пользователь", Пользователь);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат Результат;
	КонецЕсли;
	
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	
	Результат.РежимПодключения = Выборка.РежимПодключения;
	Результат.Gitsell_Endpoint = Выборка.Gitsell_Endpoint;
	Результат.Gitsell_AccessToken = Выборка.Gitsell_AccessToken;
	Результат.Вставить("Provider_BaseUrl", Выборка.Provider_BaseUrl);
	Результат.Вставить("Provider_ApiKey", Выборка.Provider_ApiKey);
	Результат.Вставить("Provider_Type", Выборка.Provider_Type);
	
	Возврат Результат;
	
КонецФункции

// Находит активный диалог пользователя или создает новый
//
// Параметры:
//  Пользователь - СправочникСсылка.Пользователи - пользователь
//
// Возвращаемое значение:
//  СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
Функция НайтиИлиСоздатьДиалогПользователя(Пользователь) Экспорт
	
	// Ищем активный диалог
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Диалоги.Ссылка
	|ИЗ
	|	Справочник.ИИА_Диалоги КАК Диалоги
	|ГДЕ
	|	Диалоги.Пользователь = &Пользователь
	|	И Диалоги.Активный = ИСТИНА
	|УПОРЯДОЧИТЬ ПО
	|	Диалоги.ДатаСоздания УБЫВ";
	
	Запрос.УстановитьПараметр("Пользователь", Пользователь);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат Выборка.Ссылка;
	КонецЕсли;
	
	// Создаем новый диалог
	НовыйДиалог = Справочники.ИИА_Диалоги.СоздатьЭлемент();
	НовыйДиалог.Пользователь = Пользователь;
	НовыйДиалог.Имя = "Диалог ИИ от " + Формат(ТекущаяДата(), "ДФ=dd.MM.yyyy HH:mm:ss");
	НовыйДиалог.ДатаСоздания = ТекущаяДата();
	НовыйДиалог.Активный = Истина;
	НовыйДиалог.Записать();
	
	Возврат НовыйДиалог.Ссылка;
	
КонецФункции

// Получает сообщения диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  Количество - Число - количество последних сообщений
//
// Возвращаемое значение:
//  Массив - массив структур с сообщениями
//
Функция ПолучитьСообщенияДиалога(СсылкаДиалога, Количество = 50) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	МассивСообщений = Новый Массив;
	
	ИндексНачала = Макс(0, Диалог.Сообщения.Количество() - Количество);
	
	Для Индекс = ИндексНачала По Диалог.Сообщения.Количество() - 1 Цикл
		
		Строка = Диалог.Сообщения[Индекс];
		
		СтруктураСообщения = Новый Структура;
		СтруктураСообщения.Вставить("Время", Строка.Время);
		СтруктураСообщения.Вставить("Автор", Строка.Автор);
		СтруктураСообщения.Вставить("ТипСообщения", Строка.ТипСообщения);
		СтруктураСообщения.Вставить("Текст", Строка.Текст);
		СтруктураСообщения.Вставить("ТекстКода", Строка.ТекстКода);
		СтруктураСообщения.Вставить("Статус", Строка.Статус);
		СтруктураСообщения.Вставить("UsageTokens", Строка.UsageTokens);
		
		МассивСообщений.Добавить(СтруктураСообщения);
		
	КонецЦикла;
	
	Возврат МассивСообщений;
	
КонецФункции

// Добавляет сообщение в диалог
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  Автор - ПеречислениеСсылка.ИИА_АвторСообщения - автор сообщения
//  ТипСообщения - ПеречислениеСсылка.ИИА_ТипСообщения - тип сообщения
//  Текст - Строка - текст сообщения
//  ТекстКода - Строка - текст кода (для запросов)
//  Статус - Строка - статус сообщения
//  UsageTokens - Число - количество использованных токенов
//
Процедура ДобавитьСообщениеВДиалог(СсылкаДиалога, Автор, ТипСообщения, Текст, ТекстКода = "", Статус = "", UsageTokens = 0) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	НоваяСтрока = Диалог.Сообщения.Добавить();
	НоваяСтрока.Время = ТекущаяДата();
	НоваяСтрока.Автор = Автор;
	НоваяСтрока.ТипСообщения = ТипСообщения;
	НоваяСтрока.Текст = Текст;
	НоваяСтрока.ТекстКода = ТекстКода;
	НоваяСтрока.Статус = Статус;
	НоваяСтрока.UsageTokens = UsageTokens;
	
	Диалог.Записать();
	
КонецПроцедуры

// Вызывает ИИ для получения ответа (заглушка)
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  Настройки - Структура - настройки пользователя
//
// Возвращаемое значение:
//  Структура - структура ответа:
//   * ТипОтвета - Строка ("Текст", "Запрос" или "DSL")
//   * Текст - Строка - текст ответа
//   * Запрос - Строка - текст запроса (для типа "Запрос")
//   * DSL - Строка - JSON с DSL-сценарием (для типа "DSL")
//   * ВыполнитьDSL - Булево - выполнить ли DSL сразу (для типа "DSL")
//   * Usage - Структура - информация об использовании токенов
//   * Ошибки - ОписаниеОшибки - информация об ошибках
//
Функция ВызватьИИ(ТипСообщения, ТекстПользователя, История, Настройки) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", "");
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	Результат.Вставить("Usage", Неопределено);
	Результат.Вставить("Ошибки", Неопределено);
	
	// Проверяем настройки подключения
	Если ПустаяСтрока(Настройки.Provider_ApiKey) ИЛИ ПустаяСтрока(Настройки.Provider_BaseUrl) Тогда
		
		Результат.Текст = "Не настроен API ключ или URL провайдера. Настройте подключение к ИИ провайдеру.";
		Возврат Результат;
		
	КонецЕсли;
	
	// Определяем тип провайдера
	ТипПровайдера = "";
	Если Настройки.Свойство("Provider_Type") Тогда
		ТипПровайдера = Настройки.Provider_Type;
	КонецЕсли;
	
	// Если провайдер Гигачат, вызываем его API
	Если ВРег(ТипПровайдера) = "GIGACHAT" ИЛИ ВРег(ТипПровайдера) = "ГИГАЧАТ" ИЛИ ПустаяСтрока(ТипПровайдера) Тогда
		
		Результат = ВызватьГигачат(ТипСообщения, ТекстПользователя, История, Настройки);
		
	Иначе
		
		// Для других провайдеров можно добавить аналогичную логику
		Результат.Текст = "Неподдерживаемый тип провайдера: " + ТипПровайдера;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Вызывает API Гигачат
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  Настройки - Структура - настройки пользователя
//
// Возвращаемое значение:
//  Структура - структура ответа от ИИ
//
Функция ВызватьГигачат(ТипСообщения, ТекстПользователя, История, Настройки)
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", "");
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	Результат.Вставить("Usage", Неопределено);
	Результат.Вставить("Ошибки", Неопределено);
	
	// Формируем URL для запроса
	БазовыйURL = Настройки.Provider_BaseUrl;
	Если ПустаяСтрока(БазовыйURL) Тогда
		БазовыйURL = "https://gigachat.devices.sberbank.ru";
	КонецЕсли;
	
	URLПуть = "/api/v1/chat/completions";
	
	// Получаем метаданные для контекста
	МетаданныеКонтекст = ПолучитьМетаданныеДляИИ();
	
	// Формируем промпт с учетом типа сообщения и метаданных
	Промпт = СформироватьПромптДляИИ(ТипСообщения, ТекстПользователя, История, МетаданныеКонтекст);
	
	// Формируем тело запроса
	ТелоЗапроса = Новый Структура;
	ТелоЗапроса.Вставить("model", "GigaChat");
	ТелоЗапроса.Вставить("messages", Промпт.Сообщения);
	ТелоЗапроса.Вставить("temperature", 0.7);
	ТелоЗапроса.Вставить("max_tokens", 2000);
	
	// Преобразуем в JSON
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, ТелоЗапроса);
	JSONТело = ЗаписьJSON.Закрыть();
	
	// Выполняем HTTP-запрос
	Попытка
		
		HTTPСоединение = Новый HTTPСоединение(БазовыйURL);
		
		Заголовки = Новый Соответствие;
		Заголовки.Вставить("Content-Type", "application/json");
		Заголовки.Вставить("Authorization", "Bearer " + Настройки.Provider_ApiKey);
		
		HTTPЗапрос = Новый HTTPЗапрос(URLПуть, Заголовки);
		HTTPЗапрос.УстановитьТелоИзСтроки(JSONТело);
		
		HTTPОтвет = HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);
		
		Если HTTPОтвет.КодСостояния <> 200 Тогда
			
			Результат.Текст = "Ошибка API Гигачат: " + Формат(HTTPОтвет.КодСостояния, "ЧН=0") + " - " + HTTPОтвет.ПолучитьТелоКакСтроку();
			Возврат Результат;
			
		КонецЕсли;
		
		// Парсим ответ
		ТекстОтвета = HTTPОтвет.ПолучитьТелоКакСтроку();
		
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ТекстОтвета);
		ОтветJSON = ПрочитатьJSON(ЧтениеJSON);
		ЧтениеJSON.Закрыть();
		
		// Извлекаем ответ от ИИ
		Если ОтветJSON.Свойство("choices") И ОтветJSON.choices.Количество() > 0 Тогда
			
			Выбор = ОтветJSON.choices[0];
			Если Выбор.Свойство("message") И Выбор.message.Свойство("content") Тогда
				
				ТекстОтветаИИ = Выбор.message.content;
				
				// Определяем тип ответа и парсим его
				Результат = РаспознатьОтветИИ(ТекстОтветаИИ, ТипСообщения);
				
			КонецЕсли;
			
		КонецЕсли;
		
		// Извлекаем информацию об использовании токенов
		Если ОтветJSON.Свойство("usage") Тогда
			
			UsageStruct = Новый Структура;
			Если ОтветJSON.usage.Свойство("prompt_tokens") Тогда
				UsageStruct.Вставить("PromptTokens", ОтветJSON.usage.prompt_tokens);
			Иначе
				UsageStruct.Вставить("PromptTokens", 0);
			КонецЕсли;
			
			Если ОтветJSON.usage.Свойство("completion_tokens") Тогда
				UsageStruct.Вставить("CompletionTokens", ОтветJSON.usage.completion_tokens);
			Иначе
				UsageStruct.Вставить("CompletionTokens", 0);
			КонецЕсли;
			
			Если ОтветJSON.usage.Свойство("total_tokens") Тогда
				UsageStruct.Вставить("TotalTokens", ОтветJSON.usage.total_tokens);
			Иначе
				UsageStruct.Вставить("TotalTokens", 0);
			КонецЕсли;
			
			UsageStruct.Вставить("ОстатокКредитов", 0); // Гигачат не возвращает информацию о балансе
			
			Результат.Usage = UsageStruct;
			
		КонецЕсли;
		
	Исключение
		
		Результат.Текст = "Ошибка при вызове API Гигачат: " + ОписаниеОшибки();
		Результат.Ошибки = ОписаниеОшибки();
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Получает метаданные конфигурации для передачи в ИИ
//
// Возвращаемое значение:
//  Структура - структура с метаданными
//
Функция ПолучитьМетаданныеДляИИ()
	
	Результат = Новый Структура;
	
	// Получаем списки объектов
	Результат.Вставить("Справочники", ИИА_Метаданные.ПолучитьСписокСправочников());
	Результат.Вставить("Документы", ИИА_Метаданные.ПолучитьСписокДокументов());
	Результат.Вставить("РегистрыСведений", ИИА_Метаданные.ПолучитьСписокРегистровСведений());
	Результат.Вставить("РегистрыНакопления", ИИА_Метаданные.ПолучитьСписокРегистровНакопления());
	Результат.Вставить("РегистрыБухгалтерии", ИИА_Метаданные.ПолучитьСписокРегистровБухгалтерии());
	
	Возврат Результат;
	
КонецФункции

// Формирует промпт для ИИ с учетом контекста
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  МетаданныеКонтекст - Структура - метаданные конфигурации
//
// Возвращаемое значение:
//  Структура - структура с сообщениями для ИИ
//
Функция СформироватьПромптДляИИ(ТипСообщения, ТекстПользователя, История, МетаданныеКонтекст)
	
	Результат = Новый Структура;
	Сообщения = Новый Массив;
	
	// Системный промпт
	СистемноеСообщение = Новый Структура;
	СистемноеСообщение.Вставить("role", "system");
	
	СистемныйПромпт = "Ты - ИИ-ассистент для работы с системой 1С:Предприятие. " + Символы.ПС +
		"Твоя задача - понимать команды пользователя и генерировать безопасные DSL-сценарии или запросы на языке запросов 1С." + Символы.ПС +
		Символы.ПС +
		"Доступные объекты конфигурации:" + Символы.ПС;
	
	// Добавляем информацию о справочниках
	Если МетаданныеКонтекст.Свойство("Справочники") Тогда
		СистемныйПромпт = СистемныйПромпт + "Справочники: ";
		Для Каждого Справочник Из МетаданныеКонтекст.Справочники Цикл
			СистемныйПромпт = СистемныйПромпт + Справочник.Имя + " (" + Справочник.Синоним + "), ";
		КонецЦикла;
		СистемныйПромпт = Лев(СистемныйПромпт, СтрДлина(СистемныйПромпт) - 2) + Символы.ПС;
	КонецЕсли;
	
	// Добавляем информацию о документах
	Если МетаданныеКонтекст.Свойство("Документы") Тогда
		СистемныйПромпт = СистемныйПромпт + "Документы: ";
		Для Каждого Документ Из МетаданныеКонтекст.Документы Цикл
			СистемныйПромпт = СистемныйПромпт + Документ.Имя + " (" + Документ.Синоним + "), ";
		КонецЦикла;
		СистемныйПромпт = Лев(СистемныйПромпт, СтрДлина(СистемныйПромпт) - 2) + Символы.ПС;
	КонецЕсли;
	
	СистемныйПромпт = СистемныйПромпт + Символы.ПС +
		"Формат DSL-сценария:" + Символы.ПС +
		"{""dsl_version"": 1, ""steps"": [{""action"": ""CreateReference"", ""object_name"": ""ИмяСправочника""}, ...]}" + Символы.ПС +
		"Доступные действия: CreateReference, CreateDocument, FindReferenceByName, SetField, Write, RunQuery, ShowInfo" + Символы.ПС +
		Символы.ПС +
		"Если пользователь просит создать или найти объект, генерируй DSL-сценарий в формате JSON." + Символы.ПС +
		"Если пользователь просит выполнить запрос, генерируй запрос на языке запросов 1С.";
	
	СистемноеСообщение.Вставить("content", СистемныйПромпт);
	Сообщения.Добавить(СистемноеСообщение);
	
	// Добавляем историю диалога
	Для Каждого СтрокаИстории Из История Цикл
		
		Сообщение = Новый Структура;
		
		Если СтрокаИстории.Автор = Перечисления.ИИА_АвторСообщения.Пользователь Тогда
			Сообщение.Вставить("role", "user");
		Иначе
			Сообщение.Вставить("role", "assistant");
		КонецЕсли;
		
		ТекстСообщения = СтрокаИстории.Текст;
		Если НЕ ПустаяСтрока(СтрокаИстории.ТекстКода) Тогда
			ТекстСообщения = ТекстСообщения + Символы.ПС + "```" + Символы.ПС + СтрокаИстории.ТекстКода + Символы.ПС + "```";
		КонецЕсли;
		
		Сообщение.Вставить("content", ТекстСообщения);
		Сообщения.Добавить(Сообщение);
		
	КонецЦикла;
	
	// Добавляем текущее сообщение пользователя
	ТекущееСообщение = Новый Структура;
	ТекущееСообщение.Вставить("role", "user");
	ТекущееСообщение.Вставить("content", ТекстПользователя);
	Сообщения.Добавить(ТекущееСообщение);
	
	Результат.Вставить("Сообщения", Сообщения);
	
	Возврат Результат;
	
КонецФункции

// Распознает ответ ИИ и определяет его тип
//
// Параметры:
//  ТекстОтветаИИ - Строка - текст ответа от ИИ
//  ТипСообщения - Строка - тип исходного сообщения
//
// Возвращаемое значение:
//  Структура - структура результата с распознанным типом и данными
//
Функция РаспознатьОтветИИ(ТекстОтветаИИ, ТипСообщения)
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", ТекстОтветаИИ);
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	
	// Пытаемся найти JSON в ответе (DSL-сценарий)
	НачалоОткрывающейСкобки = СтрНайти(ТекстОтветаИИ, "{");
	КонецЗакрывающейСкобки = СтрНайти(ТекстОтветаИИ, "}", , НачалоОткрывающейСкобки);
	
	Если НачалоОткрывающейСкобки > 0 И КонецЗакрывающейСкобки > 0 Тогда
		
		ВозможныйJSON = Сред(ТекстОтветаИИ, НачалоОткрывающейСкобки, КонецЗакрывающейСкобки - НачалоОткрывающейСкобки + 1);
		
		Попытка
			
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ВозможныйJSON);
			ПроверкаJSON = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			
			// Проверяем, что это DSL-сценарий
			Если ПроверкаJSON.Свойство("dsl_version") И ПроверкаJSON.Свойство("steps") Тогда
				
				Результат.ТипОтвета = "DSL";
				Результат.DSL = ВозможныйJSON;
				Результат.Текст = "Сгенерирован DSL-сценарий:";
				Результат.ВыполнитьDSL = Ложь; // По умолчанию не выполняем автоматически
				
				Возврат Результат;
				
			КонецЕсли;
			
		Исключение
			// Не JSON или не DSL - продолжаем как обычный текст
		КонецПопытки;
		
	КонецЕсли;
	
	// Если тип сообщения "Запрос", пытаемся найти запрос в ответе
	Если ТипСообщения = "Запрос" Тогда
		
		// Ищем блок кода с запросом
		НачалоБлока = СтрНайти(ТекстОтветаИИ, "```");
		Если НачалоБлока > 0 Тогда
			
			КонецБлока = СтрНайти(ТекстОтветаИИ, "```", НачалоБлока + 3);
			Если КонецБлока > 0 Тогда
				
				ТекстЗапроса = Сред(ТекстОтветаИИ, НачалоБлока + 3, КонецБлока - НачалоБлока - 3);
				ТекстЗапроса = СокрЛП(ТекстЗапроса);
				
				// Проверяем, что это похоже на запрос 1С
				Если СтрНайти(ВРег(ТекстЗапроса), "ВЫБРАТЬ") > 0 Тогда
					
					Результат.ТипОтвета = "Запрос";
					Результат.Запрос = ТекстЗапроса;
					Результат.Текст = "Сгенерирован запрос:";
					
					Возврат Результат;
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// По умолчанию возвращаем как текст
	Возврат Результат;
	
КонецФункции

// Исправляет DSL-сценарий через ИИ при ошибке выполнения
//
// Параметры:
//  DSLJSON - Строка - исходный DSL-сценарий с ошибкой
//  ТекстОшибки - Строка - текст ошибки выполнения
//  Настройки - Структура - настройки пользователя
//
// Возвращаемое значение:
//  Структура - структура результата:
//   * Успех - Булево
//   * Сообщение - Строка
//   * ИсправленныйDSL - Строка - исправленный DSL-сценарий
//
Функция ИсправитьDSLЧерезИИ(DSLJSON, ТекстОшибки, Настройки)
	
	Результат = Новый Структура;
	Результат.Вставить("Успех", Ложь);
	Результат.Вставить("Сообщение", "");
	Результат.Вставить("ИсправленныйDSL", "");
	
	// Формируем промпт для исправления
	ПромптИсправления = "Исправь следующий DSL-сценарий, который вызвал ошибку:" + Символы.ПС +
		"Ошибка: " + ТекстОшибки + Символы.ПС +
		"Исходный DSL:" + Символы.ПС +
		DSLJSON + Символы.ПС +
		"Верни только исправленный JSON без дополнительных комментариев.";
	
	// Вызываем ИИ для исправления
	Попытка
		
		БазовыйURL = Настройки.Provider_BaseUrl;
		Если ПустаяСтрока(БазовыйURL) Тогда
			БазовыйURL = "https://gigachat.devices.sberbank.ru";
		КонецЕсли;
		
		URLПуть = "/api/v1/chat/completions";
		
		Сообщения = Новый Массив;
		Сообщение = Новый Структура;
		Сообщение.Вставить("role", "user");
		Сообщение.Вставить("content", ПромптИсправления);
		Сообщения.Добавить(Сообщение);
		
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("model", "GigaChat");
		ТелоЗапроса.Вставить("messages", Сообщения);
		ТелоЗапроса.Вставить("temperature", 0.3); // Низкая температура для более точного исправления
		ТелоЗапроса.Вставить("max_tokens", 2000);
		
		ЗаписьJSON = Новый ЗаписьJSON;
		ЗаписьJSON.УстановитьСтроку();
		ЗаписатьJSON(ЗаписьJSON, ТелоЗапроса);
		JSONТело = ЗаписьJSON.Закрыть();
		
		HTTPСоединение = Новый HTTPСоединение(БазовыйURL);
		
		Заголовки = Новый Соответствие;
		Заголовки.Вставить("Content-Type", "application/json");
		Заголовки.Вставить("Authorization", "Bearer " + Настройки.Provider_ApiKey);
		
		HTTPЗапрос = Новый HTTPЗапрос(URLПуть, Заголовки);
		HTTPЗапрос.УстановитьТелоИзСтроки(JSONТело);
		
		HTTPОтвет = HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);
		
		Если HTTPОтвет.КодСостояния = 200 Тогда
			
			ТекстОтвета = HTTPОтвет.ПолучитьТелоКакСтроку();
			
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ТекстОтвета);
			ОтветJSON = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			
			Если ОтветJSON.Свойство("choices") И ОтветJSON.choices.Количество() > 0 Тогда
				
				Выбор = ОтветJSON.choices[0];
				Если Выбор.Свойство("message") И Выбор.message.Свойство("content") Тогда
					
					ТекстИсправления = Выбор.message.content;
					
					// Извлекаем JSON из ответа
					НачалоОткрывающейСкобки = СтрНайти(ТекстИсправления, "{");
					КонецЗакрывающейСкобки = СтрНайти(ТекстИсправления, "}", , НачалоОткрывающейСкобки);
					
					Если НачалоОткрывающейСкобки > 0 И КонецЗакрывающейСкобки > 0 Тогда
						
						ИсправленныйJSON = Сред(ТекстИсправления, НачалоОткрывающейСкобки, КонецЗакрывающейСкобки - НачалоОткрывающейСкобки + 1);
						
						// Проверяем исправленный DSL
						РезультатПроверки = ПроверитьDSLСценарий(ИсправленныйJSON);
						Если РезультатПроверки.Успех Тогда
							
							Результат.Успех = Истина;
							Результат.ИсправленныйDSL = ИсправленныйJSON;
							Результат.Сообщение = "DSL-сценарий исправлен";
							
						Иначе
							
							Результат.Сообщение = "Исправленный DSL также содержит ошибки: " + РезультатПроверки.Сообщение;
							
						КонецЕсли;
						
					Иначе
						
						Результат.Сообщение = "Не удалось извлечь JSON из ответа ИИ";
						
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЕсли;
			
		Иначе
			
			Результат.Сообщение = "Ошибка API при исправлении: " + Формат(HTTPОтвет.КодСостояния, "ЧН=0");
			
		КонецЕсли;
		
	Исключение
		
		Результат.Сообщение = "Ошибка при исправлении DSL: " + ОписаниеОшибки();
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Получает пример DSL-сценария (заглушка для демонстрации)
//
// Параметры:
//  ТекстПользователя - Строка - текст команды пользователя
//
// Возвращаемое значение:
//  Строка - JSON с DSL-сценарием
//
Функция ПолучитьПримерDSLСценария(ТекстПользователя)
	
	// Это заглушка - в реальной реализации ИИ должен генерировать DSL на основе команды пользователя
	// и метаданных конфигурации
	
	ПримерСценария = Новый Структура;
	ПримерСценария.Вставить("dsl_version", 1);
	
	Шаги = Новый Массив;
	
	// Пример: создание элемента справочника
	Если СтрНайти(ВРег(ТекстПользователя), "КОНТРАГЕНТ") > 0 Тогда
		
		Шаг1 = Новый Структура;
		Шаг1.Вставить("action", "CreateReference");
		Шаг1.Вставить("object_name", "Контрагенты");
		Шаги.Добавить(Шаг1);
		
		Шаг2 = Новый Структура;
		Шаг2.Вставить("action", "SetField");
		Шаг2.Вставить("field", "Наименование");
		Шаг2.Вставить("value", "Новый контрагент");
		Шаги.Добавить(Шаг2);
		
		Шаг3 = Новый Структура;
		Шаг3.Вставить("action", "Write");
		Шаги.Добавить(Шаг3);
		
	Иначе
		
		// Общий пример
		Шаг1 = Новый Структура;
		Шаг1.Вставить("action", "ShowInfo");
		Шаг1.Вставить("message", "Пример DSL-сценария. Настройте ИИ для генерации реальных сценариев.");
		Шаги.Добавить(Шаг1);
		
	КонецЕсли;
	
	ПримерСценария.Вставить("steps", Шаги);
	
	// Преобразуем в JSON
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, ПримерСценария);
	JSONСтрока = ЗаписьJSON.Закрыть();
	
	Возврат JSONСтрока;
	
КонецФункции

// Отправляет сообщение и получает ответ от ИИ
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//
// Возвращаемое значение:
//  Структура - структура ответа от ВызватьИИ
//
Функция ОтправитьСообщениеСервера(СсылкаДиалога, ТипСообщения, ТекстПользователя) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	Пользователь = Диалог.Пользователь;
	
	// Получаем настройки пользователя
	Настройки = ПолучитьНастройкиПользователя(Пользователь);
	
	// Загружаем историю диалога
	История = ПолучитьСообщенияДиалога(СсылкаДиалога, 10);
	
	// Определяем тип сообщения для хранения
	Если ТипСообщения = "Запрос" Тогда
		ТипСообщенияДляХранения = Перечисления.ИИА_ТипСообщения.Запрос;
	Иначе
		ТипСообщенияДляХранения = Перечисления.ИИА_ТипСообщения.Текст;
	КонецЕсли;
	
	// Добавляем сообщение пользователя
	ДобавитьСообщениеВДиалог(
		СсылкаДиалога,
		Перечисления.ИИА_АвторСообщения.Пользователь,
		ТипСообщенияДляХранения,
		ТекстПользователя
	);
	
	// Вызываем ИИ
	ОтветИИ = ВызватьИИ(ТипСообщения, ТекстПользователя, История, Настройки);
	
	// Определяем тип ответа для хранения
	Если ОтветИИ.ТипОтвета = "Запрос" Тогда
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Запрос;
		ТекстОтвета = ОтветИИ.Текст;
		ТекстКодаОтвета = ОтветИИ.Запрос;
	ИначеЕсли ОтветИИ.ТипОтвета = "DSL" Тогда
		// Обрабатываем DSL-сценарий
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Код;
		ТекстОтвета = ОтветИИ.Текст;
		ТекстКодаОтвета = ОтветИИ.DSL;
		
		// Выполняем DSL, если требуется
		Если ОтветИИ.Свойство("ВыполнитьDSL") И ОтветИИ.ВыполнитьDSL Тогда
			
			РезультатDSL = ВыполнитьDSLСценарий(ОтветИИ.DSL);
			
			Если РезультатDSL.Успех Тогда
				ТекстОтвета = ТекстОтвета + Символы.ПС + "DSL-сценарий выполнен успешно.";
				
				// Добавляем информацию о результатах
				Если РезультатDSL.Результаты.Количество() > 0 Тогда
					Для Каждого РезультатШага Из РезультатDSL.Результаты Цикл
						ТекстОтвета = ТекстОтвета + Символы.ПС + "- " + РезультатШага.Сообщение;
					КонецЦикла;
				КонецЕсли;
				
			Иначе
				// Пытаемся исправить ошибку через ИИ
				ТекстОтвета = ТекстОтвета + Символы.ПС + "Ошибка выполнения DSL: " + РезультатDSL.Сообщение;
				
				РезультатКоррекции = ИсправитьDSLЧерезИИ(ОтветИИ.DSL, РезультатDSL.Сообщение, Настройки);
				Если РезультатКоррекции.Успех Тогда
					ТекстОтвета = ТекстОтвета + Символы.ПС + "Попытка исправления: " + РезультатКоррекции.Сообщение;
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	Иначе
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Текст;
		ТекстОтвета = ОтветИИ.Текст;
		ТекстКодаОтвета = "";
	КонецЕсли;
	
	// Получаем UsageTokens
	UsageTokens = 0;
	Если ОтветИИ.Usage <> Неопределено Тогда
		UsageTokens = ОтветИИ.Usage.TotalTokens;
	КонецЕсли;
	
	// Добавляем ответ ИИ
	ДобавитьСообщениеВДиалог(
		СсылкаДиалога,
		Перечисления.ИИА_АвторСообщения.ИИ,
		ТипСообщенияОтвета,
		ТекстОтвета,
		ТекстКодаОтвета,
		"",
		UsageTokens
	);
	
	Возврат ОтветИИ;
	
КонецФункции

// Проверяет запрос 1С на выполнимость
//
// Параметры:
//  ТекстЗапроса - Строка - текст запроса
//
// Возвращаемое значение:
//  Структура - структура результата:
//   * Успех - Булево - успешность выполнения
//   * Сообщение - Строка - текст ошибки или пусто
//
Функция ПроверитьЗапрос(ТекстЗапроса) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Успех", Ложь);
	Результат.Вставить("Сообщение", "");
	
	Попытка
		
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.Выполнить();
		
		Результат.Успех = Истина;
		
	Исключение
		
		Результат.Сообщение = ОписаниеОшибки();
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Выполняет DSL сценарий
//
// Параметры:
//  DSLJSON - Строка - JSON с DSL командами
//
// Возвращаемое значение:
//  Структура - структура результата выполнения DSL
//
Функция ВыполнитьDSLСценарий(DSLJSON) Экспорт
	
	Возврат ИИА_DSL.ВыполнитьDSL(DSLJSON);
	
КонецФункции

// Проверяет DSL сценарий
//
// Параметры:
//  DSLJSON - Строка - JSON с DSL командами
//
// Возвращаемое значение:
//  Структура - структура результата проверки DSL
//
Функция ПроверитьDSLСценарий(DSLJSON) Экспорт
	
	Возврат ИИА_DSL.ПроверитьDSL(DSLJSON);
	
КонецФункции

#КонецОбласти


