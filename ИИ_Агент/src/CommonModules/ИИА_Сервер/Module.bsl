#Область ПрограммныйИнтерфейс

// Получает настройки пользователя из регистра сведений
//
// Параметры:
//  Пользователь - СправочникСсылка.Пользователи - пользователь, для которого получить настройки
//
// Возвращаемое значение:
//  Структура - структура с настройками:
//   * РежимПодключения - ПеречислениеСсылка.ИИА_РежимПодключения
//   * Gitsell_Endpoint - Строка
//   * Gitsell_AccessToken - Строка
//   * Provider_BaseURL - Строка
//   * Provider_ApiKey - Строка
//   * ProviderType - Строка
//
Функция ПолучитьНастройкиПользователя(Пользователь) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("РежимПодключения", Неопределено);
	Результат.Вставить("Gitsell_Endpoint", "");
	Результат.Вставить("Gitsell_AccessToken", "");
	Результат.Вставить("Provider_BaseUrl", "");
	Результат.Вставить("Provider_ApiKey", "");
	Результат.Вставить("Provider_Type", "");
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	НастройкиПользователя.РежимПодключения,
	|	НастройкиПользователя.Gitsell_Endpoint,
	|	НастройкиПользователя.Gitsell_AccessToken,
	|	НастройкиПользователя.Provider_BaseUrl,
	|	НастройкиПользователя.Provider_ApiKey,
	|	НастройкиПользователя.Provider_Type,
	|	НастройкиПользователя.Токен,
	|	НастройкиПользователя.ОкончаниеТокена,
	|	НастройкиПользователя.АвторизационныеДанные,
	|	НастройкиПользователя.Scope
	|ИЗ
	|	РегистрСведений.ИИА_НастройкиПользователей КАК НастройкиПользователя
	|ГДЕ
	|	НастройкиПользователя.Пользователь = &Пользователь";
	
	Запрос.УстановитьПараметр("Пользователь", Пользователь);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат Результат;
	КонецЕсли;
	
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	
	Результат.РежимПодключения = Выборка.РежимПодключения;
	Результат.Gitsell_Endpoint = Выборка.Gitsell_Endpoint;
	Результат.Gitsell_AccessToken = Выборка.Gitsell_AccessToken;
	Результат.Вставить("Provider_BaseUrl", Выборка.Provider_BaseUrl);
	Результат.Вставить("Provider_ApiKey", Выборка.Provider_ApiKey);
	Результат.Вставить("Provider_Type", Выборка.Provider_Type);
	Результат.Вставить("Токен", Выборка.Токен);
	Результат.Вставить("ОкончаниеТокена", Выборка.ОкончаниеТокена);
	Результат.Вставить("АвторизационныеДанные", Выборка.АвторизационныеДанные);
	Результат.Вставить("Scope", Выборка.Scope);
	
	Возврат Результат;
	
КонецФункции

// Получает токен доступа для Гигачат (с кешированием на 30 минут)
//
// Параметры:
//  Настройки - Структура - настройки пользователя
//
// Возвращаемое значение:
//  Строка - токен доступа
//
Функция ПолучитьТокенДоступа(Настройки) Экспорт
	
	// Если токен еще действует (30 минут), возвращаем его
	// В Python коде используется: datetime.now() + timedelta(seconds=expires_at / 1000 - 60)
	// То есть токен считается действительным до expires_at минус 60 секунд
	// Сравниваем в локальном времени (так как ОкончаниеТокена хранится в локальном времени)
	ТекущееВремя = ТекущаяДата();
	
	Если ЗначениеЗаполнено(Настройки.Токен) 
		И ЗначениеЗаполнено(Настройки.ОкончаниеТокена)
		И Настройки.ОкончаниеТокена > ТекущееВремя Тогда
		// Токен еще действует
		Возврат Настройки.Токен;
	КонецЕсли;
	
	// Получаем новый токен
	Возврат ПолучитьНовыйТокенДоступа(Настройки);
	
КонецФункции

// Получает новый токен доступа через OAuth
//
// Параметры:
//  Настройки - Структура - настройки пользователя (входной/выходной)
//
// Возвращаемое значение:
//  Строка - новый токен доступа
//
Функция ПолучитьНовыйТокенДоступа(Настройки)
	
	// Проверяем наличие авторизационных данных
	Если ПустаяСтрока(Настройки.АвторизационныеДанные) Тогда
		// Если нет авторизационных данных, используем Provider_ApiKey напрямую
		Возврат Настройки.Provider_ApiKey;
	КонецЕсли;
	
	Попытка
		
		// Подключаемся к OAuth серверу
		Соединение = Новый HTTPСоединение("ngw.devices.sberbank.ru:9443", , , , , , Новый ЗащищенноеСоединениеOpenSSL());
		
		Заголовки = Новый Соответствие;
		Заголовки.Вставить("RqUID", Строка(Новый УникальныйИдентификатор));
		Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
		Заголовки.Вставить("Accept", "application/json");
		// Для получения токена используется Basic авторизация, а не Bearer!
		Заголовки.Вставить("Authorization", "Basic " + Настройки.АвторизационныеДанные);
		
		Scope = "GIGACHAT_API_PERS";
		Если НЕ ПустаяСтрока(Настройки.Scope) Тогда
			Scope = Настройки.Scope;
		КонецЕсли;
		
		Запрос = Новый HTTPЗапрос("/api/v2/oauth", Заголовки);
		Запрос.УстановитьТелоИзСтроки("scope=" + Scope);
		Результат = Соединение.ОтправитьДляОбработки(Запрос);
		
		Если Результат.КодСостояния = 200 Тогда
			
			ТекстОтвета = Результат.ПолучитьТелоКакСтроку();
			ЧтениеJson = Новый ЧтениеJson;
			ЧтениеJson.УстановитьСтроку(ТекстОтвета);
			РезСтруктура = ПрочитатьJSON(ЧтениеJson);
			ЧтениеJson.Закрыть();
			
			// Проверяем наличие access_token в ответе
			Если НЕ РезСтруктура.Свойство("access_token") Тогда
				ВызватьИсключение "В ответе OAuth отсутствует access_token. Ответ: " + ТекстОтвета;
			КонецЕсли;
			
			НовыйТокен = РезСтруктура.access_token;
			
			// Проверяем, что токен не пустой
			Если ПустаяСтрока(НовыйТокен) Тогда
				ВызватьИсключение "Получен пустой access_token. Ответ: " + ТекстОтвета;
			КонецЕсли;
			ДатаОкончания = ПреобразоватьДатуUnix(РезСтруктура.expires_at);
			
			// Сохраняем токен в настройках (если есть возможность)
			Настройки.Вставить("Токен", НовыйТокен);
			Настройки.Вставить("ОкончаниеТокена", ДатаОкончания);
			
			// Пытаемся сохранить в регистр сведений
			Попытка
				СохранитьТокенВНастройки(Настройки);
			Исключение
				// Если не удалось сохранить, продолжаем работу
			КонецПопытки;
			
			Возврат НовыйТокен;
			
		Иначе
			
			ТекстОшибки = Результат.ПолучитьТелоКакСтроку();
			ВызватьИсключение "Не удалось получить токен доступа. Код ошибки: " + Формат(Результат.КодСостояния, "ЧН=0") + " " + ТекстОшибки;
			
		КонецЕсли;
		
	Исключение
		
		// Если ошибка при получении токена, используем Provider_ApiKey напрямую
		Если НЕ ПустаяСтрока(Настройки.Provider_ApiKey) Тогда
			Возврат Настройки.Provider_ApiKey;
		Иначе
			ВызватьИсключение "Ошибка при получении токена доступа: " + ОписаниеОшибки();
		КонецЕсли;
		
	КонецПопытки;
	
КонецФункции

// Преобразует дату из формата Unix timestamp в дату 1С
//
// Параметры:
//  Значение - Число - Unix timestamp в миллисекундах (как в GigaChat API)
//
// Возвращаемое значение:
//  Дата - дата в формате 1С
//
Функция ПреобразоватьДатуUnix(Значение)
	
	Результат = Дата(1, 1, 1);
	Если ЗначениеЗаполнено(Значение) Тогда
		// GigaChat возвращает expires_at в миллисекундах как Unix timestamp (абсолютное время в UTC)
		// Преобразуем в дату 1С, вычитая 60 секунд для безопасности
		ЗначениеВСекундах = Значение / 1000 - 60;
		
		// Преобразуем Unix timestamp в дату 1С
		// Unix timestamp - это количество секунд с 1 января 1970 года 00:00:00 UTC
		// В 1С дата хранится в локальном времени
		// Вычисляем смещение часового пояса (разница между локальным и UTC)
		ТекущееЛокальное = ТекущаяДата();
		ТекущееUTC = УниверсальноеВремя(ТекущееЛокальное);
		СмещениеСекунд = ТекущееЛокальное - ТекущееUTC;
		
		// Начало эпохи Unix в UTC: 1970-01-01 00:00:00 UTC
		// Преобразуем в локальное время: прибавляем смещение часового пояса
		НачалоЭпохиUnixUTC = Дата(1970, 1, 1, 0, 0, 0);
		НачалоЭпохиUnixЛокальное = НачалоЭпохиUnixUTC + СмещениеСекунд;
		
		// Добавляем секунды Unix timestamp и получаем дату в локальном времени
		Результат = НачалоЭпохиUnixЛокальное + ЗначениеВСекундах;
		
	КонецЕсли;
	Возврат Результат;
	
КонецФункции

// Сохраняет токен в регистр сведений настроек пользователя
//
// Параметры:
//  Настройки - Структура - настройки пользователя (входной/выходной)
//
Процедура СохранитьТокенВНастройки(Настройки)
	
	// Получаем пользователя из настроек
	Если НЕ Настройки.Свойство("Пользователь") Тогда
		Возврат;
	КонецЕсли;
	
	Пользователь = Настройки.Пользователь;
	
	// Получаем набор записей
	НаборЗаписей = РегистрыСведений.ИИА_НастройкиПользователей.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Пользователь.Установить(Пользователь);
	
	// Ищем существующую запись
	НаборЗаписей.Прочитать();
	
	Если НаборЗаписей.Количество() = 0 Тогда
		// Создаем новую запись
		НоваяЗапись = НаборЗаписей.Добавить();
		НоваяЗапись.Пользователь = Пользователь;
	Иначе
		// Используем существующую запись
		НоваяЗапись = НаборЗаписей[0];
	КонецЕсли;
	
	// Обновляем токен и дату окончания
	НоваяЗапись.Токен = Настройки.Токен;
	НоваяЗапись.ОкончаниеТокена = Настройки.ОкончаниеТокена;
	
	НаборЗаписей.Записать();
	
КонецПроцедуры

// Находит активный диалог пользователя или создает новый
//
// Параметры:
//  Пользователь - СправочникСсылка.Пользователи - пользователь
//
// Возвращаемое значение:
//  СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//
Функция НайтиИлиСоздатьДиалогПользователя(Пользователь) Экспорт
	
	// Ищем активный диалог
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Диалоги.Ссылка
	|ИЗ
	|	Справочник.ИИА_Диалоги КАК Диалоги
	|ГДЕ
	|	Диалоги.Пользователь = &Пользователь
	|	И Диалоги.Активный = ИСТИНА
	|УПОРЯДОЧИТЬ ПО
	|	Диалоги.ДатаСоздания УБЫВ";
	
	Запрос.УстановитьПараметр("Пользователь", Пользователь);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат Выборка.Ссылка;
	КонецЕсли;
	
	// Создаем новый диалог
	НовыйДиалог = Справочники.ИИА_Диалоги.СоздатьЭлемент();
	НовыйДиалог.Пользователь = Пользователь;
	НовыйДиалог.Имя = "Диалог ИИ от " + Формат(ТекущаяДата(), "ДФ=dd.MM.yyyy HH:mm:ss");
	НовыйДиалог.ДатаСоздания = ТекущаяДата();
	НовыйДиалог.Активный = Истина;
	НовыйДиалог.Записать();
	
	Возврат НовыйДиалог.Ссылка;
	
КонецФункции

// Получает сообщения диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  Количество - Число - количество последних сообщений
//
// Возвращаемое значение:
//  Массив - массив структур с сообщениями
//
Функция ПолучитьСообщенияДиалога(СсылкаДиалога, Количество = 50) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	МассивСообщений = Новый Массив;
	
	ИндексНачала = Макс(0, Диалог.Сообщения.Количество() - Количество);
	
	Для Индекс = ИндексНачала По Диалог.Сообщения.Количество() - 1 Цикл
		
		Строка = Диалог.Сообщения[Индекс];
		
		СтруктураСообщения = Новый Структура;
		СтруктураСообщения.Вставить("Время", Строка.Время);
		СтруктураСообщения.Вставить("Автор", Строка.Автор);
		СтруктураСообщения.Вставить("ТипСообщения", Строка.ТипСообщения);
		СтруктураСообщения.Вставить("Текст", Строка.Текст);
		СтруктураСообщения.Вставить("ТекстКода", Строка.ТекстКода);
		СтруктураСообщения.Вставить("Статус", Строка.Статус);
		СтруктураСообщения.Вставить("UsageTokens", Строка.UsageTokens);
		
		МассивСообщений.Добавить(СтруктураСообщения);
		
	КонецЦикла;
	
	Возврат МассивСообщений;
	
КонецФункции

// Добавляет сообщение в диалог
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  Автор - ПеречислениеСсылка.ИИА_АвторСообщения - автор сообщения
//  ТипСообщения - ПеречислениеСсылка.ИИА_ТипСообщения - тип сообщения
//  Текст - Строка - текст сообщения
//  ТекстКода - Строка - текст кода (для запросов)
//  Статус - Строка - статус сообщения
//  UsageTokens - Число - количество использованных токенов
//
Процедура ДобавитьСообщениеВДиалог(СсылкаДиалога, Автор, ТипСообщения, Текст, ТекстКода = "", Статус = "", UsageTokens = 0, СтатусDSL = Неопределено) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	
	НоваяСтрока = Диалог.Сообщения.Добавить();
	НоваяСтрока.Время = ТекущаяДата();
	НоваяСтрока.Автор = Автор;
	НоваяСтрока.ТипСообщения = ТипСообщения;
	НоваяСтрока.Текст = Текст;
	НоваяСтрока.ТекстКода = ТекстКода;
	НоваяСтрока.Статус = Статус;
	НоваяСтрока.UsageTokens = UsageTokens;
	
	// Устанавливаем статус DSL
	Если СтатусDSL = Неопределено Тогда
		// Если есть ТекстКода и это DSL, устанавливаем "ВОчереди", иначе "НеПрименяется"
		Если НЕ ПустаяСтрока(ТекстКода) И ТипСообщения = Перечисления.ИИА_ТипСообщения.Код Тогда
			НоваяСтрока.СтатусDSL = Перечисления.ИИА_СтатусDSL.ВОчереди;
		Иначе
			НоваяСтрока.СтатусDSL = Перечисления.ИИА_СтатусDSL.НеПрименяется;
		КонецЕсли;
	Иначе
		НоваяСтрока.СтатусDSL = СтатусDSL;
	КонецЕсли;
	
	Диалог.Записать();
	
КонецПроцедуры

// Вызывает ИИ для получения ответа (заглушка)
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  Настройки - Структура - настройки пользователя
//
// Возвращаемое значение:
//  Структура - структура ответа:
//   * ТипОтвета - Строка ("Текст", "Запрос" или "DSL")
//   * Текст - Строка - текст ответа
//   * Запрос - Строка - текст запроса (для типа "Запрос")
//   * DSL - Строка - JSON с DSL-сценарием (для типа "DSL")
//   * ВыполнитьDSL - Булево - выполнить ли DSL сразу (для типа "DSL")
//   * Usage - Структура - информация об использовании токенов
//   * Ошибки - ОписаниеОшибки - информация об ошибках
//
Функция ВызватьИИ(ТипСообщения, ТекстПользователя, История, Настройки) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", "");
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	Результат.Вставить("Usage", Неопределено);
	Результат.Вставить("Ошибки", Неопределено);
	
	// Проверяем настройки подключения
	Если ПустаяСтрока(Настройки.Provider_ApiKey) ИЛИ ПустаяСтрока(Настройки.Provider_BaseUrl) Тогда
		
		Результат.Текст = "Не настроен API ключ или URL провайдера. Настройте подключение к ИИ провайдеру.";
		Возврат Результат;
		
	КонецЕсли;
	
	// Определяем тип провайдера
	ТипПровайдера = "";
	Если Настройки.Свойство("Provider_Type") Тогда
		ТипПровайдера = Настройки.Provider_Type;
	КонецЕсли;
	
	// Если провайдер Гигачат, вызываем его API
	Если ВРег(ТипПровайдера) = "GIGACHAT" ИЛИ ВРег(ТипПровайдера) = "ГИГАЧАТ" ИЛИ ПустаяСтрока(ТипПровайдера) Тогда
		
		Результат = ВызватьГигачат(ТипСообщения, ТекстПользователя, История, Настройки);
		
	Иначе
		
		// Для других провайдеров можно добавить аналогичную логику
		Результат.Текст = "Неподдерживаемый тип провайдера: " + ТипПровайдера;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Вызывает API Гигачат
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  Настройки - Структура - настройки пользователя
//
// Возвращаемое значение:
//  Структура - структура ответа от ИИ
//
Функция ВызватьГигачат(ТипСообщения, ТекстПользователя, История, Настройки)
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", "");
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	Результат.Вставить("Usage", Неопределено);
	Результат.Вставить("Ошибки", Неопределено);
	
	// Формируем URL для запроса (как в Python коде)
	URLИзНастроек = Настройки.Provider_BaseUrl;
	Если ПустаяСтрока(URLИзНастроек) Тогда
		URLИзНастроек = "https://gigachat.devices.sberbank.ru/api/v1";
	КонецЕсли;
	
	// Если в URL нет /api/v1, добавляем его
	Если СтрНайти(ВРег(URLИзНастроек), "/API/V1") = 0 Тогда
		// Убираем завершающий слеш, если есть
		Если Прав(URLИзНастроек, 1) = "/" Тогда
			URLИзНастроек = Лев(URLИзНастроек, СтрДлина(URLИзНастроек) - 1);
		КонецЕсли;
		URLИзНастроек = URLИзНастроек + "/api/v1";
	КонецЕсли;
	
	// Убираем завершающий слеш, если есть (как в Python: rstrip('/'))
	Если Прав(URLИзНастроек, 1) = "/" Тогда
		URLИзНастроек = Лев(URLИзНастроек, СтрДлина(URLИзНастроек) - 1);
	КонецЕсли;
	
	// Формируем полный URL (как в Python: f"{base_url.rstrip('/')}/chat/completions")
	ПолныйURL = URLИзНастроек + "/chat/completions";
	
	// Разделяем на домен и путь для HTTPСоединение
	// Убираем протокол https:// если есть
	URLБезПротокола = СтрЗаменить(URLИзНастроек, "https://", "");
	URLБезПротокола = СтрЗаменить(URLБезПротокола, "http://", "");
	
	// Разделяем на домен и путь для HTTPСоединение
	// В Python используется полный URL, но в 1С HTTPСоединение требует домен и путь отдельно
	ПозицияСлеша = СтрНайти(URLБезПротокола, "/");
	Если ПозицияСлеша > 0 Тогда
		БазовыйДомен = Лев(URLБезПротокола, ПозицияСлеша - 1);
		// Путь должен быть "/api/v1/chat/completions" (с начальным слешем)
		БазовыйПуть = Сред(URLБезПротокола, ПозицияСлеша);
		URLПуть = БазовыйПуть + "/chat/completions";
	Иначе
		БазовыйДомен = URLБезПротокола;
		URLПуть = "/api/v1/chat/completions";
	КонецЕсли;
	
	// Получаем токен доступа (с кешированием на 30 минут)
	// Для GigaChat API всегда нужен OAuth Access token, даже для режима "Свой ключ напрямую"
	// Если есть авторизационные данные, используем их для получения OAuth токена
	// Иначе используем Provider_ApiKey (для обратной совместимости, но это может не работать)
	Если НЕ ПустаяСтрока(Настройки.АвторизационныеДанные) Тогда
		// Используем OAuth токен (получается автоматически через авторизационные данные)
		ТокенДоступа = ПолучитьТокенДоступа(Настройки);
	ИначеЕсли НЕ ПустаяСтрока(Настройки.Provider_ApiKey) Тогда
		// Fallback: используем Provider_ApiKey напрямую (может не работать для GigaChat)
		ТокенДоступа = Настройки.Provider_ApiKey;
	Иначе
		ВызватьИсключение "Не указан Provider_ApiKey или АвторизационныеДанные для подключения к GigaChat";
	КонецЕсли;
	
	// Получаем метаданные для контекста
	МетаданныеКонтекст = ПолучитьМетаданныеДляИИ();
	
	// Формируем промпт с учетом типа сообщения и метаданных
	Промпт = СформироватьПромптДляИИ(ТипСообщения, ТекстПользователя, История, МетаданныеКонтекст);
	
	// Формируем тело запроса
	ТелоЗапроса = Новый Структура;
	ТелоЗапроса.Вставить("model", "GigaChat:latest");
	ТелоЗапроса.Вставить("messages", Промпт.Сообщения);
	ТелоЗапроса.Вставить("temperature", 0.7);
	ТелоЗапроса.Вставить("max_tokens", 2000);
	
	// Преобразуем в JSON
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, ТелоЗапроса);
	JSONТело = ЗаписьJSON.Закрыть();
	
	// Выполняем HTTP-запрос
	Попытка
		
		// Используем защищенное соединение OpenSSL для HTTPS
		// БазовыйДомен уже без протокола (например, "gigachat.devices.sberbank.ru")
		HTTPСоединение = Новый HTTPСоединение(БазовыйДомен, , , , , , Новый ЗащищенноеСоединениеOpenSSL());
		
		Заголовки = Новый Соответствие;
		// Host заголовок не нужен при использовании HTTPСоединение - он устанавливается автоматически
		// Заголовки.Вставить("Host", БазовыйДомен);
		Заголовки.Вставить("Content-Type", "application/json");
		Заголовки.Вставить("Accept", "application/json");
		Заголовки.Вставить("Cache-Control", "no-cache");
		
		// Для GigaChat используется формат "Bearer {токен}" для Access token
		ЗаголовокАвторизации = "Bearer " + ТокенДоступа;
		Заголовки.Вставить("Authorization", ЗаголовокАвторизации);
		
		
		HTTPЗапрос = Новый HTTPЗапрос(URLПуть, Заголовки);
		HTTPЗапрос.УстановитьТелоИзСтроки(JSONТело);
		
		HTTPОтвет = HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);
		
		Если HTTPОтвет.КодСостояния <> 200 Тогда
			
			ТекстОшибки = HTTPОтвет.ПолучитьТелоКакСтроку();
			
			// Если токен истек (401), пытаемся получить новый токен и повторить запрос
			Если HTTPОтвет.КодСостояния = 401 И (СтрНайти(ТекстОшибки, "expired") > 0 Или СтрНайти(ТекстОшибки, "Token") > 0) Тогда
				
				// Запрашиваем новый токен
				Попытка
					
					НовыйТокен = ПолучитьНовыйТокенДоступа(Настройки);
					
					// Обновляем заголовок авторизации
					Заголовки.Установить("Authorization", "Bearer " + НовыйТокен);
					
					// Повторяем запрос с новым токеном
					HTTPЗапрос = Новый HTTPЗапрос(URLПуть, Заголовки);
					HTTPЗапрос.УстановитьТелоИзСтроки(JSONТело);
					
					HTTPОтвет = HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);
					
					// Если повторный запрос тоже не удался, возвращаем ошибку
					Если HTTPОтвет.КодСостояния <> 200 Тогда
						ТекстОшибки = HTTPОтвет.ПолучитьТелоКакСтроку();
						Результат.Текст = "Ошибка API Гигачат после обновления токена: " + Формат(HTTPОтвет.КодСостояния, "ЧН=0") + " - " + ТекстОшибки;
						
						Если НЕ Результат.Свойство("Ошибки") Тогда
							Результат.Вставить("Ошибки", "");
						КонецЕсли;
						Результат.Ошибки = ТекстОшибки;
						
						Возврат Результат;
					КонецЕсли;
					
					// Если повторный запрос успешен, продолжаем обработку ответа
					
				Исключение
					
					// Если не удалось получить новый токен, возвращаем исходную ошибку
					Результат.Текст = "Ошибка API Гигачат: " + Формат(HTTPОтвет.КодСостояния, "ЧН=0") + " - " + ТекстОшибки + 
						Символы.ПС + "Не удалось обновить токен: " + ОписаниеОшибки();
					
					Если НЕ Результат.Свойство("Ошибки") Тогда
						Результат.Вставить("Ошибки", "");
					КонецЕсли;
					Результат.Ошибки = ТекстОшибки;
					
					Возврат Результат;
					
				КонецПопытки;
				
			Иначе
				
				// Для других ошибок возвращаем как обычно
				Результат.Текст = "Ошибка API Гигачат: " + Формат(HTTPОтвет.КодСостояния, "ЧН=0") + " - " + ТекстОшибки;
				
				Если НЕ Результат.Свойство("Ошибки") Тогда
					Результат.Вставить("Ошибки", "");
				КонецЕсли;
				Результат.Ошибки = ТекстОшибки;
				
				Возврат Результат;
				
			КонецЕсли;
			
		КонецЕсли;
		
		// Парсим ответ
		ТекстОтвета = HTTPОтвет.ПолучитьТелоКакСтроку();
		
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ТекстОтвета);
		ОтветJSON = ПрочитатьJSON(ЧтениеJSON);
		ЧтениеJSON.Закрыть();
		
		// Извлекаем ответ от ИИ
		Если ОтветJSON.Свойство("choices") И ОтветJSON.choices.Количество() > 0 Тогда
			
			Выбор = ОтветJSON.choices[0];
			Если Выбор.Свойство("message") И Выбор.message.Свойство("content") Тогда
				
				ТекстОтветаИИ = Выбор.message.content;
				
				// Определяем тип ответа и парсим его
				РезультатРаспознавания = РаспознатьОтветИИ(ТекстОтветаИИ, ТипСообщения);
				
				// Копируем поля из результата распознавания, сохраняя существующие поля
				Для Каждого КлючЗначение Из РезультатРаспознавания Цикл
					Результат.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЕсли;
		
		// Извлекаем информацию об использовании токенов
		Если ОтветJSON.Свойство("usage") Тогда
			
			UsageStruct = Новый Структура;
			Если ОтветJSON.usage.Свойство("prompt_tokens") Тогда
				UsageStruct.Вставить("PromptTokens", ОтветJSON.usage.prompt_tokens);
			Иначе
				UsageStruct.Вставить("PromptTokens", 0);
			КонецЕсли;
			
			Если ОтветJSON.usage.Свойство("completion_tokens") Тогда
				UsageStruct.Вставить("CompletionTokens", ОтветJSON.usage.completion_tokens);
			Иначе
				UsageStruct.Вставить("CompletionTokens", 0);
			КонецЕсли;
			
			Если ОтветJSON.usage.Свойство("total_tokens") Тогда
				UsageStruct.Вставить("TotalTokens", ОтветJSON.usage.total_tokens);
			Иначе
				UsageStruct.Вставить("TotalTokens", 0);
			КонецЕсли;
			
			UsageStruct.Вставить("ОстатокКредитов", 0); // Гигачат не возвращает информацию о балансе
			
			// Убеждаемся, что поле Usage существует
			Если НЕ Результат.Свойство("Usage") Тогда
				Результат.Вставить("Usage", Неопределено);
			КонецЕсли;
			Результат.Usage = UsageStruct;
			
		КонецЕсли;
		
	Исключение
		
		ТекстОшибки = ОписаниеОшибки();
		Результат.Текст = "Ошибка при вызове API Гигачат: " + ТекстОшибки + 
			Символы.ПС + "БазовыйДомен: " + БазовыйДомен + 
			Символы.ПС + "URLПуть: " + URLПуть;
		
		// Убеждаемся, что поле Ошибки существует
		Если НЕ Результат.Свойство("Ошибки") Тогда
			Результат.Вставить("Ошибки", "");
		КонецЕсли;
		Результат.Ошибки = ОписаниеОшибки();
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Получает метаданные конфигурации для передачи в ИИ
//
// Возвращаемое значение:
//  Структура - структура с метаданными
//
Функция ПолучитьМетаданныеДляИИ()
	
	Результат = Новый Структура;
	
	// Получаем списки объектов
	Результат.Вставить("Справочники", ИИА_Метаданные.ПолучитьСписокСправочников());
	Результат.Вставить("Документы", ИИА_Метаданные.ПолучитьСписокДокументов());
	Результат.Вставить("РегистрыСведений", ИИА_Метаданные.ПолучитьСписокРегистровСведений());
	Результат.Вставить("РегистрыНакопления", ИИА_Метаданные.ПолучитьСписокРегистровНакопления());
	Результат.Вставить("РегистрыБухгалтерии", ИИА_Метаданные.ПолучитьСписокРегистровБухгалтерии());
	
	Возврат Результат;
	
КонецФункции

// Формирует промпт для ИИ с учетом контекста
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  МетаданныеКонтекст - Структура - метаданные конфигурации
//
// Возвращаемое значение:
//  Структура - структура с сообщениями для ИИ
//
Функция СформироватьПромптДляИИ(ТипСообщения, ТекстПользователя, История, МетаданныеКонтекст)
	
	Результат = Новый Структура;
	Сообщения = Новый Массив;
	
	// Системный промпт
	СистемноеСообщение = Новый Структура;
	СистемноеСообщение.Вставить("role", "system");
	
	СистемныйПромпт = "Ты - ИИ-ассистент для работы с системой 1С:Предприятие. " + Символы.ПС +
		"Твоя задача - понимать команды пользователя и генерировать безопасные DSL-сценарии или запросы на языке запросов 1С." + Символы.ПС +
		Символы.ПС +
		"Доступные объекты конфигурации:" + Символы.ПС;
	
	// Добавляем информацию о справочниках
	Если МетаданныеКонтекст.Свойство("Справочники") Тогда
		СистемныйПромпт = СистемныйПромпт + "Справочники: ";
		Для Каждого Справочник Из МетаданныеКонтекст.Справочники Цикл
			СистемныйПромпт = СистемныйПромпт + Справочник.Имя + " (" + Справочник.Синоним + "), ";
		КонецЦикла;
		СистемныйПромпт = Лев(СистемныйПромпт, СтрДлина(СистемныйПромпт) - 2) + Символы.ПС;
	КонецЕсли;
	
	// Добавляем информацию о документах
	Если МетаданныеКонтекст.Свойство("Документы") Тогда
		СистемныйПромпт = СистемныйПромпт + "Документы: ";
		Для Каждого Документ Из МетаданныеКонтекст.Документы Цикл
			СистемныйПромпт = СистемныйПромпт + Документ.Имя + " (" + Документ.Синоним + "), ";
		КонецЦикла;
		СистемныйПромпт = Лев(СистемныйПромпт, СтрДлина(СистемныйПромпт) - 2) + Символы.ПС;
	КонецЕсли;
	
	СистемныйПромпт = СистемныйПромпт + Символы.ПС +
		"Формат DSL-сценария:" + Символы.ПС +
		"{""dsl_version"": 1, ""steps"": [{""action"": ""CreateReference"", ""object_name"": ""ИмяСправочника""}, ...]}" + Символы.ПС +
		"Доступные действия: CreateReference, CreateDocument, FindReferenceByName, SetField, Write, RunQuery, ShowInfo" + Символы.ПС +
		Символы.ПС +
		"Если пользователь просит создать или найти объект, генерируй DSL-сценарий в формате JSON." + Символы.ПС +
		"Если пользователь просит выполнить запрос, генерируй запрос на языке запросов 1С.";
	
	СистемноеСообщение.Вставить("content", СистемныйПромпт);
	Сообщения.Добавить(СистемноеСообщение);
	
	// Добавляем историю диалога
	Для Каждого СтрокаИстории Из История Цикл
		
		Сообщение = Новый Структура;
		
		Если СтрокаИстории.Автор = Перечисления.ИИА_АвторСообщения.Пользователь Тогда
			Сообщение.Вставить("role", "user");
		Иначе
			Сообщение.Вставить("role", "assistant");
		КонецЕсли;
		
		ТекстСообщения = СтрокаИстории.Текст;
		Если НЕ ПустаяСтрока(СтрокаИстории.ТекстКода) Тогда
			ТекстСообщения = ТекстСообщения + Символы.ПС + "```" + Символы.ПС + СтрокаИстории.ТекстКода + Символы.ПС + "```";
		КонецЕсли;
		
		Сообщение.Вставить("content", ТекстСообщения);
		Сообщения.Добавить(Сообщение);
		
	КонецЦикла;
	
	// Добавляем текущее сообщение пользователя
	ТекущееСообщение = Новый Структура;
	ТекущееСообщение.Вставить("role", "user");
	ТекущееСообщение.Вставить("content", ТекстПользователя);
	Сообщения.Добавить(ТекущееСообщение);
	
	Результат.Вставить("Сообщения", Сообщения);
	
	Возврат Результат;
	
КонецФункции

// Распознает ответ ИИ и определяет его тип
//
// Параметры:
//  ТекстОтветаИИ - Строка - текст ответа от ИИ
//  ТипСообщения - Строка - тип исходного сообщения
//
// Возвращаемое значение:
//  Структура - структура результата с распознанным типом и данными
//
Функция РаспознатьОтветИИ(ТекстОтветаИИ, ТипСообщения)
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", ТекстОтветаИИ);
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	
	// Пытаемся найти JSON в ответе (DSL-сценарий)
	// JSON может быть в чистом виде или с текстом перед ним
	ТекстДляПарсинга = СокрЛП(ТекстОтветаИИ);
	
	// Сначала проверяем, начинается ли текст с "{"
	Если Лев(ТекстДляПарсинга, 1) = "{" Тогда
		
		Попытка
			
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ТекстДляПарсинга);
			ПроверкаJSON = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			
			// Проверяем, что это DSL-сценарий
			Если ПроверкаJSON.Свойство("dsl_version") И ПроверкаJSON.Свойство("steps") Тогда
				
				Результат.ТипОтвета = "DSL";
				Результат.DSL = ТекстДляПарсинга;
				Результат.Текст = "Сгенерирован DSL-сценарий:";
				Результат.ВыполнитьDSL = Истина; // Выполняем DSL-сценарий автоматически
				
				Возврат Результат;
				
			КонецЕсли;
			
		Исключение
			// Не JSON или не DSL - продолжаем поиск
		КонецПопытки;
		
	КонецЕсли;
	
	// Если текст не начинается с "{", ищем JSON внутри текста
	// Ищем открывающую скобку в тексте
	НачалоОткрывающейСкобки = СтрНайти(ТекстОтветаИИ, "{");
	Если НачалоОткрывающейСкобки > 0 Тогда
		// Ищем закрывающую скобку с конца
		КонецЗакрывающейСкобки = СтрНайти(ТекстОтветаИИ, "}", НаправлениеПоиска.СКонца);
		Если КонецЗакрывающейСкобки > 0 И КонецЗакрывающейСкобки > НачалоОткрывающейСкобки Тогда
			
			ВозможныйJSON = Сред(ТекстОтветаИИ, НачалоОткрывающейСкобки, КонецЗакрывающейСкобки - НачалоОткрывающейСкобки + 1);
			
			Попытка
				
				ЧтениеJSON = Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(ВозможныйJSON);
				ПроверкаJSON = ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				
				// Проверяем, что это DSL-сценарий
				Если ПроверкаJSON.Свойство("dsl_version") И ПроверкаJSON.Свойство("steps") Тогда
					
					Результат.ТипОтвета = "DSL";
					Результат.DSL = ВозможныйJSON;
					// Извлекаем текст перед JSON (если есть)
					Если НачалоОткрывающейСкобки > 1 Тогда
						ТекстПередJSON = СокрЛП(Лев(ТекстОтветаИИ, НачалоОткрывающейСкобки - 1));
						Если НЕ ПустаяСтрока(ТекстПередJSON) Тогда
							Результат.Текст = ТекстПередJSON;
						Иначе
							Результат.Текст = "Сгенерирован DSL-сценарий:";
						КонецЕсли;
					Иначе
						Результат.Текст = "Сгенерирован DSL-сценарий:";
					КонецЕсли;
					Результат.ВыполнитьDSL = Истина; // Выполняем DSL-сценарий автоматически
					
					Возврат Результат;
					
				КонецЕсли;
				
			Исключение
				// Не JSON или не DSL - продолжаем как обычный текст
			КонецПопытки;
			
		КонецЕсли;
	КонецЕсли;
	
	// Если тип сообщения "Запрос", пытаемся найти запрос в ответе
	Если ТипСообщения = "Запрос" Тогда
		
		// Ищем блок кода с запросом
		НачалоБлока = СтрНайти(ТекстОтветаИИ, "```");
		Если НачалоБлока > 0 Тогда
			
			КонецБлока = СтрНайти(ТекстОтветаИИ, "```", НачалоБлока + 3);
			Если КонецБлока > 0 Тогда
				
				ТекстЗапроса = Сред(ТекстОтветаИИ, НачалоБлока + 3, КонецБлока - НачалоБлока - 3);
				ТекстЗапроса = СокрЛП(ТекстЗапроса);
				
				// Проверяем, что это похоже на запрос 1С
				Если СтрНайти(ВРег(ТекстЗапроса), "ВЫБРАТЬ") > 0 Тогда
					
					Результат.ТипОтвета = "Запрос";
					Результат.Запрос = ТекстЗапроса;
					Результат.Текст = "Сгенерирован запрос:";
					
					Возврат Результат;
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// По умолчанию возвращаем как текст
	Возврат Результат;
	
КонецФункции

// Исправляет DSL-сценарий через ИИ при ошибке выполнения
//
// Параметры:
//  DSLJSON - Строка - исходный DSL-сценарий с ошибкой
//  ТекстОшибки - Строка - текст ошибки выполнения
//  Настройки - Структура - настройки пользователя
//  НомерПопытки - Число - номер текущей попытки исправления (по умолчанию 1)
//  МаксимальноеКоличествоПопыток - Число - максимальное количество попыток исправления (по умолчанию 2)
//
// Возвращаемое значение:
//  Структура - структура результата:
//   * Успех - Булево
//   * Сообщение - Строка
//   * ИсправленныйDSL - Строка - исправленный DSL-сценарий
//
Функция ИсправитьDSLЧерезИИ(DSLJSON, ТекстОшибки, Настройки, НомерПопытки = 1, МаксимальноеКоличествоПопыток = 2)
	
	Результат = Новый Структура;
	Результат.Вставить("Успех", Ложь);
	Результат.Вставить("Сообщение", "");
	Результат.Вставить("ИсправленныйDSL", "");
	
	// Проверяем, не превышен ли лимит попыток исправления
	Если НомерПопытки > МаксимальноеКоличествоПопыток Тогда
		Результат.Сообщение = "Достигнут лимит попыток исправления (" + Формат(МаксимальноеКоличествоПопыток, "ЧН=0") + "). Дальнейшие исправления отменены.";
		Возврат Результат;
	КонецЕсли;
	
	// Формируем промпт для исправления
	ПромптИсправления = "Исправь следующий DSL-сценарий, который вызвал ошибку:" + Символы.ПС +
		"Ошибка: " + ТекстОшибки + Символы.ПС +
		"Исходный DSL:" + Символы.ПС +
		DSLJSON + Символы.ПС +
		"Верни только исправленный JSON без дополнительных комментариев.";
	
	// Вызываем ИИ для исправления
	Попытка
		
		БазовыйURL = Настройки.Provider_BaseUrl;
		Если ПустаяСтрока(БазовыйURL) Тогда
			БазовыйURL = "https://gigachat.devices.sberbank.ru";
		КонецЕсли;
		
		URLПуть = "/api/v1/chat/completions";
		
		Сообщения = Новый Массив;
		Сообщение = Новый Структура;
		Сообщение.Вставить("role", "user");
		Сообщение.Вставить("content", ПромптИсправления);
		Сообщения.Добавить(Сообщение);
		
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("model", "GigaChat");
		ТелоЗапроса.Вставить("messages", Сообщения);
		ТелоЗапроса.Вставить("temperature", 0.3); // Низкая температура для более точного исправления
		ТелоЗапроса.Вставить("max_tokens", 2000);
		
		ЗаписьJSON = Новый ЗаписьJSON;
		ЗаписьJSON.УстановитьСтроку();
		ЗаписатьJSON(ЗаписьJSON, ТелоЗапроса);
		JSONТело = ЗаписьJSON.Закрыть();
		
		// Получаем токен доступа (используем ту же логику, что и в ВызватьГигачат)
		ТокенДоступа = ПолучитьТокенДоступа(Настройки);
		
		// Извлекаем домен из URL
		БазовыйДомен = БазовыйURL;
		Если СтрНайти(БазовыйДомен, "://") > 0 Тогда
			БазовыйДомен = СтрЗаменить(БазовыйДомен, "https://", "");
			БазовыйДомен = СтрЗаменить(БазовыйДомен, "http://", "");
		КонецЕсли;
		
		HTTPСоединение = Новый HTTPСоединение(БазовыйДомен, , , , , , Новый ЗащищенноеСоединениеOpenSSL());
		
		Заголовки = Новый Соответствие;
		Заголовки.Вставить("Content-Type", "application/json");
		Заголовки.Вставить("Accept", "application/json");
		Заголовки.Вставить("Cache-Control", "no-cache");
		Заголовки.Вставить("Authorization", "Bearer " + ТокенДоступа);
		
		HTTPЗапрос = Новый HTTPЗапрос(URLПуть, Заголовки);
		HTTPЗапрос.УстановитьТелоИзСтроки(JSONТело);
		
		HTTPОтвет = HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);
		
		Если HTTPОтвет.КодСостояния = 200 Тогда
			
			ТекстОтвета = HTTPОтвет.ПолучитьТелоКакСтроку();
			
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ТекстОтвета);
			ОтветJSON = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			
			Если ОтветJSON.Свойство("choices") И ОтветJSON.choices.Количество() > 0 Тогда
				
				Выбор = ОтветJSON.choices[0];
				Если Выбор.Свойство("message") И Выбор.message.Свойство("content") Тогда
					
					ТекстИсправления = Выбор.message.content;
					
					// Извлекаем JSON из ответа
					НачалоОткрывающейСкобки = СтрНайти(ТекстИсправления, "{");
					КонецЗакрывающейСкобки = СтрНайти(ТекстИсправления, "}", , НачалоОткрывающейСкобки);
					
					Если НачалоОткрывающейСкобки > 0 И КонецЗакрывающейСкобки > 0 Тогда
						
						ИсправленныйJSON = Сред(ТекстИсправления, НачалоОткрывающейСкобки, КонецЗакрывающейСкобки - НачалоОткрывающейСкобки + 1);
						
						// Проверяем исправленный DSL
						РезультатПроверки = ПроверитьDSLСценарий(ИсправленныйJSON);
						Если РезультатПроверки.Успех Тогда
							
							Результат.Успех = Истина;
							Результат.ИсправленныйDSL = ИсправленныйJSON;
							Результат.Сообщение = "DSL-сценарий исправлен";
							
						Иначе
							
							Результат.Сообщение = "Исправленный DSL также содержит ошибки: " + РезультатПроверки.Сообщение;
							
						КонецЕсли;
						
					Иначе
						
						Результат.Сообщение = "Не удалось извлечь JSON из ответа ИИ";
						
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЕсли;
			
		Иначе
			
			Результат.Сообщение = "Ошибка API при исправлении: " + Формат(HTTPОтвет.КодСостояния, "ЧН=0");
			
		КонецЕсли;
		
	Исключение
		
		Результат.Сообщение = "Ошибка при исправлении DSL: " + ОписаниеОшибки();
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Получает пример DSL-сценария (заглушка для демонстрации)
//
// Параметры:
//  ТекстПользователя - Строка - текст команды пользователя
//
// Возвращаемое значение:
//  Строка - JSON с DSL-сценарием
//
Функция ПолучитьПримерDSLСценария(ТекстПользователя)
	
	// Это заглушка - в реальной реализации ИИ должен генерировать DSL на основе команды пользователя
	// и метаданных конфигурации
	
	ПримерСценария = Новый Структура;
	ПримерСценария.Вставить("dsl_version", 1);
	
	Шаги = Новый Массив;
	
	// Пример: создание элемента справочника
	Если СтрНайти(ВРег(ТекстПользователя), "КОНТРАГЕНТ") > 0 Тогда
		
		Шаг1 = Новый Структура;
		Шаг1.Вставить("action", "CreateReference");
		Шаг1.Вставить("object_name", "Контрагенты");
		Шаги.Добавить(Шаг1);
		
		Шаг2 = Новый Структура;
		Шаг2.Вставить("action", "SetField");
		Шаг2.Вставить("field", "Наименование");
		Шаг2.Вставить("value", "Новый контрагент");
		Шаги.Добавить(Шаг2);
		
		Шаг3 = Новый Структура;
		Шаг3.Вставить("action", "Write");
		Шаги.Добавить(Шаг3);
		
	Иначе
		
		// Общий пример
		Шаг1 = Новый Структура;
		Шаг1.Вставить("action", "ShowInfo");
		Шаг1.Вставить("message", "Пример DSL-сценария. Настройте ИИ для генерации реальных сценариев.");
		Шаги.Добавить(Шаг1);
		
	КонецЕсли;
	
	ПримерСценария.Вставить("steps", Шаги);
	
	// Преобразуем в JSON
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, ПримерСценария);
	JSONСтрока = ЗаписьJSON.Закрыть();
	
	Возврат JSONСтрока;
	
КонецФункции

// Отправляет сообщение и получает ответ от ИИ
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//
// Возвращаемое значение:
//  Структура - структура ответа от ВызватьИИ
//
Функция ОтправитьСообщениеСервера(СсылкаДиалога, ТипСообщения, ТекстПользователя) Экспорт
	
	Диалог = СсылкаДиалога.ПолучитьОбъект();
	Пользователь = Диалог.Пользователь;
	
	// Получаем настройки пользователя
	Настройки = ПолучитьНастройкиПользователя(Пользователь);
	Настройки.Вставить("Пользователь", Пользователь);
	
	// Загружаем историю диалога
	МассивИстории = ПолучитьСообщенияДиалога(СсылкаДиалога, 10);
	
	// Преобразуем массив в таблицу значений для функции ВызватьИИ
	История = Новый ТаблицаЗначений;
	История.Колонки.Добавить("Время", Новый ОписаниеТипов("Дата"));
	История.Колонки.Добавить("Автор", Новый ОписаниеТипов("ПеречислениеСсылка.ИИА_АвторСообщения"));
	История.Колонки.Добавить("ТипСообщения", Новый ОписаниеТипов("ПеречислениеСсылка.ИИА_ТипСообщения"));
	История.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка"));
	История.Колонки.Добавить("ТекстКода", Новый ОписаниеТипов("Строка"));
	
	Для Каждого СтруктураСообщения Из МассивИстории Цикл
		
		НоваяСтрока = История.Добавить();
		НоваяСтрока.Время = СтруктураСообщения.Время;
		НоваяСтрока.Автор = СтруктураСообщения.Автор;
		НоваяСтрока.ТипСообщения = СтруктураСообщения.ТипСообщения;
		НоваяСтрока.Текст = СтруктураСообщения.Текст;
		
	КонецЦикла;
	
	// Определяем тип сообщения для хранения
	Если ТипСообщения = "Запрос" Тогда
		ТипСообщенияДляХранения = Перечисления.ИИА_ТипСообщения.Запрос;
	Иначе
		ТипСообщенияДляХранения = Перечисления.ИИА_ТипСообщения.Текст;
	КонецЕсли;
	
	// Добавляем сообщение пользователя
	ДобавитьСообщениеВДиалог(
		СсылкаДиалога,
		Перечисления.ИИА_АвторСообщения.Пользователь,
		ТипСообщенияДляХранения,
		ТекстПользователя
	);
	
	// Вызываем ИИ
	ОтветИИ = ВызватьИИ(ТипСообщения, ТекстПользователя, История, Настройки);
	
	// Определяем тип ответа для хранения
	Если ОтветИИ.ТипОтвета = "Запрос" Тогда
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Запрос;
		ТекстОтвета = ОтветИИ.Текст;
		ТекстКодаОтвета = ОтветИИ.Запрос;
	ИначеЕсли ОтветИИ.ТипОтвета = "DSL" Тогда
		// Обрабатываем DSL-сценарий
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Код;
		ТекстОтвета = ОтветИИ.Текст;
		ТекстКодаОтвета = ОтветИИ.DSL;
		
	Иначе
		ТипСообщенияОтвета = Перечисления.ИИА_ТипСообщения.Текст;
		ТекстОтвета = ОтветИИ.Текст;
		ТекстКодаОтвета = "";
	КонецЕсли;
	
	// Получаем UsageTokens
	UsageTokens = 0;
	Если ОтветИИ.Свойство("Usage") И ОтветИИ.Usage <> Неопределено Тогда
		Если ТипЗнч(ОтветИИ.Usage) = Тип("Структура") И ОтветИИ.Usage.Свойство("TotalTokens") Тогда
			UsageTokens = ОтветИИ.Usage.TotalTokens;
		КонецЕсли;
	КонецЕсли;
	
	// Определяем статус DSL для сообщения (пока ставим "ВОчереди", потом обновим после выполнения)
	СтатусDSLСообщения = Неопределено;
	Если ОтветИИ.ТипОтвета = "DSL" И НЕ ПустаяСтрока(ТекстКодаОтвета) Тогда
		СтатусDSLСообщения = Перечисления.ИИА_СтатусDSL.ВОчереди;
	КонецЕсли;
	
	// Сначала добавляем ответ ИИ
	ДобавитьСообщениеВДиалог(
		СсылкаДиалога,
		Перечисления.ИИА_АвторСообщения.ИИ,
		ТипСообщенияОтвета,
		ТекстОтвета,
		ТекстКодаОтвета,
		"",
		UsageTokens,
		СтатусDSLСообщения
	);
	
	// Теперь обрабатываем DSL-сценарий (если это DSL)
	Если ОтветИИ.ТипОтвета = "DSL" И НЕ ПустаяСтрока(ОтветИИ.DSL) Тогда
		
		// Выполняем DSL
		РезультатDSL = ВыполнитьDSLСценарий(ОтветИИ.DSL);
		
		// Обновляем статус DSL в сообщении
		Если РезультатDSL.Успех Тогда
			ОбновитьСтатусDSLВПоследнемСообщении(СсылкаДиалога, Перечисления.ИИА_СтатусDSL.ОбработанУспешно);
			
			// Добавляем системное сообщение об успешном выполнении
			ТекстСистемногоСообщения = "DSL-сценарий выполнен успешно.";
			
			// Добавляем информацию о результатах шагов
			Если РезультатDSL.Результаты.Количество() > 0 Тогда
				Для Каждого РезультатШага Из РезультатDSL.Результаты Цикл
					ТекстСистемногоСообщения = ТекстСистемногоСообщения + Символы.ПС + "- " + РезультатШага.Сообщение;
				КонецЦикла;
			КонецЕсли;
			
			ДобавитьСообщениеВДиалог(
				СсылкаДиалога,
				Перечисления.ИИА_АвторСообщения.Система,
				Перечисления.ИИА_ТипСообщения.Текст,
				ТекстСистемногоСообщения,
				"",
				"",
				0
			);
			
			// Добавляем системное сообщение со ссылками на созданные/измененные объекты
			Если РезультатDSL.Свойство("СсылкиОбъектов") Тогда
				МассивСсылок = РезультатDSL.СсылкиОбъектов;
				Если МассивСсылок.Количество() > 0 Тогда
					Попытка
						
						ТекстСсылок = "";
						
						// Формируем текст с гиперссылками
						Если МассивСсылок.Количество() = 1 Тогда
							СсылкаОбъекта = МассивСсылок[0];
							ТекстСсылок = "Объект: " + СсылкаОбъекта;
						Иначе
							ТекстСсылок = "Создано/изменено объектов: " + Формат(МассивСсылок.Количество(), "ЧН=0");
							Для Каждого СсылкаОбъекта Из МассивСсылок Цикл
								ТекстСсылок = ТекстСсылок + Символы.ПС + "- " + СсылкаОбъекта;
							КонецЦикла;
						КонецЕсли;
						
						ДобавитьСообщениеВДиалог(
							СсылкаДиалога,
							Перечисления.ИИА_АвторСообщения.Система,
							Перечисления.ИИА_ТипСообщения.Текст,
							ТекстСсылок,
							"",
							"",
							0
						);
						
					Исключение
						// Если не удалось добавить ссылки, добавляем сообщение об ошибке для отладки
						ДобавитьСообщениеВДиалог(
							СсылкаДиалога,
							Перечисления.ИИА_АвторСообщения.Система,
							Перечисления.ИИА_ТипСообщения.Ошибка,
							"Ошибка при формировании сообщения со ссылками: " + ОписаниеОшибки(),
							"",
							"",
							0
						);
					КонецПопытки;
				КонецЕсли;
			КонецЕсли;
			
		Иначе
			// Обновляем статус DSL на "ОбработанСОшибкой"
			ОбновитьСтатусDSLВПоследнемСообщении(СсылкаДиалога, Перечисления.ИИА_СтатусDSL.ОбработанСОшибкой);
			
			// Добавляем системное сообщение об ошибке
			ТекстОшибки = "Ошибка выполнения DSL: " + РезультатDSL.Сообщение;
			
			ДобавитьСообщениеВДиалог(
				СсылкаДиалога,
				Перечисления.ИИА_АвторСообщения.Система,
				Перечисления.ИИА_ТипСообщения.Ошибка,
				ТекстОшибки,
				"",
				"",
				0
			);
			
			// Пытаемся исправить ошибку через ИИ (максимум 5 попыток)
			ВыполнитьПопыткиИсправленияDSL(ОтветИИ.DSL, РезультатDSL.Сообщение, Настройки, СсылкаДиалога, 1, 5);
			
		КонецЕсли;
		
	КонецЕсли;
	
	// Если есть ТекстКода, добавляем системное сообщение о получении кода (только для не-DSL типов)
	Если НЕ ПустаяСтрока(ТекстКодаОтвета) И ОтветИИ.ТипОтвета <> "DSL" Тогда
		
		// Определяем текст системного сообщения в зависимости от типа
		Если ОтветИИ.ТипОтвета = "Запрос" Тогда
			ТекстСистемногоСообщения = "Запрос сгенерирован.";
		Иначе
			ТекстСистемногоСообщения = "ИИ сгенерировал код.";
		КонецЕсли;
		
		ДобавитьСообщениеВДиалог(
			СсылкаДиалога,
			Перечисления.ИИА_АвторСообщения.Система,
			Перечисления.ИИА_ТипСообщения.Текст,
			ТекстСистемногоСообщения,
			"",
			"",
			0
		);
		
	КонецЕсли;
	
	Возврат ОтветИИ;
	
КонецФункции

// Проверяет запрос 1С на выполнимость
//
// Параметры:
//  ТекстЗапроса - Строка - текст запроса
//
// Возвращаемое значение:
//  Структура - структура результата:
//   * Успех - Булево - успешность выполнения
//   * Сообщение - Строка - текст ошибки или пусто
//
Функция ПроверитьЗапрос(ТекстЗапроса) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Успех", Ложь);
	Результат.Вставить("Сообщение", "");
	
	Попытка
		
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.Выполнить();
		
		Результат.Успех = Истина;
		
	Исключение
		
		Результат.Сообщение = ОписаниеОшибки();
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Выполняет DSL сценарий
//
// Параметры:
//  DSLJSON - Строка - JSON с DSL командами
//
// Возвращаемое значение:
//  Структура - структура результата выполнения DSL
//
Функция ВыполнитьDSLСценарий(DSLJSON) Экспорт
	
	Возврат ИИА_DSL.ВыполнитьDSL(DSLJSON);
	
КонецФункции

// Выполняет DSL-сценарий и добавляет системные сообщения в диалог
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  DSLJSON - Строка - JSON с DSL командами
//
// Возвращаемое значение:
//  Структура - структура результата выполнения DSL
//
Функция ВыполнитьDSLСценарийССообщениями(СсылкаДиалога, DSLJSON) Экспорт
	
	// Выполняем DSL
	РезультатDSL = ИИА_DSL.ВыполнитьDSL(DSLJSON);
	
	Если РезультатDSL.Успех Тогда
		
		// Добавляем системное сообщение об успешном выполнении
		ТекстСистемногоСообщения = "DSL-сценарий выполнен успешно.";
		
		// Добавляем информацию о результатах шагов
		Если РезультатDSL.Результаты.Количество() > 0 Тогда
			Для Каждого РезультатШага Из РезультатDSL.Результаты Цикл
				ТекстСистемногоСообщения = ТекстСистемногоСообщения + Символы.ПС + "- " + РезультатШага.Сообщение;
			КонецЦикла;
		КонецЕсли;
		
		ДобавитьСообщениеВДиалог(
			СсылкаДиалога,
			Перечисления.ИИА_АвторСообщения.Система,
			Перечисления.ИИА_ТипСообщения.Текст,
			ТекстСистемногоСообщения,
			"",
			"",
			0
		);
		
		// Добавляем системное сообщение со ссылками на созданные/измененные объекты
		Если РезультатDSL.Свойство("СсылкиОбъектов") Тогда
			МассивСсылок = РезультатDSL.СсылкиОбъектов;
			Если МассивСсылок.Количество() > 0 Тогда
				Попытка
					
					ТекстСсылок = "";
					
					// Формируем текст с гиперссылками
					Если МассивСсылок.Количество() = 1 Тогда
						СсылкаОбъекта = МассивСсылок[0];
						ТекстСсылок = "Объект: " + СсылкаОбъекта;
					Иначе
						ТекстСсылок = "Создано/изменено объектов: " + Формат(МассивСсылок.Количество(), "ЧН=0");
						Для Каждого СсылкаОбъекта Из МассивСсылок Цикл
							ТекстСсылок = ТекстСсылок + Символы.ПС + "- " + СсылкаОбъекта;
						КонецЦикла;
					КонецЕсли;
					
					ДобавитьСообщениеВДиалог(
						СсылкаДиалога,
						Перечисления.ИИА_АвторСообщения.Система,
						Перечисления.ИИА_ТипСообщения.Текст,
						ТекстСсылок,
						"",
						"",
						0
					);
					
				Исключение
					// Если не удалось добавить ссылки, добавляем сообщение об ошибке для отладки
					ДобавитьСообщениеВДиалог(
						СсылкаДиалога,
						Перечисления.ИИА_АвторСообщения.Система,
						Перечисления.ИИА_ТипСообщения.Ошибка,
						"Ошибка при формировании сообщения со ссылками: " + ОписаниеОшибки(),
						"",
						"",
						0
					);
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
		
	Иначе
		
		// Добавляем системное сообщение об ошибке
		ТекстОшибки = "Ошибка выполнения DSL: " + РезультатDSL.Сообщение;
		
		ДобавитьСообщениеВДиалог(
			СсылкаДиалога,
			Перечисления.ИИА_АвторСообщения.Система,
			Перечисления.ИИА_ТипСообщения.Ошибка,
			ТекстОшибки,
			"",
			"",
			0
		);
		
	КонецЕсли;
	
	Возврат РезультатDSL;
	
КонецФункции

// Проверяет DSL сценарий
//
// Параметры:
//  DSLJSON - Строка - JSON с DSL командами
//
// Возвращаемое значение:
//  Структура - структура результата проверки DSL
//
Функция ПроверитьDSLСценарий(DSLJSON) Экспорт
	
	Возврат ИИА_DSL.ПроверитьDSL(DSLJSON);
	
КонецФункции

// Обновляет статус DSL в последнем сообщении диалога
//
// Параметры:
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  НовыйСтатус - ПеречислениеСсылка.ИИА_СтатусDSL - новый статус DSL
//
Процедура ОбновитьСтатусDSLВПоследнемСообщении(СсылкаДиалога, НовыйСтатус)
	
	Попытка
		
		Диалог = СсылкаДиалога.ПолучитьОбъект();
		
		// Находим последнее сообщение с DSL (тип Код)
		Если Диалог.Сообщения.Количество() > 0 Тогда
			
			// Ищем последнее сообщение с типом "Код" (DSL), начиная с конца
			Индекс = Диалог.Сообщения.Количество() - 1;
			Пока Индекс >= 0 Цикл
				
				СтрокаСообщения = Диалог.Сообщения[Индекс];
				
				Если СтрокаСообщения.ТипСообщения = Перечисления.ИИА_ТипСообщения.Код И НЕ ПустаяСтрока(СтрокаСообщения.ТекстКода) Тогда
					
					СтрокаСообщения.СтатусDSL = НовыйСтатус;
					Диалог.Записать();
					
					Прервать;
					
				КонецЕсли;
				
				Индекс = Индекс - 1;
				
			КонецЦикла;
			
		КонецЕсли;
		
	Исключение
		// Игнорируем ошибки обновления статуса
	КонецПопытки;
	
КонецПроцедуры

// Выполняет попытки исправления DSL с рекурсивной логикой
//
// Параметры:
//  DSLJSON - Строка - исходный DSL-сценарий с ошибкой
//  ТекстОшибки - Строка - текст ошибки выполнения
//  Настройки - Структура - настройки пользователя
//  СсылкаДиалога - СправочникСсылка.ИИА_Диалоги - ссылка на диалог
//  НомерПопытки - Число - номер текущей попытки исправления
//  МаксимальноеКоличествоПопыток - Число - максимальное количество попыток исправления
//
Процедура ВыполнитьПопыткиИсправленияDSL(DSLJSON, ТекстОшибки, Настройки, СсылкаДиалога, НомерПопытки, МаксимальноеКоличествоПопыток)
	
	// Пытаемся исправить ошибку через ИИ
	РезультатКоррекции = ИсправитьDSLЧерезИИ(DSLJSON, ТекстОшибки, Настройки, НомерПопытки, МаксимальноеКоличествоПопыток);
	
	Если РезультатКоррекции.Успех Тогда
		
		// Обновляем статус на "Исправляется"
		ОбновитьСтатусDSLВПоследнемСообщении(СсылкаДиалога, Перечисления.ИИА_СтатусDSL.Исправляется);
		
		ДобавитьСообщениеВДиалог(
			СсылкаДиалога,
			Перечисления.ИИА_АвторСообщения.Система,
			Перечисления.ИИА_ТипСообщения.Текст,
			"Получен исправленный DSL-сценарий от ИИ (попытка " + Формат(НомерПопытки, "ЧН=0") + "). Выполняю повторно...",
			"",
			"",
			0
		);
		
		// Выполняем исправленный DSL-сценарий
		РезультатИсправленногоDSL = ВыполнитьDSLСценарий(РезультатКоррекции.ИсправленныйDSL);
		
		Если РезультатИсправленногоDSL.Успех Тогда
			// Обновляем статус на "ОбработанУспешно"
			ОбновитьСтатусDSLВПоследнемСообщении(СсылкаДиалога, Перечисления.ИИА_СтатусDSL.ОбработанУспешно);
			
			// Добавляем системное сообщение об успешном выполнении исправленного сценария
			ТекстУспеха = "Исправленный DSL-сценарий выполнен успешно (попытка " + Формат(НомерПопытки, "ЧН=0") + ").";
			
			// Добавляем информацию о результатах шагов
			Если РезультатИсправленногоDSL.Результаты.Количество() > 0 Тогда
				Для Каждого РезультатШага Из РезультатИсправленногоDSL.Результаты Цикл
					ТекстУспеха = ТекстУспеха + Символы.ПС + "- " + РезультатШага.Сообщение;
				КонецЦикла;
			КонецЕсли;
			
			ДобавитьСообщениеВДиалог(
				СсылкаДиалога,
				Перечисления.ИИА_АвторСообщения.Система,
				Перечисления.ИИА_ТипСообщения.Текст,
				ТекстУспеха,
				"",
				"",
				0
			);
			
			// Добавляем системное сообщение со ссылками на созданные/измененные объекты
			Если РезультатИсправленногоDSL.Свойство("СсылкиОбъектов") И РезультатИсправленногоDSL.СсылкиОбъектов.Количество() > 0 Тогда
				Попытка
					
					МассивСсылок = РезультатИсправленногоDSL.СсылкиОбъектов;
					ТекстСсылок = "";
					
					// Формируем текст с гиперссылками
					Если МассивСсылок.Количество() = 1 Тогда
						СсылкаОбъекта = МассивСсылок[0];
						ТекстСсылок = "Объект: " + СсылкаОбъекта;
					Иначе
						ТекстСсылок = "Создано/изменено объектов: " + Формат(МассивСсылок.Количество(), "ЧН=0");
						Для Каждого СсылкаОбъекта Из МассивСсылок Цикл
							ТекстСсылок = ТекстСсылок + Символы.ПС + "- " + СсылкаОбъекта;
						КонецЦикла;
					КонецЕсли;
					
					ДобавитьСообщениеВДиалог(
						СсылкаДиалога,
						Перечисления.ИИА_АвторСообщения.Система,
						Перечисления.ИИА_ТипСообщения.Текст,
						ТекстСсылок,
						"",
						"",
						0
					);
					
				Исключение
					// Если не удалось добавить ссылки, просто игнорируем
				КонецПопытки;
			КонецЕсли;
			
		Иначе
			// Если исправленный DSL не выполнился, проверяем, можем ли мы попробовать еще раз
			Если НомерПопытки < МаксимальноеКоличествоПопыток Тогда
				// Обновляем статус на "ОбработанСОшибкой" перед следующей попыткой
				ОбновитьСтатусDSLВПоследнемСообщении(СсылкаДиалога, Перечисления.ИИА_СтатусDSL.ОбработанСОшибкой);
				// Рекурсивно вызываем функцию для следующей попытки
				ВыполнитьПопыткиИсправленияDSL(РезультатКоррекции.ИсправленныйDSL, РезультатИсправленногоDSL.Сообщение, Настройки, СсылкаДиалога, НомерПопытки + 1, МаксимальноеКоличествоПопыток);
			Иначе
				// Достигнут лимит попыток
				ДобавитьСообщениеВДиалог(
					СсылкаДиалога,
					Перечисления.ИИА_АвторСообщения.Система,
					Перечисления.ИИА_ТипСообщения.Ошибка,
					"Исправленный DSL-сценарий (попытка " + Формат(НомерПопытки, "ЧН=0") + ") также завершился с ошибкой: " + РезультатИсправленногоDSL.Сообщение + Символы.ПС + "Достигнут лимит попыток исправления (" + Формат(МаксимальноеКоличествоПопыток, "ЧН=0") + ").",
					"",
					"",
					0
				);
			КонецЕсли;
		КонецЕсли;
		
	Иначе
		// Если не удалось получить исправленный DSL от ИИ или достигнут лимит
		ДобавитьСообщениеВДиалог(
			СсылкаДиалога,
			Перечисления.ИИА_АвторСообщения.Система,
			Перечисления.ИИА_ТипСообщения.Ошибка,
			"Не удалось получить исправленный DSL от ИИ (попытка " + Формат(НомерПопытки, "ЧН=0") + "): " + РезультатКоррекции.Сообщение,
			"",
			"",
			0
		);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти


