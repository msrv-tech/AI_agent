#Область ПрограммныйИнтерфейс

// Вызывает ИИ для получения ответа
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  Настройки - Структура - настройки пользователя
//
// Возвращаемое значение:
//  Структура - структура ответа:
//   * ТипОтвета - Строка ("Текст", "Запрос" или "DSL")
//   * Текст - Строка - текст ответа
//   * Запрос - Строка - текст запроса (для типа "Запрос")
//   * DSL - Строка - JSON с DSL-сценарием (для типа "DSL")
//   * ВыполнитьDSL - Булево - выполнить ли DSL сразу (для типа "DSL")
//   * Usage - Структура - информация об использовании токенов
//   * Ошибки - ОписаниеОшибки - информация об ошибках
//
Функция ВызватьИИ(ТипСообщения, ТекстПользователя, История, Настройки) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", "");
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	Результат.Вставить("Usage", Неопределено);
	Результат.Вставить("Ошибки", Неопределено);
	
	// Проверяем настройки подключения
	Если ПустаяСтрока(Настройки.Provider_ApiKey) ИЛИ ПустаяСтрока(Настройки.Provider_BaseUrl) Тогда
		
		Результат.Текст = "Не настроен API ключ или URL провайдера. Настройте подключение к ИИ провайдеру.";
		Возврат Результат;
		
	КонецЕсли;
	
	// Определяем тип провайдера
	ТипПровайдера = "";
	Если Настройки.Свойство("Provider_Type") Тогда
		ТипПровайдера = Настройки.Provider_Type;
	КонецЕсли;
	
	// Если провайдер Гигачат, вызываем его API
	Если ВРег(ТипПровайдера) = "GIGACHAT" ИЛИ ВРег(ТипПровайдера) = "ГИГАЧАТ" ИЛИ ПустаяСтрока(ТипПровайдера) Тогда
		
		Результат = ИИА_Гигачат.ВызватьГигачат(ТипСообщения, ТекстПользователя, История, Настройки);
		
	Иначе
		
		// Для других провайдеров можно добавить аналогичную логику
		Результат.Текст = "Неподдерживаемый тип провайдера: " + ТипПровайдера;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Формирует промпт для ИИ с учетом контекста
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//
// Возвращаемое значение:
//  Структура - структура с сообщениями для ИИ
//
Функция СформироватьПромптДляИИ(ТипСообщения, ТекстПользователя, История) Экспорт
	
	Результат = Новый Структура;
	Сообщения = Новый Массив;
	
	// Системный промпт
	СистемноеСообщение = Новый Структура;
	СистемноеСообщение.Вставить("role", "system");
	
	СистемныйПромпт = "Ты - ИИ-ассистент для работы с системой 1С:Предприятие. " + Символы.ПС +
		"Твоя задача - понимать команды пользователя и генерировать безопасные DSL-сценарии в формате JSON." + Символы.ПС +
		Символы.ПС +
		"Формат DSL: {""dsl_version"": 1, ""steps"": [{""action"": ""..."", ...}]}" + Символы.ПС +
		"Верни ТОЛЬКО JSON без дополнительных комментариев, объяснений или markdown блоков!" + Символы.ПС +
		Символы.ПС +
		"ДОСТУПНЫЕ ДЕЙСТВИЯ И ИХ ПАРАМЕТРЫ (используй ТОЛЬКО эти действия и параметры):" + Символы.ПС +
		Символы.ПС +
		"1. GetMetadata - получение списка всех объектов метаданных" + Символы.ПС +
		"   Параметры: нет" + Символы.ПС +
		"   Пример: {""action"": ""GetMetadata""}" + Символы.ПС +
		Символы.ПС +
		"2. CheckObjectExists - проверка существования объекта" + Символы.ПС +
		"   Параметры: object_name (строка), object_type (""Справочник"" или ""Документ"")" + Символы.ПС +
		"   Пример: {""action"": ""CheckObjectExists"", ""object_name"": ""Контрагенты"", ""object_type"": ""Справочник""}" + Символы.ПС +
		Символы.ПС +
		"3. GetObjectFields - получение реквизитов объекта" + Символы.ПС +
		"   Параметры: object_name (строка), object_type (""Справочник"" или ""Документ"")" + Символы.ПС +
		"   Пример: {""action"": ""GetObjectFields"", ""object_name"": ""Контрагенты"", ""object_type"": ""Справочник""}" + Символы.ПС +
		Символы.ПС +
		"4. CreateReference - создание элемента справочника" + Символы.ПС +
		"   Параметры: object_name (строка), data (структура с полями)" + Символы.ПС +
		"   Пример: {""action"": ""CreateReference"", ""object_name"": ""Контрагенты"", ""data"": {""Наименование"": ""Название""}}" + Символы.ПС +
		Символы.ПС +
		"5. CreateDocument - создание документа" + Символы.ПС +
		"   Параметры: object_name (строка), data (структура с полями)" + Символы.ПС +
		"   Пример: {""action"": ""CreateDocument"", ""object_name"": ""ЗаказКлиента"", ""data"": {""Дата"": ""2024-01-01""}}" + Символы.ПС +
		Символы.ПС +
		"6. FindReferenceByName - поиск объекта по наименованию" + Символы.ПС +
		"   Параметры: object_name (строка), name (строка) или value (строка)" + Символы.ПС +
		"   Пример: {""action"": ""FindReferenceByName"", ""object_name"": ""Контрагенты"", ""name"": ""Название""}" + Символы.ПС +
		Символы.ПС +
		"7. FindReferenceByGUID - поиск объекта по УИД" + Символы.ПС +
		"   Параметры: guid (строка)" + Символы.ПС +
		"   Пример: {""action"": ""FindReferenceByGUID"", ""guid"": ""уид-в-виде-строки""}" + Символы.ПС +
		Символы.ПС +
		"8. FindReferenceByURL - поиск объекта по навигационной ссылке" + Символы.ПС +
		"   Параметры: url (строка)" + Символы.ПС +
		"   Пример: {""action"": ""FindReferenceByURL"", ""url"": ""e1cib/data/Справочник.Контрагенты?ref=уид""}" + Символы.ПС +
		Символы.ПС +
		"17. SelectObject - выбор объекта по ссылке (из переменной или результата запроса)" + Символы.ПС +
		"    Параметры: object (ссылка)" + Символы.ПС +
		"    Пример: {""action"": ""SelectObject"", ""object"": ""#(CurrentItem.Ссылка)""}" + Символы.ПС +
		Символы.ПС +
		"9. SetField - установка значения реквизита (требует текущий объект, установленный через CreateReference/CreateDocument/FindReferenceBy*/SelectObject)" + Символы.ПС +
		"   Параметры: field_name (строка), value (любое значение)" + Символы.ПС +
		"   Пример: {""action"": ""SetField"", ""field_name"": ""Реквизит1"", ""value"": 555}" + Символы.ПС +
		Символы.ПС +
		"10. Write - запись объекта в базу данных" + Символы.ПС +
		"    Параметры: нет" + Символы.ПС +
		"    Пример: {""action"": ""Write""}" + Символы.ПС +
		Символы.ПС +
		"11. RunQuery - выполнение запроса на языке запросов 1С" + Символы.ПС +
		"    Параметры: query (строка с запросом)" + Символы.ПС +
		"    Пример: {""action"": ""RunQuery"", ""query"": ""ВЫБРАТЬ УникальныйИдентификатор(Контрагенты.Ссылка) КАК УИД ИЗ Справочник.Контрагенты КАК Контрагенты""}" + Символы.ПС +
		"    Результат выполнения сохраняется в контексте под именем РезультатЗапроса. Используй #(РезультатЗапроса) для доступа." + Символы.ПС +
		"    Для получения УИД используй функцию УникальныйИдентификатор(Ссылка) в запросе" + Символы.ПС +
		Символы.ПС +
		"12. ShowInfo - вывод информационного сообщения (автоматически открывает табличный документ, если есть результат RunQuery)" + Символы.ПС +
		"    Параметры: message (строка)" + Символы.ПС +
		"    Пример: {""action"": ""ShowInfo"", ""message"": ""Результаты запроса:""}" + Символы.ПС +
		Символы.ПС +
		"13. GetChangedObjects - получение всех измененных объектов из диалога" + Символы.ПС +
		"    Параметры: нет" + Символы.ПС +
		"    Пример: {""action"": ""GetChangedObjects""}" + Символы.ПС +
		Символы.ПС +
		"14. SaveToStorage - сохранение данных в хранилище значений" + Символы.ПС +
		"    Параметры: key (строка), data (любое сериализуемое значение)" + Символы.ПС +
		"    Пример: {""action"": ""SaveToStorage"", ""key"": ""обработано_контрагентов"", ""data"": 10}" + Символы.ПС +
		"    НЕ сохраняй ссылки на объекты БД! Сохраняй УИД в виде строки" + Символы.ПС +
		Символы.ПС +
		"15. LoadFromStorage - загрузка данных из хранилища значений" + Символы.ПС +
		"    Параметры: key (строка)" + Символы.ПС +
		"    Пример: {""action"": ""LoadFromStorage"", ""key"": ""обработано_контрагентов""}" + Символы.ПС +
		Символы.ПС +
		"16. ForEach - итерация по коллекции (массиву данных)" + Символы.ПС +
		"    Параметры:" + Символы.ПС +
		"     - collection (строка): имя ключа коллекции в контексте (например, ""РезультатЗапроса"" или ключ из LoadFromStorage)" + Символы.ПС +
		"     - steps (массив): последовательность действий для каждого элемента" + Символы.ПС +
		"    Доступ к текущему элементу внутри цикла через #(CurrentItem) или #(CurrentItem.ИмяПоля)" + Символы.ПС +
		"    Пример: {""action"": ""ForEach"", ""collection"": ""РезультатЗапроса"", ""steps"": [{""action"": ""FindReferenceByGUID"", ""guid"": ""#(CurrentItem.УИД)""}, {""action"": ""SetField"", ""field_name"": ""ПометкаНаУдаление"", ""value"": true}, {""action"": ""Write""}]}" + Символы.ПС +
		Символы.ПС +
		"ВАЖНО:" + Символы.ПС +
		"- Используй ТОЛЬКО перечисленные выше действия и параметры" + Символы.ПС +
		"- Для циклов используй ТОЛЬКО действие ForEach. Другие циклы (While, For и т.д.) НЕ ПОДДЕРЖИВАЮТСЯ." + Символы.ПС +
		"- Для массовых операций используй связку: GetObjectFields -> RunQuery -> ForEach" + Символы.ПС +
		"  * Сценарий: GetObjectFields -> RunQuery (ВЫБРАТЬ УникальныйИдентификатор...) -> ForEach (collection: ""РезультатЗапроса"") -> внутри: FindReferenceByGUID -> SetField -> Write" + Символы.ПС +
		"- Используй РЕАЛЬНЫЕ ссылки или УИД из результата RunQuery, а НЕ плейсхолдеры" + Символы.ПС +
		"- ВСЕГДА используй GetMetadata, CheckObjectExists, GetObjectFields для получения информации о метаданных" + Символы.ПС +
		"- Если нужна информация о структуре объектов, полях или существовании объекта, вызови соответствующее DSL-действие (GetMetadata, GetObjectFields, CheckObjectExists, RunQuery) прямо в рамках текущей задачи и используй полученные данные в следующем шаге" + Символы.ПС +
		"- Не перегружай системный промпт списками метаданных: запрашивай только те сведения, которые нужны для решения конкретной задачи" + Символы.ПС +
		"- Если задача требует ВЫВЕСТИ ДАННЫЕ (список, отчет и т.д.), ОБЯЗАТЕЛЬНО используй RunQuery для выборки данных и ShowInfo для показа. Просто получения метаданных НЕДОСТАТОЧНО." + Символы.ПС +
		"- Если задача требует ИЗМЕНИТЬ ДАННЫЕ (создать, обновить, пометить на удаление и т.д.), ОБЯЗАТЕЛЬНО используй Write, Delete или другие модифицирующие действия. Просто выборки данных через RunQuery НЕДОСТАТОЧНО.";
	СистемноеСообщение.Вставить("content", СистемныйПромпт);
	Сообщения.Добавить(СистемноеСообщение);
	
	// Добавляем историю диалога (системные сообщения из истории передаем как часть контекста в сообщениях пользователя)
	Для Каждого СтрокаИстории Из История Цикл
		
		Сообщение = Новый Структура;
		
		Если СтрокаИстории.Автор = Перечисления.ИИА_АвторСообщения.Пользователь Тогда
			Сообщение.Вставить("role", "user");
			ТекстСообщения = СтрокаИстории.Текст;
			Если НЕ ПустаяСтрока(СтрокаИстории.ТекстКода) Тогда
				ТекстСообщения = ТекстСообщения + Символы.ПС + "```" + Символы.ПС + СтрокаИстории.ТекстКода + Символы.ПС + "```";
			КонецЕсли;
			Сообщение.Вставить("content", ТекстСообщения);
			Сообщения.Добавить(Сообщение);
			
		ИначеЕсли СтрокаИстории.Автор = Перечисления.ИИА_АвторСообщения.ИИ Тогда
			Сообщение.Вставить("role", "assistant");
			ТекстСообщения = СтрокаИстории.Текст;
			Если НЕ ПустаяСтрока(СтрокаИстории.ТекстКода) Тогда
				ТекстСообщения = ТекстСообщения + Символы.ПС + "```" + Символы.ПС + СтрокаИстории.ТекстКода + Символы.ПС + "```";
			КонецЕсли;
			Сообщение.Вставить("content", ТекстСообщения);
			Сообщения.Добавить(Сообщение);
			
		ИначеЕсли СтрокаИстории.Автор = Перечисления.ИИА_АвторСообщения.Система Тогда
			// Системные сообщения из истории (результаты выполнения DSL) передаем как часть следующего сообщения пользователя
			// Это позволяет ИИ видеть результаты выполнения DSL-сценариев, но не нарушает требование API о единственном системном сообщении
			// Добавляем системное сообщение как контекст к следующему сообщению пользователя
			Если Сообщения.Количество() > 0 И Сообщения[Сообщения.Количество() - 1].role = "user" Тогда
				// Если последнее сообщение от пользователя, добавляем системную информацию к нему
				ПоследнееСообщение = Сообщения[Сообщения.Количество() - 1];
				ТекущийТекст = ПоследнееСообщение.content;
				ТекстСистемногоСообщения = "[Система] " + СтрокаИстории.Текст;
				ПоследнееСообщение.Вставить("content", ТекущийТекст + Символы.ПС + Символы.ПС + ТекстСистемногоСообщения);
			Иначе
				// Если нет предыдущего сообщения пользователя, создаем отдельное сообщение пользователя с системной информацией
				Сообщение.Вставить("role", "user");
				ТекстСистемногоСообщения = "[Система] " + СтрокаИстории.Текст;
				Сообщение.Вставить("content", ТекстСистемногоСообщения);
				Сообщения.Добавить(Сообщение);
			КонецЕсли;
			
		Иначе
			// Пропускаем неизвестные типы авторов
			Продолжить;
		КонецЕсли;
		
	КонецЦикла;
	
	// Добавляем текущее сообщение пользователя
	ТекущееСообщение = Новый Структура;
	ТекущееСообщение.Вставить("role", "user");
	ТекущееСообщение.Вставить("content", ТекстПользователя);
	Сообщения.Добавить(ТекущееСообщение);
	
	Результат.Вставить("Сообщения", Сообщения);
	
	Возврат Результат;
	
КонецФункции

// Извлекает DSL JSON из текста
//
// Параметры:
//  Текст - Строка - текст, из которого нужно извлечь JSON
//
// Возвращаемое значение:
//  Строка - извлеченный JSON или пустая строка, если не найден
//
Функция ИзвлечьDSLИзТекста(Текст) Экспорт
	
	Если ПустаяСтрока(Текст) Тогда
		Возврат "";
	КонецЕсли;
	
	ТекстДляПарсинга = СокрЛП(Текст);
	
	// Исправляем возможные ошибки JSON от ИИ (например, истина/ложь вместо true/false)
	ТекстДляПарсинга = СтрЗаменить(ТекстДляПарсинга, ": истина", ": true");
	ТекстДляПарсинга = СтрЗаменить(ТекстДляПарсинга, ": ложь", ": false");
	ТекстДляПарсинга = СтрЗаменить(ТекстДляПарсинга, ":истина", ": true");
	ТекстДляПарсинга = СтрЗаменить(ТекстДляПарсинга, ":ложь", ": false");
	
	// Ищем JSON в markdown блоках (```json ... ``` или ``` ... ```)
	// Может быть несколько блоков, ищем все и пробуем извлечь JSON из каждого
	НачалоБлока = СтрНайти(ТекстДляПарсинга, "```");
	Пока НачалоБлока > 0 Цикл
		// Найден markdown блок, извлекаем содержимое
		НачалоСодержимого = НачалоБлока + 3;
		// Ищем закрывающий блок
		КонецБлока = СтрНайти(ТекстДляПарсинга, "```", , НачалоСодержимого);
		Если КонецБлока > 0 Тогда
			СодержимоеБлока = Сред(ТекстДляПарсинга, НачалоСодержимого, КонецБлока - НачалоСодержимого);
			СодержимоеБлока = СокрЛП(СодержимоеБлока);
			// Убираем "json" если есть в начале
			Если Лев(СодержимоеБлока, 4) = "json" Тогда
				СодержимоеБлока = СокрЛП(Сред(СодержимоеБлока, 5));
			КонецЕсли;
			// Пробуем распарсить как JSON
			Если Лев(СокрЛП(СодержимоеБлока), 1) = "{" Тогда
				Попытка
					ЧтениеJSON = Новый ЧтениеJSON;
					ЧтениеJSON.УстановитьСтроку(СодержимоеБлока);
					ПроверкаJSON = ПрочитатьJSON(ЧтениеJSON);
					ЧтениеJSON.Закрыть();
					// Проверяем, что это DSL-сценарий
					Если ПроверкаJSON.Свойство("dsl_version") И ПроверкаJSON.Свойство("steps") Тогда
						Возврат СодержимоеБлока;
					ИначеЕсли ТипЗнч(ПроверкаJSON) = Тип("Структура") И ПроверкаJSON.Свойство("action") Тогда
						// Это объект действия - оборачиваем в DSL-сценарий
						DSLСценарий = Новый Структура;
						DSLСценарий.Вставить("dsl_version", 1);
						Шаги = Новый Массив;
						Шаги.Добавить(ПроверкаJSON);
						DSLСценарий.Вставить("steps", Шаги);
						// Преобразуем обратно в JSON
						ЗаписьJSON = Новый ЗаписьJSON;
						ЗаписьJSON.УстановитьСтроку();
						ЗаписатьJSON(ЗаписьJSON, DSLСценарий);
						Возврат ЗаписьJSON.Закрыть();
					КонецЕсли;
				Исключение
					// Не JSON или не DSL - продолжаем поиск
				КонецПопытки;
			КонецЕсли;
			// Переходим к следующему блоку
			Если КонецБлока + 3 <= СтрДлина(ТекстДляПарсинга) Тогда
				НачалоБлока = СтрНайти(ТекстДляПарсинга, "```", , КонецБлока + 3);
			Иначе
				Прервать;
			КонецЕсли;
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	// Сначала проверяем, начинается ли текст с "{"
	Если Лев(ТекстДляПарсинга, 1) = "{" Тогда
		
		Попытка
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ТекстДляПарсинга);
			ПроверкаJSON = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			
			// Проверяем, что это DSL-сценарий
			Если ПроверкаJSON.Свойство("dsl_version") И ПроверкаJSON.Свойство("steps") Тогда
				Возврат ТекстДляПарсинга;
			ИначеЕсли ТипЗнч(ПроверкаJSON) = Тип("Структура") И ПроверкаJSON.Свойство("action") Тогда
				// Это объект действия - оборачиваем в DSL-сценарий
				DSLСценарий = Новый Структура;
				DSLСценарий.Вставить("dsl_version", 1);
				Шаги = Новый Массив;
				Шаги.Добавить(ПроверкаJSON);
				DSLСценарий.Вставить("steps", Шаги);
				
				// Преобразуем обратно в JSON
				ЗаписьJSON = Новый ЗаписьJSON;
				ЗаписьJSON.УстановитьСтроку();
				ЗаписатьJSON(ЗаписьJSON, DSLСценарий);
				Возврат ЗаписьJSON.Закрыть();
			КонецЕсли;
			
		Исключение
			// Не JSON или не DSL - продолжаем поиск
		КонецПопытки;
		
	КонецЕсли;
	
	// Если текст не начинается с "{", ищем JSON внутри текста
	НачалоОткрывающейСкобки = СтрНайти(Текст, "{");
	Если НачалоОткрывающейСкобки > 0 Тогда
		
		// Ищем закрывающую скобку с балансом скобок, учитывая строки
		ГлубинаВложенности = 0;
		КонецЗакрывающейСкобки = 0;
		ВнутриСтроки = Ложь;
		Экранирование = Ложь;
		
		Для Индекс = НачалоОткрывающейСкобки По СтрДлина(Текст) Цикл
			Символ = Сред(Текст, Индекс, 1);
			
			Если ВнутриСтроки Тогда
				Если Экранирование Тогда
					Экранирование = Ложь;
				ИначеЕсли Символ = "\" Тогда
					Экранирование = Истина;
				ИначеЕсли Символ = """" Тогда
					ВнутриСтроки = Ложь;
				КонецЕсли;
			Иначе
				Если Символ = """" Тогда
					ВнутриСтроки = Истина;
				ИначеЕсли Символ = "{" Тогда
					ГлубинаВложенности = ГлубинаВложенности + 1;
				ИначеЕсли Символ = "}" Тогда
					ГлубинаВложенности = ГлубинаВложенности - 1;
					Если ГлубинаВложенности = 0 Тогда
						КонецЗакрывающейСкобки = Индекс;
						Прервать;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		Если КонецЗакрывающейСкобки > 0 И КонецЗакрывающейСкобки > НачалоОткрывающейСкобки Тогда
			
			ВозможныйJSON = Сред(Текст, НачалоОткрывающейСкобки, КонецЗакрывающейСкобки - НачалоОткрывающейСкобки + 1);
			
			Попытка
				ЧтениеJSON = Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(ВозможныйJSON);
				ПроверкаJSON = ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				
				// Проверяем, что это DSL-сценарий
				Если ПроверкаJSON.Свойство("dsl_version") И ПроверкаJSON.Свойство("steps") Тогда
					Возврат ВозможныйJSON;
				ИначеЕсли ТипЗнч(ПроверкаJSON) = Тип("Структура") И ПроверкаJSON.Свойство("action") Тогда
					// Это объект действия - оборачиваем в DSL-сценарий
					DSLСценарий = Новый Структура;
					DSLСценарий.Вставить("dsl_version", 1);
					Шаги = Новый Массив;
					Шаги.Добавить(ПроверкаJSON);
					DSLСценарий.Вставить("steps", Шаги);
					
					// Преобразуем обратно в JSON
					ЗаписьJSON = Новый ЗаписьJSON;
					ЗаписьJSON.УстановитьСтроку();
					ЗаписатьJSON(ЗаписьJSON, DSLСценарий);
					Возврат ЗаписьJSON.Закрыть();
				КонецЕсли;
				
			Исключение
				// Не JSON или не DSL - пробуем найти другой JSON блок
			КонецПопытки;
			
		КонецЕсли;
		
		// Если не нашли по балансу, пробуем найти последнюю закрывающую скобку
		Если КонецЗакрывающейСкобки = 0 Тогда
			КонецЗакрывающейСкобки = СтрНайти(Текст, "}", НаправлениеПоиска.СКонца);
			Если КонецЗакрывающейСкобки > 0 И КонецЗакрывающейСкобки > НачалоОткрывающейСкобки Тогда
				
				ВозможныйJSON = Сред(Текст, НачалоОткрывающейСкобки, КонецЗакрывающейСкобки - НачалоОткрывающейСкобки + 1);
				
				Попытка
					ЧтениеJSON = Новый ЧтениеJSON;
					ЧтениеJSON.УстановитьСтроку(ВозможныйJSON);
					ПроверкаJSON = ПрочитатьJSON(ЧтениеJSON);
					ЧтениеJSON.Закрыть();
					
					// Проверяем, что это DSL-сценарий
					Если ПроверкаJSON.Свойство("dsl_version") И ПроверкаJSON.Свойство("steps") Тогда
						Возврат ВозможныйJSON;
					КонецЕсли;
					
				Исключение
					// Не JSON или не DSL
				КонецПопытки;
				
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

// Распознает ответ ИИ и определяет его тип
//
// Параметры:
//  ТекстОтветаИИ - Строка - текст ответа от ИИ
//  ТипСообщения - Строка - тип исходного сообщения
//
// Возвращаемое значение:
//  Структура - структура результата с распознанным типом и данными
//
Функция РаспознатьОтветИИ(ТекстОтветаИИ, ТипСообщения) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", ТекстОтветаИИ);
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	
	// Пытаемся найти JSON в ответе (DSL-сценарий)
	ИзвлеченныйDSL = ИзвлечьDSLИзТекста(ТекстОтветаИИ);
	
	Если НЕ ПустаяСтрока(ИзвлеченныйDSL) Тогда
		
		// Проверяем, является ли извлеченный JSON полным DSL-сценарием или просто объектом действия
		Попытка
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ИзвлеченныйDSL);
			JSONОбъект = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			
			// Если это структура с полем "action", но без "dsl_version" и "steps", оборачиваем в DSL-сценарий
			Если ТипЗнч(JSONОбъект) = Тип("Структура") 
				И JSONОбъект.Свойство("action") 
				И НЕ JSONОбъект.Свойство("dsl_version") 
				И НЕ JSONОбъект.Свойство("steps") Тогда
				
				// Оборачиваем в формат DSL-сценария
				DSLСценарий = Новый Структура;
				DSLСценарий.Вставить("dsl_version", 1);
				Шаги = Новый Массив;
				Шаги.Добавить(JSONОбъект);
				DSLСценарий.Вставить("steps", Шаги);
				
				// Преобразуем обратно в JSON
				ЗаписьJSON = Новый ЗаписьJSON;
				ЗаписьJSON.УстановитьСтроку();
				ЗаписатьJSON(ЗаписьJSON, DSLСценарий);
				ИзвлеченныйDSL = ЗаписьJSON.Закрыть();
				
			КонецЕсли;
			
		Исключение
			// Игнорируем ошибки парсинга, используем извлеченный DSL как есть
		КонецПопытки;
		
		Результат.ТипОтвета = "DSL";
		Результат.DSL = ИзвлеченныйDSL;
		Результат.ВыполнитьDSL = Истина; // Выполняем DSL-сценарий автоматически
		
		// Извлекаем текст перед JSON (если есть)
		НачалоОткрывающейСкобки = СтрНайти(ТекстОтветаИИ, "{");
		Если НачалоОткрывающейСкобки > 1 Тогда
			ТекстПередJSON = СокрЛП(Лев(ТекстОтветаИИ, НачалоОткрывающейСкобки - 1));
			Если НЕ ПустаяСтрока(ТекстПередJSON) Тогда
				Результат.Текст = ТекстПередJSON;
			Иначе
				Результат.Текст = "Сгенерирован DSL-сценарий:";
			КонецЕсли;
		Иначе
			Результат.Текст = "Сгенерирован DSL-сценарий:";
		КонецЕсли;
		
		Возврат Результат;
		
	КонецЕсли;
	
	// Если тип сообщения "Запрос", пытаемся найти запрос в ответе
	Если ТипСообщения = "Запрос" Тогда
		
		// Ищем блок кода с запросом
		НачалоБлока = СтрНайти(ТекстОтветаИИ, "```");
		Если НачалоБлока > 0 Тогда
			
			// Ищем вторую тройку обратных кавычек после первой, начиная с позиции после первой
			КонецБлока = СтрНайти(ТекстОтветаИИ, "```", , НачалоБлока + 3);
			Если КонецБлока > 0 Тогда
				
				ТекстЗапроса = Сред(ТекстОтветаИИ, НачалоБлока + 3, КонецБлока - НачалоБлока - 3);
				ТекстЗапроса = СокрЛП(ТекстЗапроса);
				
				// Проверяем, что это похоже на запрос 1С
				Если СтрНайти(ВРег(ТекстЗапроса), "ВЫБРАТЬ") > 0 Тогда
					
					Результат.ТипОтвета = "Запрос";
					Результат.Запрос = ТекстЗапроса;
					Результат.Текст = "Сгенерирован запрос:";
					
					Возврат Результат;
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// По умолчанию возвращаем как текст
	Возврат Результат;
	
КонецФункции


#КонецОбласти
