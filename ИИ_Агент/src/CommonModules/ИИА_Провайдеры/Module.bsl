#Область ПрограммныйИнтерфейс

// Вызывает ИИ для получения ответа
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  Настройки - Структура - настройки пользователя
//
// Возвращаемое значение:
//  Структура - структура ответа:
//   * ТипОтвета - Строка ("Текст", "Запрос" или "DSL")
//   * Текст - Строка - текст ответа
//   * Запрос - Строка - текст запроса (для типа "Запрос")
//   * DSL - Строка - JSON с DSL-сценарием (для типа "DSL")
//   * ВыполнитьDSL - Булево - выполнить ли DSL сразу (для типа "DSL")
//   * Usage - Структура - информация об использовании токенов
//   * Ошибки - ОписаниеОшибки - информация об ошибках
//
Функция ВызватьИИ(ТипСообщения, ТекстПользователя, История, Настройки) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", "");
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	Результат.Вставить("Usage", Неопределено);
	Результат.Вставить("Ошибки", Неопределено);
	
	// Проверяем настройки подключения
	Если ПустаяСтрока(Настройки.Provider_ApiKey) ИЛИ ПустаяСтрока(Настройки.Provider_BaseUrl) Тогда
		
		Результат.Текст = "Не настроен API ключ или URL провайдера. Настройте подключение к ИИ провайдеру.";
		Возврат Результат;
		
	КонецЕсли;
	
	// Определяем тип провайдера
	ТипПровайдера = "";
	Если Настройки.Свойство("Provider_Type") Тогда
		ТипПровайдера = Настройки.Provider_Type;
	КонецЕсли;
	
	// Если провайдер Гигачат, вызываем его API
	Если ВРег(ТипПровайдера) = "GIGACHAT" ИЛИ ВРег(ТипПровайдера) = "ГИГАЧАТ" ИЛИ ПустаяСтрока(ТипПровайдера) Тогда
		
		Результат = ИИА_Гигачат.ВызватьГигачат(ТипСообщения, ТекстПользователя, История, Настройки);
		
	Иначе
		
		// Для других провайдеров можно добавить аналогичную логику
		Результат.Текст = "Неподдерживаемый тип провайдера: " + ТипПровайдера;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Получает метаданные конфигурации для передачи в ИИ
//
// Возвращаемое значение:
//  Структура - структура с метаданными
//
Функция ПолучитьМетаданныеДляИИ() Экспорт
	
	Результат = Новый Структура;
	
	// Получаем списки объектов
	Результат.Вставить("Справочники", ИИА_Метаданные.ПолучитьСписокСправочников());
	Результат.Вставить("Документы", ИИА_Метаданные.ПолучитьСписокДокументов());
	Результат.Вставить("РегистрыСведений", ИИА_Метаданные.ПолучитьСписокРегистровСведений());
	Результат.Вставить("РегистрыНакопления", ИИА_Метаданные.ПолучитьСписокРегистровНакопления());
	Результат.Вставить("РегистрыБухгалтерии", ИИА_Метаданные.ПолучитьСписокРегистровБухгалтерии());
	
	Возврат Результат;
	
КонецФункции

// Формирует промпт для ИИ с учетом контекста
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  МетаданныеКонтекст - Структура - метаданные конфигурации
//
// Возвращаемое значение:
//  Структура - структура с сообщениями для ИИ
//
Функция СформироватьПромптДляИИ(ТипСообщения, ТекстПользователя, История, МетаданныеКонтекст) Экспорт
	
	Результат = Новый Структура;
	Сообщения = Новый Массив;
	
	// Системный промпт
	СистемноеСообщение = Новый Структура;
	СистемноеСообщение.Вставить("role", "system");
	
	СистемныйПромпт = "Ты - ИИ-ассистент для работы с системой 1С:Предприятие. " + Символы.ПС +
		"Твоя задача - понимать команды пользователя и генерировать безопасные DSL-сценарии или запросы на языке запросов 1С." + Символы.ПС +
		Символы.ПС +
		"ВАЖНО о получении информации о метаданных конфигурации:" + Символы.ПС +
		"НЕ используй заранее известные названия объектов конфигурации!" + Символы.ПС +
		"ВСЕГДА используй DSL-действия для получения информации о метаданных:" + Символы.ПС +
		"1. Для получения списка всех объектов используй GetMetadata (возвращает списки справочников, документов, регистров)" + Символы.ПС +
		"2. Для проверки существования объекта используй CheckObjectExists (object_name, object_type)" + Символы.ПС +
		"3. Для получения реквизитов объекта используй GetObjectFields (object_name, object_type)" + Символы.ПС +
		"4. Если пользователь упоминает объект, но ты не уверен в его существовании - сначала проверь через CheckObjectExists" + Символы.ПС +
		"5. Если нужно узнать структуру объекта (какие реквизиты есть) - используй GetObjectFields перед работой с объектом" + Символы.ПС +
		"Пример последовательности:" + Символы.ПС +
		"1. Пользователь: ""создай контрагента"" - сначала проверь существование: {""action"": ""CheckObjectExists"", ""object_name"": ""Контрагенты"", ""object_type"": ""Справочник""}" + Символы.ПС +
		"2. Если нужно узнать реквизиты: {""action"": ""GetObjectFields"", ""object_name"": ""Контрагенты"", ""object_type"": ""Справочник""}" + Символы.ПС +
		"3. Затем создай объект: {""action"": ""CreateReference"", ""object_name"": ""Контрагенты"", ""data"": {""Наименование"": ""Название""}}" + Символы.ПС +
		"Если пользователь упоминает объект, который может не существовать, ВСЕГДА сначала проверь его существование!" + Символы.ПС +
		Символы.ПС +
		"Формат DSL-сценария:" + Символы.ПС +
		"{""dsl_version"": 1, ""steps"": [{""action"": ""CreateReference"", ""object_name"": ""ИмяСправочника""}, ...]}" + Символы.ПС +
		"Доступные действия: CreateReference, CreateDocument, FindReferenceByName, FindReferenceByGUID, FindReferenceByURL, SetField, Write, RunQuery, ShowInfo, GetChangedObjects, GetMetadata, GetObjectFields, CheckObjectExists, SaveToStorage, LoadFromStorage, ClearStorage, ListStorageKeys" + Символы.ПС +
		Символы.ПС +
		"ВАЖНО о поиске объектов:" + Символы.ПС +
		"FindReferenceByName - поиск по наименованию (параметры: object_name, name или value)" + Символы.ПС +
		"FindReferenceByGUID - поиск по УИД (параметр: guid, object_name не обязателен) - ПРЕДПОЧТИТЕЛЬНО для массовых операций" + Символы.ПС +
		"   Функция автоматически определяет тип объекта (справочник, документ и т.д.) по УИД" + Символы.ПС +
		"FindReferenceByURL - поиск по навигационной ссылке (параметр: url)" + Символы.ПС +
		Символы.ПС +
		"Как получить УИД элемента справочника:" + Символы.ПС +
		"Используй запрос с полем Ссылка.УникальныйИдентификатор:" + Символы.ПС +
		"{""action"": ""RunQuery"", ""query"": ""ВЫБРАТЬ Контрагенты.Ссылка.УникальныйИдентификатор КАК УИД, Контрагенты.Ссылка, Контрагенты.Наименование ИЗ Справочник.Контрагенты КАК Контрагенты""}" + Символы.ПС +
		"После получения УИД из результата запроса используй FindReferenceByGUID для поиска конкретного объекта:" + Символы.ПС +
		"{""action"": ""FindReferenceByGUID"", ""guid"": ""полученный-уид-из-запроса""}" + Символы.ПС +
		"Примечание: object_name не обязателен, так как функция автоматически определяет тип объекта по УИД" + Символы.ПС +
		Символы.ПС +
		"КРИТИЧЕСКИ ВАЖНО: DSL НЕ поддерживает циклы (ForEach, While, For и т.д.)!" + Символы.ПС +
		"НЕ используй несуществующие действия типа ForEach, While, Loop и т.п.!" + Символы.ПС +
		Символы.ПС +
		"ВАЖНО о разбиении больших задач на несколько DSL-сценариев:" + Символы.ПС +
		"Если задача требует обработки большого количества объектов (более 10-20), РАЗБЕЙ её на несколько DSL-сценариев!" + Символы.ПС +
		"Система автоматически продолжит выполнение следующих сценариев, пока задача не будет выполнена полностью." + Символы.ПС +
		"План разбиения большой задачи:" + Символы.ПС +
		"1. ПЕРВЫЙ сценарий: подготовка данных" + Символы.ПС +
		"   - GetObjectFields для получения списка реквизитов" + Символы.ПС +
		"   - RunQuery для получения списка всех объектов с УИД (включай Ссылка.УникальныйИдентификатор КАК УИД)" + Символы.ПС +
		"   - SaveToStorage для сохранения полного списка УИД в хранилище с ключом (например, ""список_уид_для_обработки"")" + Символы.ПС +
		"   - SaveToStorage для сохранения счетчика обработанных объектов (например, ""обработано_объектов"": 0)" + Символы.ПС +
		"2. ВТОРОЙ и последующие сценарии: обработка пакетов объектов" + Символы.ПС +
		"   - LoadFromStorage для загрузки списка УИД и счетчика" + Символы.ПС +
		"   - Обработай следующий пакет объектов (10-20 штук), начиная с позиции счетчика" + Символы.ПС +
		"   - Для каждого объекта в пакете: FindReferenceByGUID -> SetField -> Write" + Символы.ПС +
		"   - Обнови счетчик обработанных объектов в хранилище" + Символы.ПС +
		"   - Если остались необработанные объекты, сохрани обновленный счетчик" + Символы.ПС +
		"   - Если все объекты обработаны, используй ShowInfo с сообщением о завершении" + Символы.ПС +
		"Система автоматически продолжит выполнение следующего сценария, если задача еще не выполнена." + Символы.ПС +
		"Пример первого сценария для заполнения реквизита 'Реквизит1' = 555 у всех контрагентов:" + Символы.ПС +
		"{""dsl_version"": 1, ""steps"": [" + Символы.ПС +
		"  {""action"": ""GetObjectFields"", ""object_name"": ""Контрагенты"", ""object_type"": ""Справочник""}," + Символы.ПС +
		"  {""action"": ""RunQuery"", ""query"": ""ВЫБРАТЬ Контрагенты.Ссылка.УникальныйИдентификатор КАК УИД ИЗ Справочник.Контрагенты КАК Контрагенты""}," + Символы.ПС +
		"  {""action"": ""SaveToStorage"", ""key"": ""список_уид_контрагентов"", ""data"": ""<результат_из_RunQuery>""}," + Символы.ПС +
		"  {""action"": ""SaveToStorage"", ""key"": ""обработано_контрагентов"", ""data"": 0}" + Символы.ПС +
		"]}" + Символы.ПС +
		"Пример второго сценария (обработка первых 10 контрагентов):" + Символы.ПС +
		"{""dsl_version"": 1, ""steps"": [" + Символы.ПС +
		"  {""action"": ""LoadFromStorage"", ""key"": ""список_уид_контрагентов""}," + Символы.ПС +
		"  {""action"": ""LoadFromStorage"", ""key"": ""обработано_контрагентов""}," + Символы.ПС +
		"  {""action"": ""FindReferenceByGUID"", ""guid"": ""<уид1>""}," + Символы.ПС +
		"  {""action"": ""SetField"", ""field_name"": ""Реквизит1"", ""value"": 555}," + Символы.ПС +
		"  {""action"": ""Write""}," + Символы.ПС +
		"  ... (повтори для следующих 9 объектов)," + Символы.ПС +
		"  {""action"": ""SaveToStorage"", ""key"": ""обработано_контрагентов"", ""data"": 10}" + Символы.ПС +
		"]}" + Символы.ПС +
		"ВАЖНО: Используй ListStorageKeys в начале второго и последующих сценариев, чтобы проверить, какие данные уже сохранены!" + Символы.ПС +
		"Если данных нет в хранилище, значит первый сценарий еще не выполнен - создай первый сценарий." + Символы.ПС +
		"Если данные есть, но задача не выполнена - создай следующий сценарий для обработки следующего пакета объектов." + Символы.ПС +
		Символы.ПС +
		"FindReferenceByURL используется для работы с навигационными ссылками из интерфейса 1С." + Символы.ПС +
		"Формат навигационной ссылки: ""e1cib/data/Справочник.Контрагенты?ref=УИД"" или ""e1cib/data/Документ.ЗаказКлиента?ref=УИД""" + Символы.ПС +
		"Пример: {""action"": ""FindReferenceByURL"", ""url"": ""e1cib/data/Справочник.Контрагенты?ref=уид-объекта""}" + Символы.ПС +
		Символы.ПС +
		"ВАЖНО: RunQuery - выполняет запрос на языке запросов 1С (НЕ код 1С!)." + Символы.ПС +
		"Формат: {""action"": ""RunQuery"", ""query"": ""ВЫБРАТЬ ... ИЗ ...""}" + Символы.ПС +
		"Примеры правильных запросов:" + Символы.ПС +
		"1. Подсчет количества контрагентов:" + Символы.ПС +
		"   {""action"": ""RunQuery"", ""query"": ""ВЫБРАТЬ КОЛИЧЕСТВО(РАЗЛИЧНЫЕ Контрагенты.Ссылка) КАК Количество ИЗ Справочник.Контрагенты КАК Контрагенты""}" + Символы.ПС +
		"2. Список контрагентов:" + Символы.ПС +
		"   {""action"": ""RunQuery"", ""query"": ""ВЫБРАТЬ Контрагенты.Ссылка, Контрагенты.Наименование ИЗ Справочник.Контрагенты КАК Контрагенты""}" + Символы.ПС +
		"3. После RunQuery ОБЯЗАТЕЛЬНО используй ShowInfo для вывода результата:" + Символы.ПС +
		"   {""action"": ""ShowInfo"", ""message"": ""Количество контрагентов: {Количество}""}" + Символы.ПС +
		"   или для списка:" + Символы.ПС +
		"   {""action"": ""ShowInfo"", ""message"": ""Результаты запроса:""}" + Символы.ПС +
		"ShowInfo автоматически откроет табличный документ с результатами запроса, если они есть." + Символы.ПС +
		"НЕ используй код 1С (например, Справочник.Контрагенты.Количество()) в RunQuery!" + Символы.ПС +
		"НЕ используй FindReferenceByName для подсчета - используй RunQuery!" + Символы.ПС +
		Символы.ПС +
		"ВАЖНО о SetField:" + Символы.ПС +
		"SetField требует текущий объект, который должен быть установлен ПЕРЕД SetField через CreateReference, CreateDocument, FindReferenceByName, FindReferenceByGUID или FindReferenceByURL." + Символы.ПС +
		"НЕЛЬЗЯ использовать SetField сразу после RunQuery - RunQuery НЕ устанавливает текущий объект!" + Символы.ПС +
		"ВАЖНО: DSL НЕ поддерживает циклы! Для массового заполнения нужно явно перечислить все шаги." + Символы.ПС +
		"Для массового заполнения реквизита у всех объектов:" + Символы.ПС +
		"1. Сначала получи реквизиты объекта через GetObjectFields, чтобы узнать правильное имя реквизита" + Символы.ПС +
		"2. Используй RunQuery для получения списка объектов с УИД:" + Символы.ПС +
		"   {""action"": ""RunQuery"", ""query"": ""ВЫБРАТЬ Контрагенты.Ссылка.УникальныйИдентификатор КАК УИД ИЗ Справочник.Контрагенты КАК Контрагенты""}" + Символы.ПС +
		"3. Сохрани результат в хранилище для использования в следующих сценариях:" + Символы.ПС +
		"   {""action"": ""SaveToStorage"", ""key"": ""список_уид"", ""data"": ""<результат_из_RunQuery>""}" + Символы.ПС +
		"4. Создай DSL-сценарий с явным перечислением шагов для каждого УИД (до 10-20 объектов за раз):" + Символы.ПС +
		"   Для каждого УИД добавь три шага:" + Символы.ПС +
		"   - FindReferenceByGUID с guid (УИД из результата запроса)" + Символы.ПС +
		"   - SetField для установки значения реквизита (используй правильное имя реквизита из GetObjectFields)" + Символы.ПС +
		"   - Write для сохранения изменений" + Символы.ПС +
		"Пример полного сценария для заполнения реквизита 'Реквизит1' = 555 у первых 10 контрагентов:" + Символы.ПС +
		"{""dsl_version"": 1, ""steps"": [" + Символы.ПС +
		"  {""action"": ""GetObjectFields"", ""object_name"": ""Контрагенты"", ""object_type"": ""Справочник""}," + Символы.ПС +
		"  {""action"": ""RunQuery"", ""query"": ""ВЫБРАТЬ ПЕРВЫЕ 10 Контрагенты.Ссылка.УникальныйИдентификатор КАК УИД ИЗ Справочник.Контрагенты КАК Контрагенты""}," + Символы.ПС +
		"  {""action"": ""SaveToStorage"", ""key"": ""список_уид"", ""data"": ""<результат_из_RunQuery>""}," + Символы.ПС +
		"  {""action"": ""FindReferenceByGUID"", ""guid"": ""<уид1>""}," + Символы.ПС +
		"  {""action"": ""SetField"", ""field_name"": ""Реквизит1"", ""value"": 555}," + Символы.ПС +
		"  {""action"": ""Write""}," + Символы.ПС +
		"  {""action"": ""FindReferenceByGUID"", ""guid"": ""<уид2>""}," + Символы.ПС +
		"  {""action"": ""SetField"", ""field_name"": ""Реквизит1"", ""value"": 555}," + Символы.ПС +
		"  {""action"": ""Write""}," + Символы.ПС +
		"  ... (повтори для каждого УИД)" + Символы.ПС +
		"]}" + Символы.ПС +
		"Если объектов много, выполни несколько DSL-сценариев последовательно, используя хранилище для передачи списка УИД." + Символы.ПС +
		"Если нужно заполнить реквизит у одного объекта, используй: FindReferenceByGUID (или FindReferenceByName) -> SetField -> Write." + Символы.ПС +
		"ПРЕДПОЧТИТЕЛЬНО использовать FindReferenceByGUID вместо FindReferenceByName для массовых операций, так как УИД уникален и надежнее." + Символы.ПС +
		Символы.ПС +
		"GetChangedObjects - получает все ссылки на объекты из табличной части 'ИзмененныеОбъекты' диалога (не требует параметров)" + Символы.ПС +
		"ShowInfo - выводит информационное сообщение пользователю (параметр: message)" + Символы.ПС +
		Символы.ПС +
		"Действия для работы с метаданными:" + Символы.ПС +
		"GetMetadata - получает списки всех объектов метаданных конфигурации (справочники, документы, регистры). Не требует параметров." + Символы.ПС +
		"   Пример: {""action"": ""GetMetadata""}" + Символы.ПС +
		"   Возвращает структуру с массивами: Справочники, Документы, РегистрыСведений, РегистрыНакопления, РегистрыБухгалтерии" + Символы.ПС +
		"   Каждый элемент массива содержит: Имя, Синоним" + Символы.ПС +
		"GetObjectFields - получает реквизиты справочника или документа (параметры: object_name, object_type)" + Символы.ПС +
		"   object_type должен быть 'Справочник' или 'Документ'" + Символы.ПС +
		"   Пример для справочника: {""action"": ""GetObjectFields"", ""object_name"": ""Контрагенты"", ""object_type"": ""Справочник""}" + Символы.ПС +
		"   Пример для документа: {""action"": ""GetObjectFields"", ""object_name"": ""ЗаказКлиента"", ""object_type"": ""Документ""}" + Символы.ПС +
		"   Возвращает структуру с полями: Найден, Имя, Синоним, Реквизиты (массив с Имя, Синоним, Тип)" + Символы.ПС +
		"   Для документов также возвращает ТабличныеЧасти" + Символы.ПС +
		"CheckObjectExists - проверяет существование справочника или документа (параметры: object_name, object_type)" + Символы.ПС +
		"   object_type должен быть 'Справочник' или 'Документ'" + Символы.ПС +
		"   Пример: {""action"": ""CheckObjectExists"", ""object_name"": ""Контрагенты"", ""object_type"": ""Справочник""}" + Символы.ПС +
		"   Возвращает структуру с полями: Существует (Булево), Имя, Тип" + Символы.ПС +
		"КРИТИЧЕСКИ ВАЖНО: Используй эти действия для получения информации о структуре конфигурации!" + Символы.ПС +
		"НЕ предполагай существование объектов - ВСЕГДА проверяй через CheckObjectExists!" + Символы.ПС +
		"НЕ предполагай структуру объектов - ВСЕГДА получай реквизиты через GetObjectFields!" + Символы.ПС +
		"Если пользователь упоминает объект, сначала проверь его существование, затем получи его реквизиты, затем работай с ним." + Символы.ПС +
		"Пример последовательности при работе с объектом:" + Символы.ПС +
		"1. Проверь существование: {""action"": ""CheckObjectExists"", ""object_name"": ""Контрагенты"", ""object_type"": ""Справочник""}" + Символы.ПС +
		"2. Получи реквизиты: {""action"": ""GetObjectFields"", ""object_name"": ""Контрагенты"", ""object_type"": ""Справочник""}" + Символы.ПС +
		"3. Работай с объектом: {""action"": ""CreateReference"", ""object_name"": ""Контрагенты"", ""data"": {""Наименование"": ""Название""}}" + Символы.ПС +
		Символы.ПС +
		"Если пользователь просит создать или найти объект, генерируй DSL-сценарий в формате JSON." + Символы.ПС +
		"Если пользователь просит выполнить запрос или узнать количество/список объектов, используй RunQuery с запросом на языке запросов 1С." + Символы.ПС +
		Символы.ПС +
		"Важно о хранении объектов:" + Символы.ПС +
		"- Все ссылки на созданные или измененные объекты автоматически сохраняются в табличной части 'ИзмененныеОбъекты' диалога." + Символы.ПС +
		"- Эти ссылки можно использовать для последующего редактирования объектов, анализа результатов работы и выполнения дополнительных операций с ними." + Символы.ПС +
		"- Для получения всех объектов из табличной части используй действие GetChangedObjects (не требует параметров)." + Символы.ПС +
		"- После выполнения DSL-сценария для проверки результата используй GetChangedObjects, чтобы получить все созданные/измененные объекты, затем проверь их реквизиты." + Символы.ПС +
		"- При необходимости работы с ранее созданными объектами, используй информацию из истории диалога, где указаны ссылки на эти объекты." + Символы.ПС +
		Символы.ПС +
		"ВАЖНО о работе с хранилищем значений (ХранилищеЗначения):" + Символы.ПС +
		"ХранилищеЗначения - это реквизит диалога, который позволяет сохранять промежуточные результаты между выполнением нескольких DSL-сценариев." + Символы.ПС +
		"Хранилище хранит данные в специальном формате. К значению нельзя обращаться напрямую - его можно только извлечь из хранилища." + Символы.ПС +
		"В хранилище можно сохранять сериализуемые объекты: структуры, массивы, таблицы значений, результаты запросов (массивы структур), примитивные типы (строки, числа, даты, булево) и другие сериализуемые данные." + Символы.ПС +
		"КРИТИЧЕСКИ ВАЖНО: НЕ сохраняй в хранилище ссылки на объекты базы данных (СправочникСсылка, ДокументСсылка и т.д.)!" + Символы.ПС +
		"   Вместо ссылок сохраняй УИД (УникальныйИдентификатор) объектов в виде строки, затем используй FindReferenceByGUID для получения ссылки." + Символы.ПС +
		"   Пример: вместо сохранения ссылки сохрани УИД: {""action"": ""RunQuery"", ""query"": ""ВЫБРАТЬ Контрагенты.Ссылка.УникальныйИдентификатор КАК УИД ИЗ Справочник.Контрагенты""}" + Символы.ПС +
		"   Затем сохрани результат запроса (массив структур с УИД) в хранилище, а не сами ссылки." + Символы.ПС +
		"Хранилище доступно только в рамках одного диалога (сессии пользователя)." + Символы.ПС +
		Символы.ПС +
		"Действия для работы с хранилищем:" + Символы.ПС +
		"SaveToStorage - сохраняет данные в хранилище (параметры: key, data)" + Символы.ПС +
		"   key - строка, уникальный ключ для сохранения данных" + Символы.ПС +
		"   data - произвольные данные (структура, массив, таблица значений и т.д.)" + Символы.ПС +
		"   Пример: {""action"": ""SaveToStorage"", ""key"": ""результаты_запроса"", ""data"": {""количество"": 10, ""список"": [""элемент1"", ""элемент2""]}}" + Символы.ПС +
		"   Пример сохранения результата RunQuery: после RunQuery сохрани результат в хранилище с понятным ключом" + Символы.ПС +
		"   {""action"": ""RunQuery"", ""query"": ""ВЫБРАТЬ ...""}" + Символы.ПС +
		"   {""action"": ""SaveToStorage"", ""key"": ""список_контрагентов"", ""data"": ""<результат_из_предыдущего_шага>""}" + Символы.ПС +
		Символы.ПС +
		"LoadFromStorage - загружает данные из хранилища (параметр: key)" + Символы.ПС +
		"   key - строка, ключ данных для загрузки" + Символы.ПС +
		"   Пример: {""action"": ""LoadFromStorage"", ""key"": ""результаты_запроса""}" + Символы.ПС +
		"   Возвращает сохраненные данные, которые можно использовать в последующих шагах сценария" + Символы.ПС +
		"   Пример использования: загрузи данные из хранилища, затем обработай их в цикле" + Символы.ПС +
		"   {""action"": ""LoadFromStorage"", ""key"": ""список_контрагентов""}" + Символы.ПС +
		"   {""action"": ""ShowInfo"", ""message"": ""Загружено контрагентов: {количество}""}" + Символы.ПС +
		Символы.ПС +
		"ClearStorage - очищает хранилище (опциональный параметр: key)" + Символы.ПС +
		"   Если key указан - удаляет только данные с этим ключом" + Символы.ПС +
		"   Если key не указан - очищает все хранилище" + Символы.ПС +
		"   Пример удаления конкретного ключа: {""action"": ""ClearStorage"", ""key"": ""временные_данные""}" + Символы.ПС +
		"   Пример полной очистки: {""action"": ""ClearStorage""}" + Символы.ПС +
		Символы.ПС +
		"ListStorageKeys - получает список всех ключей в хранилище (не требует параметров)" + Символы.ПС +
		"   Пример: {""action"": ""ListStorageKeys""}" + Символы.ПС +
		"   Возвращает массив строк с ключами" + Символы.ПС +
		"   Полезно для проверки, какие данные уже сохранены в хранилище" + Символы.ПС +
		Символы.ПС +
		"Типичные сценарии использования хранилища:" + Символы.ПС +
		"1. Сохранение результатов запроса для последующей обработки:" + Символы.ПС +
		"   - Выполни RunQuery для получения списка объектов" + Символы.ПС +
		"   - Сохрани результат в хранилище с ключом (например, ""список_объектов"")" + Символы.ПС +
		"   - В следующем сценарии загрузи данные из хранилища" + Символы.ПС +
		"   - Обработай каждый объект из загруженного списка" + Символы.ПС +
		"2. Передача данных между несколькими DSL-сценариями:" + Символы.ПС +
		"   - Первый сценарий: выполни запрос, сохрани результат в хранилище" + Символы.ПС +
		"   - Второй сценарий: загрузи данные из хранилища, используй их для дальнейшей работы" + Символы.ПС +
		"3. Сохранение промежуточных вычислений:" + Символы.ПС +
		"   - Вычисли значение, сохрани в хранилище" + Символы.ПС +
		"   - Используй сохраненное значение в последующих шагах" + Символы.ПС +
		"4. Кэширование данных запросов:" + Символы.ПС +
		"   - Если запрос выполняется долго, сохрани результат в хранилище" + Символы.ПС +
		"   - При повторной необходимости используй сохраненные данные" + Символы.ПС +
		Символы.ПС +
		"ВАЖНО:" + Символы.ПС +
		"- Используй понятные и уникальные ключи для сохранения данных" + Символы.ПС +
		"- Хранилище доступно только в рамках одного диалога (сессии)" + Символы.ПС +
		"- При сохранении результата RunQuery, сохраняй массив структур (результат запроса)" + Символы.ПС +
		"- Данные в хранилище сохраняются между выполнением разных DSL-сценариев в рамках одного диалога" + Символы.ПС +
		"- Используй ListStorageKeys для проверки наличия данных перед их использованием" + Символы.ПС +
		"- НЕ сохраняй ссылки на объекты базы данных - сохраняй УИД в виде строки, затем используй FindReferenceByGUID" + Символы.ПС +
		"- Данные в хранилище сериализуются, поэтому сохраняй только сериализуемые объекты" + Символы.ПС +
		"- При загрузке данных из хранилища используй LoadFromStorage, затем обрабатывай полученные данные";
	СистемноеСообщение.Вставить("content", СистемныйПромпт);
	Сообщения.Добавить(СистемноеСообщение);
	
	// Добавляем историю диалога (системные сообщения из истории передаем как часть контекста в сообщениях пользователя)
	Для Каждого СтрокаИстории Из История Цикл
		
		Сообщение = Новый Структура;
		
		Если СтрокаИстории.Автор = Перечисления.ИИА_АвторСообщения.Пользователь Тогда
			Сообщение.Вставить("role", "user");
			ТекстСообщения = СтрокаИстории.Текст;
			Если НЕ ПустаяСтрока(СтрокаИстории.ТекстКода) Тогда
				ТекстСообщения = ТекстСообщения + Символы.ПС + "```" + Символы.ПС + СтрокаИстории.ТекстКода + Символы.ПС + "```";
			КонецЕсли;
			Сообщение.Вставить("content", ТекстСообщения);
			Сообщения.Добавить(Сообщение);
			
		ИначеЕсли СтрокаИстории.Автор = Перечисления.ИИА_АвторСообщения.ИИ Тогда
			Сообщение.Вставить("role", "assistant");
			ТекстСообщения = СтрокаИстории.Текст;
			Если НЕ ПустаяСтрока(СтрокаИстории.ТекстКода) Тогда
				ТекстСообщения = ТекстСообщения + Символы.ПС + "```" + Символы.ПС + СтрокаИстории.ТекстКода + Символы.ПС + "```";
			КонецЕсли;
			Сообщение.Вставить("content", ТекстСообщения);
			Сообщения.Добавить(Сообщение);
			
		ИначеЕсли СтрокаИстории.Автор = Перечисления.ИИА_АвторСообщения.Система Тогда
			// Системные сообщения из истории (результаты выполнения DSL) передаем как часть следующего сообщения пользователя
			// Это позволяет ИИ видеть результаты выполнения DSL-сценариев, но не нарушает требование API о единственном системном сообщении
			// Добавляем системное сообщение как контекст к следующему сообщению пользователя
			Если Сообщения.Количество() > 0 И Сообщения[Сообщения.Количество() - 1].role = "user" Тогда
				// Если последнее сообщение от пользователя, добавляем системную информацию к нему
				ПоследнееСообщение = Сообщения[Сообщения.Количество() - 1];
				ТекущийТекст = ПоследнееСообщение.content;
				ТекстСистемногоСообщения = "[Система] " + СтрокаИстории.Текст;
				ПоследнееСообщение.Вставить("content", ТекущийТекст + Символы.ПС + Символы.ПС + ТекстСистемногоСообщения);
			Иначе
				// Если нет предыдущего сообщения пользователя, создаем отдельное сообщение пользователя с системной информацией
				Сообщение.Вставить("role", "user");
				ТекстСистемногоСообщения = "[Система] " + СтрокаИстории.Текст;
				Сообщение.Вставить("content", ТекстСистемногоСообщения);
				Сообщения.Добавить(Сообщение);
			КонецЕсли;
			
		Иначе
			// Пропускаем неизвестные типы авторов
			Продолжить;
		КонецЕсли;
		
	КонецЦикла;
	
	// Добавляем текущее сообщение пользователя
	ТекущееСообщение = Новый Структура;
	ТекущееСообщение.Вставить("role", "user");
	ТекущееСообщение.Вставить("content", ТекстПользователя);
	Сообщения.Добавить(ТекущееСообщение);
	
	Результат.Вставить("Сообщения", Сообщения);
	
	Возврат Результат;
	
КонецФункции

// Извлекает DSL JSON из текста
//
// Параметры:
//  Текст - Строка - текст, из которого нужно извлечь JSON
//
// Возвращаемое значение:
//  Строка - извлеченный JSON или пустая строка, если не найден
//
Функция ИзвлечьDSLИзТекста(Текст) Экспорт
	
	Если ПустаяСтрока(Текст) Тогда
		Возврат "";
	КонецЕсли;
	
	ТекстДляПарсинга = СокрЛП(Текст);
	
	// Ищем JSON в markdown блоках (```json ... ``` или ``` ... ```)
	НачалоБлока = СтрНайти(ТекстДляПарсинга, "```");
	Если НачалоБлока > 0 Тогда
		// Найден markdown блок, извлекаем содержимое
		НачалоСодержимого = НачалоБлока + 3;
		// Ищем закрывающий блок
		КонецБлока = СтрНайти(ТекстДляПарсинга, "```", , НачалоСодержимого);
		Если КонецБлока > 0 Тогда
			СодержимоеБлока = Сред(ТекстДляПарсинга, НачалоСодержимого, КонецБлока - НачалоСодержимого);
			СодержимоеБлока = СокрЛП(СодержимоеБлока);
			// Убираем "json" если есть в начале
			Если Лев(СодержимоеБлока, 4) = "json" Тогда
				СодержимоеБлока = СокрЛП(Сред(СодержимоеБлока, 5));
			КонецЕсли;
			ТекстДляПарсинга = СодержимоеБлока;
		КонецЕсли;
	КонецЕсли;
	
	// Сначала проверяем, начинается ли текст с "{"
	Если Лев(ТекстДляПарсинга, 1) = "{" Тогда
		
		Попытка
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ТекстДляПарсинга);
			ПроверкаJSON = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			
			// Проверяем, что это DSL-сценарий
			Если ПроверкаJSON.Свойство("dsl_version") И ПроверкаJSON.Свойство("steps") Тогда
				Возврат ТекстДляПарсинга;
			ИначеЕсли ТипЗнч(ПроверкаJSON) = Тип("Структура") И ПроверкаJSON.Свойство("action") Тогда
				// Это объект действия - оборачиваем в DSL-сценарий
				DSLСценарий = Новый Структура;
				DSLСценарий.Вставить("dsl_version", 1);
				Шаги = Новый Массив;
				Шаги.Добавить(ПроверкаJSON);
				DSLСценарий.Вставить("steps", Шаги);
				
				// Преобразуем обратно в JSON
				ЗаписьJSON = Новый ЗаписьJSON;
				ЗаписьJSON.УстановитьСтроку();
				ЗаписатьJSON(ЗаписьJSON, DSLСценарий);
				Возврат ЗаписьJSON.Закрыть();
			КонецЕсли;
			
		Исключение
			// Не JSON или не DSL - продолжаем поиск
		КонецПопытки;
		
	КонецЕсли;
	
	// Если текст не начинается с "{", ищем JSON внутри текста
	НачалоОткрывающейСкобки = СтрНайти(Текст, "{");
	Если НачалоОткрывающейСкобки > 0 Тогда
		
		// Ищем закрывающую скобку с балансом скобок
		ГлубинаВложенности = 0;
		КонецЗакрывающейСкобки = 0;
		Для Индекс = НачалоОткрывающейСкобки По СтрДлина(Текст) Цикл
			Символ = Сред(Текст, Индекс, 1);
			Если Символ = "{" Тогда
				ГлубинаВложенности = ГлубинаВложенности + 1;
			ИначеЕсли Символ = "}" Тогда
				ГлубинаВложенности = ГлубинаВложенности - 1;
				Если ГлубинаВложенности = 0 Тогда
					КонецЗакрывающейСкобки = Индекс;
					Прервать;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		Если КонецЗакрывающейСкобки > 0 И КонецЗакрывающейСкобки > НачалоОткрывающейСкобки Тогда
			
			ВозможныйJSON = Сред(Текст, НачалоОткрывающейСкобки, КонецЗакрывающейСкобки - НачалоОткрывающейСкобки + 1);
			
			Попытка
				ЧтениеJSON = Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(ВозможныйJSON);
				ПроверкаJSON = ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				
				// Проверяем, что это DSL-сценарий
				Если ПроверкаJSON.Свойство("dsl_version") И ПроверкаJSON.Свойство("steps") Тогда
					Возврат ВозможныйJSON;
				ИначеЕсли ТипЗнч(ПроверкаJSON) = Тип("Структура") И ПроверкаJSON.Свойство("action") Тогда
					// Это объект действия - оборачиваем в DSL-сценарий
					DSLСценарий = Новый Структура;
					DSLСценарий.Вставить("dsl_version", 1);
					Шаги = Новый Массив;
					Шаги.Добавить(ПроверкаJSON);
					DSLСценарий.Вставить("steps", Шаги);
					
					// Преобразуем обратно в JSON
					ЗаписьJSON = Новый ЗаписьJSON;
					ЗаписьJSON.УстановитьСтроку();
					ЗаписатьJSON(ЗаписьJSON, DSLСценарий);
					Возврат ЗаписьJSON.Закрыть();
				КонецЕсли;
				
			Исключение
				// Не JSON или не DSL - пробуем найти другой JSON блок
			КонецПопытки;
			
		КонецЕсли;
		
		// Если не нашли по балансу, пробуем найти последнюю закрывающую скобку
		Если КонецЗакрывающейСкобки = 0 Тогда
			КонецЗакрывающейСкобки = СтрНайти(Текст, "}", НаправлениеПоиска.СКонца);
			Если КонецЗакрывающейСкобки > 0 И КонецЗакрывающейСкобки > НачалоОткрывающейСкобки Тогда
				
				ВозможныйJSON = Сред(Текст, НачалоОткрывающейСкобки, КонецЗакрывающейСкобки - НачалоОткрывающейСкобки + 1);
				
				Попытка
					ЧтениеJSON = Новый ЧтениеJSON;
					ЧтениеJSON.УстановитьСтроку(ВозможныйJSON);
					ПроверкаJSON = ПрочитатьJSON(ЧтениеJSON);
					ЧтениеJSON.Закрыть();
					
					// Проверяем, что это DSL-сценарий
					Если ПроверкаJSON.Свойство("dsl_version") И ПроверкаJSON.Свойство("steps") Тогда
						Возврат ВозможныйJSON;
					КонецЕсли;
					
				Исключение
					// Не JSON или не DSL
				КонецПопытки;
				
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

// Распознает ответ ИИ и определяет его тип
//
// Параметры:
//  ТекстОтветаИИ - Строка - текст ответа от ИИ
//  ТипСообщения - Строка - тип исходного сообщения
//
// Возвращаемое значение:
//  Структура - структура результата с распознанным типом и данными
//
Функция РаспознатьОтветИИ(ТекстОтветаИИ, ТипСообщения) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", ТекстОтветаИИ);
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	
	// Пытаемся найти JSON в ответе (DSL-сценарий)
	ИзвлеченныйDSL = ИзвлечьDSLИзТекста(ТекстОтветаИИ);
	
	Если НЕ ПустаяСтрока(ИзвлеченныйDSL) Тогда
		
		// Проверяем, является ли извлеченный JSON полным DSL-сценарием или просто объектом действия
		Попытка
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ИзвлеченныйDSL);
			JSONОбъект = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			
			// Если это структура с полем "action", но без "dsl_version" и "steps", оборачиваем в DSL-сценарий
			Если ТипЗнч(JSONОбъект) = Тип("Структура") 
				И JSONОбъект.Свойство("action") 
				И НЕ JSONОбъект.Свойство("dsl_version") 
				И НЕ JSONОбъект.Свойство("steps") Тогда
				
				// Оборачиваем в формат DSL-сценария
				DSLСценарий = Новый Структура;
				DSLСценарий.Вставить("dsl_version", 1);
				Шаги = Новый Массив;
				Шаги.Добавить(JSONОбъект);
				DSLСценарий.Вставить("steps", Шаги);
				
				// Преобразуем обратно в JSON
				ЗаписьJSON = Новый ЗаписьJSON;
				ЗаписьJSON.УстановитьСтроку();
				ЗаписатьJSON(ЗаписьJSON, DSLСценарий);
				ИзвлеченныйDSL = ЗаписьJSON.Закрыть();
				
			КонецЕсли;
			
		Исключение
			// Игнорируем ошибки парсинга, используем извлеченный DSL как есть
		КонецПопытки;
		
		Результат.ТипОтвета = "DSL";
		Результат.DSL = ИзвлеченныйDSL;
		Результат.ВыполнитьDSL = Истина; // Выполняем DSL-сценарий автоматически
		
		// Извлекаем текст перед JSON (если есть)
		НачалоОткрывающейСкобки = СтрНайти(ТекстОтветаИИ, "{");
		Если НачалоОткрывающейСкобки > 1 Тогда
			ТекстПередJSON = СокрЛП(Лев(ТекстОтветаИИ, НачалоОткрывающейСкобки - 1));
			Если НЕ ПустаяСтрока(ТекстПередJSON) Тогда
				Результат.Текст = ТекстПередJSON;
			Иначе
				Результат.Текст = "Сгенерирован DSL-сценарий:";
			КонецЕсли;
		Иначе
			Результат.Текст = "Сгенерирован DSL-сценарий:";
		КонецЕсли;
		
		Возврат Результат;
		
	КонецЕсли;
	
	// Если тип сообщения "Запрос", пытаемся найти запрос в ответе
	Если ТипСообщения = "Запрос" Тогда
		
		// Ищем блок кода с запросом
		НачалоБлока = СтрНайти(ТекстОтветаИИ, "```");
		Если НачалоБлока > 0 Тогда
			
			// Ищем вторую тройку обратных кавычек после первой, начиная с позиции после первой
			КонецБлока = СтрНайти(ТекстОтветаИИ, "```", , НачалоБлока + 3);
			Если КонецБлока > 0 Тогда
				
				ТекстЗапроса = Сред(ТекстОтветаИИ, НачалоБлока + 3, КонецБлока - НачалоБлока - 3);
				ТекстЗапроса = СокрЛП(ТекстЗапроса);
				
				// Проверяем, что это похоже на запрос 1С
				Если СтрНайти(ВРег(ТекстЗапроса), "ВЫБРАТЬ") > 0 Тогда
					
					Результат.ТипОтвета = "Запрос";
					Результат.Запрос = ТекстЗапроса;
					Результат.Текст = "Сгенерирован запрос:";
					
					Возврат Результат;
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// По умолчанию возвращаем как текст
	Возврат Результат;
	
КонецФункции


#КонецОбласти
