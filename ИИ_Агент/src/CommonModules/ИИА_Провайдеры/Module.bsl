#Область ПрограммныйИнтерфейс

// Вызывает ИИ для получения ответа
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  Настройки - Структура - настройки пользователя
//
// Возвращаемое значение:
//  Структура - структура ответа:
//   * ТипОтвета - Строка ("Текст", "Запрос" или "DSL")
//   * Текст - Строка - текст ответа
//   * Запрос - Строка - текст запроса (для типа "Запрос")
//   * DSL - Строка - JSON с DSL-сценарием (для типа "DSL")
//   * ВыполнитьDSL - Булево - выполнить ли DSL сразу (для типа "DSL")
//   * Usage - Структура - информация об использовании токенов
//   * Ошибки - ОписаниеОшибки - информация об ошибках
//
Функция ВызватьИИ(ТипСообщения, ТекстПользователя, История, Настройки) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", "");
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	Результат.Вставить("Usage", Неопределено);
	Результат.Вставить("Ошибки", Неопределено);
	
	// Проверяем настройки подключения
	Если ПустаяСтрока(Настройки.Provider_ApiKey) ИЛИ ПустаяСтрока(Настройки.Provider_BaseUrl) Тогда
		
		Результат.Текст = "Не настроен API ключ или URL провайдера. Настройте подключение к ИИ провайдеру.";
		Возврат Результат;
		
	КонецЕсли;
	
	// Определяем тип провайдера
	ТипПровайдера = "";
	Если Настройки.Свойство("Provider_Type") Тогда
		ТипПровайдера = Настройки.Provider_Type;
	КонецЕсли;
	
	// Если провайдер Гигачат, вызываем его API
	Если ВРег(ТипПровайдера) = "GIGACHAT" ИЛИ ВРег(ТипПровайдера) = "ГИГАЧАТ" ИЛИ ПустаяСтрока(ТипПровайдера) Тогда
		
		Результат = ИИА_Гигачат.ВызватьГигачат(ТипСообщения, ТекстПользователя, История, Настройки);
		
	Иначе
		
		// Для других провайдеров можно добавить аналогичную логику
		Результат.Текст = "Неподдерживаемый тип провайдера: " + ТипПровайдера;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Получает метаданные конфигурации для передачи в ИИ
//
// Возвращаемое значение:
//  Структура - структура с метаданными
//
Функция ПолучитьМетаданныеДляИИ() Экспорт
	
	Результат = Новый Структура;
	
	// Получаем списки объектов
	Результат.Вставить("Справочники", ИИА_Метаданные.ПолучитьСписокСправочников());
	Результат.Вставить("Документы", ИИА_Метаданные.ПолучитьСписокДокументов());
	Результат.Вставить("РегистрыСведений", ИИА_Метаданные.ПолучитьСписокРегистровСведений());
	Результат.Вставить("РегистрыНакопления", ИИА_Метаданные.ПолучитьСписокРегистровНакопления());
	Результат.Вставить("РегистрыБухгалтерии", ИИА_Метаданные.ПолучитьСписокРегистровБухгалтерии());
	
	Возврат Результат;
	
КонецФункции

// Формирует промпт для ИИ с учетом контекста
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  МетаданныеКонтекст - Структура - метаданные конфигурации
//
// Возвращаемое значение:
//  Структура - структура с сообщениями для ИИ
//
Функция СформироватьПромптДляИИ(ТипСообщения, ТекстПользователя, История, МетаданныеКонтекст) Экспорт
	
	Результат = Новый Структура;
	Сообщения = Новый Массив;
	
	// Системный промпт
	СистемноеСообщение = Новый Структура;
	СистемноеСообщение.Вставить("role", "system");
	
	СистемныйПромпт = "Ты - ИИ-ассистент для работы с системой 1С:Предприятие. " + Символы.ПС +
		"Твоя задача - понимать команды пользователя и генерировать безопасные DSL-сценарии или запросы на языке запросов 1С." + Символы.ПС +
		Символы.ПС +
		"Доступные объекты конфигурации:" + Символы.ПС;
	
	// Добавляем информацию о справочниках
	Если МетаданныеКонтекст.Свойство("Справочники") Тогда
		СистемныйПромпт = СистемныйПромпт + "Справочники: ";
		Для Каждого Справочник Из МетаданныеКонтекст.Справочники Цикл
			СистемныйПромпт = СистемныйПромпт + Справочник.Имя + " (" + Справочник.Синоним + "), ";
		КонецЦикла;
		СистемныйПромпт = Лев(СистемныйПромпт, СтрДлина(СистемныйПромпт) - 2) + Символы.ПС;
	КонецЕсли;
	
	// Добавляем информацию о документах
	Если МетаданныеКонтекст.Свойство("Документы") Тогда
		СистемныйПромпт = СистемныйПромпт + "Документы: ";
		Для Каждого Документ Из МетаданныеКонтекст.Документы Цикл
			СистемныйПромпт = СистемныйПромпт + Документ.Имя + " (" + Документ.Синоним + "), ";
		КонецЦикла;
		СистемныйПромпт = Лев(СистемныйПромпт, СтрДлина(СистемныйПромпт) - 2) + Символы.ПС;
	КонецЕсли;
	
	СистемныйПромпт = СистемныйПромпт + Символы.ПС +
		"Формат DSL-сценария:" + Символы.ПС +
		"{""dsl_version"": 1, ""steps"": [{""action"": ""CreateReference"", ""object_name"": ""ИмяСправочника""}, ...]}" + Символы.ПС +
		"Доступные действия: CreateReference, CreateDocument, FindReferenceByName, SetField, Write, RunQuery, ShowInfo, GetChangedObjects" + Символы.ПС +
		"GetChangedObjects - получает все ссылки на объекты из табличной части 'ИзмененныеОбъекты' диалога (не требует параметров)" + Символы.ПС +
		Символы.ПС +
		"Если пользователь просит создать или найти объект, генерируй DSL-сценарий в формате JSON." + Символы.ПС +
		"Если пользователь просит выполнить запрос, генерируй запрос на языке запросов 1С." + Символы.ПС +
		Символы.ПС +
		"Важно о хранении объектов:" + Символы.ПС +
		"- Все ссылки на созданные или измененные объекты автоматически сохраняются в табличной части 'ИзмененныеОбъекты' диалога." + Символы.ПС +
		"- Эти ссылки можно использовать для последующего редактирования объектов, анализа результатов работы и выполнения дополнительных операций с ними." + Символы.ПС +
		"- Для получения всех объектов из табличной части используй действие GetChangedObjects (не требует параметров)." + Символы.ПС +
		"- После выполнения DSL-сценария для проверки результата используй GetChangedObjects, чтобы получить все созданные/измененные объекты, затем проверь их реквизиты." + Символы.ПС +
		"- При необходимости работы с ранее созданными объектами, используй информацию из истории диалога, где указаны ссылки на эти объекты.";
	СистемноеСообщение.Вставить("content", СистемныйПромпт);
	Сообщения.Добавить(СистемноеСообщение);
	
	// Добавляем историю диалога (системные сообщения из истории передаем как часть контекста в сообщениях пользователя)
	Для Каждого СтрокаИстории Из История Цикл
		
		Сообщение = Новый Структура;
		
		Если СтрокаИстории.Автор = Перечисления.ИИА_АвторСообщения.Пользователь Тогда
			Сообщение.Вставить("role", "user");
			ТекстСообщения = СтрокаИстории.Текст;
			Если НЕ ПустаяСтрока(СтрокаИстории.ТекстКода) Тогда
				ТекстСообщения = ТекстСообщения + Символы.ПС + "```" + Символы.ПС + СтрокаИстории.ТекстКода + Символы.ПС + "```";
			КонецЕсли;
			Сообщение.Вставить("content", ТекстСообщения);
			Сообщения.Добавить(Сообщение);
			
		ИначеЕсли СтрокаИстории.Автор = Перечисления.ИИА_АвторСообщения.ИИ Тогда
			Сообщение.Вставить("role", "assistant");
			ТекстСообщения = СтрокаИстории.Текст;
			Если НЕ ПустаяСтрока(СтрокаИстории.ТекстКода) Тогда
				ТекстСообщения = ТекстСообщения + Символы.ПС + "```" + Символы.ПС + СтрокаИстории.ТекстКода + Символы.ПС + "```";
			КонецЕсли;
			Сообщение.Вставить("content", ТекстСообщения);
			Сообщения.Добавить(Сообщение);
			
		ИначеЕсли СтрокаИстории.Автор = Перечисления.ИИА_АвторСообщения.Система Тогда
			// Системные сообщения из истории (результаты выполнения DSL) передаем как часть следующего сообщения пользователя
			// Это позволяет ИИ видеть результаты выполнения DSL-сценариев, но не нарушает требование API о единственном системном сообщении
			// Добавляем системное сообщение как контекст к следующему сообщению пользователя
			Если Сообщения.Количество() > 0 И Сообщения[Сообщения.Количество() - 1].role = "user" Тогда
				// Если последнее сообщение от пользователя, добавляем системную информацию к нему
				ПоследнееСообщение = Сообщения[Сообщения.Количество() - 1];
				ТекущийТекст = ПоследнееСообщение.content;
				ТекстСистемногоСообщения = "[Система] " + СтрокаИстории.Текст;
				ПоследнееСообщение.Вставить("content", ТекущийТекст + Символы.ПС + Символы.ПС + ТекстСистемногоСообщения);
			Иначе
				// Если нет предыдущего сообщения пользователя, создаем отдельное сообщение пользователя с системной информацией
				Сообщение.Вставить("role", "user");
				ТекстСистемногоСообщения = "[Система] " + СтрокаИстории.Текст;
				Сообщение.Вставить("content", ТекстСистемногоСообщения);
				Сообщения.Добавить(Сообщение);
			КонецЕсли;
			
		Иначе
			// Пропускаем неизвестные типы авторов
			Продолжить;
		КонецЕсли;
		
	КонецЦикла;
	
	// Добавляем текущее сообщение пользователя
	ТекущееСообщение = Новый Структура;
	ТекущееСообщение.Вставить("role", "user");
	ТекущееСообщение.Вставить("content", ТекстПользователя);
	Сообщения.Добавить(ТекущееСообщение);
	
	Результат.Вставить("Сообщения", Сообщения);
	
	Возврат Результат;
	
КонецФункции

// Извлекает DSL JSON из текста
//
// Параметры:
//  Текст - Строка - текст, из которого нужно извлечь JSON
//
// Возвращаемое значение:
//  Строка - извлеченный JSON или пустая строка, если не найден
//
Функция ИзвлечьDSLИзТекста(Текст) Экспорт
	
	Если ПустаяСтрока(Текст) Тогда
		Возврат "";
	КонецЕсли;
	
	ТекстДляПарсинга = СокрЛП(Текст);
	
	// Ищем JSON в markdown блоках (```json ... ``` или ``` ... ```)
	НачалоБлока = СтрНайти(ТекстДляПарсинга, "```");
	Если НачалоБлока > 0 Тогда
		// Найден markdown блок, извлекаем содержимое
		НачалоСодержимого = НачалоБлока + 3;
		// Ищем закрывающий блок
		КонецБлока = СтрНайти(ТекстДляПарсинга, "```", , НачалоСодержимого);
		Если КонецБлока > 0 Тогда
			СодержимоеБлока = Сред(ТекстДляПарсинга, НачалоСодержимого, КонецБлока - НачалоСодержимого);
			СодержимоеБлока = СокрЛП(СодержимоеБлока);
			// Убираем "json" если есть в начале
			Если Лев(СодержимоеБлока, 4) = "json" Тогда
				СодержимоеБлока = СокрЛП(Сред(СодержимоеБлока, 5));
			КонецЕсли;
			ТекстДляПарсинга = СодержимоеБлока;
		КонецЕсли;
	КонецЕсли;
	
	// Сначала проверяем, начинается ли текст с "{"
	Если Лев(ТекстДляПарсинга, 1) = "{" Тогда
		
		Попытка
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ТекстДляПарсинга);
			ПроверкаJSON = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			
			// Проверяем, что это DSL-сценарий
			Если ПроверкаJSON.Свойство("dsl_version") И ПроверкаJSON.Свойство("steps") Тогда
				Возврат ТекстДляПарсинга;
			КонецЕсли;
			
		Исключение
			// Не JSON или не DSL - продолжаем поиск
		КонецПопытки;
		
	КонецЕсли;
	
	// Если текст не начинается с "{", ищем JSON внутри текста
	НачалоОткрывающейСкобки = СтрНайти(Текст, "{");
	Если НачалоОткрывающейСкобки > 0 Тогда
		
		// Ищем закрывающую скобку с конца
		КонецЗакрывающейСкобки = СтрНайти(Текст, "}", НаправлениеПоиска.СКонца);
		Если КонецЗакрывающейСкобки > 0 И КонецЗакрывающейСкобки > НачалоОткрывающейСкобки Тогда
			
			ВозможныйJSON = Сред(Текст, НачалоОткрывающейСкобки, КонецЗакрывающейСкобки - НачалоОткрывающейСкобки + 1);
			
			Попытка
				ЧтениеJSON = Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(ВозможныйJSON);
				ПроверкаJSON = ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				
				// Проверяем, что это DSL-сценарий
				Если ПроверкаJSON.Свойство("dsl_version") И ПроверкаJSON.Свойство("steps") Тогда
					Возврат ВозможныйJSON;
				КонецЕсли;
				
			Исключение
				// Не JSON или не DSL
			КонецПопытки;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

// Распознает ответ ИИ и определяет его тип
//
// Параметры:
//  ТекстОтветаИИ - Строка - текст ответа от ИИ
//  ТипСообщения - Строка - тип исходного сообщения
//
// Возвращаемое значение:
//  Структура - структура результата с распознанным типом и данными
//
Функция РаспознатьОтветИИ(ТекстОтветаИИ, ТипСообщения) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", ТекстОтветаИИ);
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	
	// Пытаемся найти JSON в ответе (DSL-сценарий)
	ИзвлеченныйDSL = ИзвлечьDSLИзТекста(ТекстОтветаИИ);
	
	Если НЕ ПустаяСтрока(ИзвлеченныйDSL) Тогда
		
		Результат.ТипОтвета = "DSL";
		Результат.DSL = ИзвлеченныйDSL;
		Результат.ВыполнитьDSL = Истина; // Выполняем DSL-сценарий автоматически
		
		// Извлекаем текст перед JSON (если есть)
		НачалоОткрывающейСкобки = СтрНайти(ТекстОтветаИИ, "{");
		Если НачалоОткрывающейСкобки > 1 Тогда
			ТекстПередJSON = СокрЛП(Лев(ТекстОтветаИИ, НачалоОткрывающейСкобки - 1));
			Если НЕ ПустаяСтрока(ТекстПередJSON) Тогда
				Результат.Текст = ТекстПередJSON;
			Иначе
				Результат.Текст = "Сгенерирован DSL-сценарий:";
			КонецЕсли;
		Иначе
			Результат.Текст = "Сгенерирован DSL-сценарий:";
		КонецЕсли;
		
		Возврат Результат;
		
	КонецЕсли;
	
	// Если тип сообщения "Запрос", пытаемся найти запрос в ответе
	Если ТипСообщения = "Запрос" Тогда
		
		// Ищем блок кода с запросом
		НачалоБлока = СтрНайти(ТекстОтветаИИ, "```");
		Если НачалоБлока > 0 Тогда
			
			// Ищем вторую тройку обратных кавычек после первой, начиная с позиции после первой
			КонецБлока = СтрНайти(ТекстОтветаИИ, "```", , НачалоБлока + 3);
			Если КонецБлока > 0 Тогда
				
				ТекстЗапроса = Сред(ТекстОтветаИИ, НачалоБлока + 3, КонецБлока - НачалоБлока - 3);
				ТекстЗапроса = СокрЛП(ТекстЗапроса);
				
				// Проверяем, что это похоже на запрос 1С
				Если СтрНайти(ВРег(ТекстЗапроса), "ВЫБРАТЬ") > 0 Тогда
					
					Результат.ТипОтвета = "Запрос";
					Результат.Запрос = ТекстЗапроса;
					Результат.Текст = "Сгенерирован запрос:";
					
					Возврат Результат;
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// По умолчанию возвращаем как текст
	Возврат Результат;
	
КонецФункции


#КонецОбласти
