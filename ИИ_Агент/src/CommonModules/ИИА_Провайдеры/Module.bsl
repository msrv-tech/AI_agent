#Область ПрограммныйИнтерфейс

// Вызывает ИИ для получения ответа
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  Настройки - Структура - настройки пользователя
//
// Возвращаемое значение:
//  Структура - структура ответа:
//   * ТипОтвета - Строка ("Текст", "Запрос" или "DSL")
//   * Текст - Строка - текст ответа
//   * Запрос - Строка - текст запроса (для типа "Запрос")
//   * DSL - Строка - JSON с DSL-сценарием (для типа "DSL")
//   * ВыполнитьDSL - Булево - выполнить ли DSL сразу (для типа "DSL")
//   * Usage - Структура - информация об использовании токенов
//   * Ошибки - ОписаниеОшибки - информация об ошибках
//
Функция ВызватьИИ(ТипСообщения, ТекстПользователя, История, Настройки) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", "");
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	Результат.Вставить("Usage", Неопределено);
	Результат.Вставить("Ошибки", Неопределено);
	
	// Проверяем настройки подключения
	Если ПустаяСтрока(Настройки.Provider_ApiKey) ИЛИ ПустаяСтрока(Настройки.Provider_BaseUrl) Тогда
		
		Результат.Текст = "Не настроен API ключ или URL провайдера. Настройте подключение к ИИ провайдеру.";
		Возврат Результат;
		
	КонецЕсли;
	
	// Определяем тип провайдера
	ТипПровайдера = "";
	Если Настройки.Свойство("Provider_Type") Тогда
		ТипПровайдера = Настройки.Provider_Type;
	КонецЕсли;
	
	// Если провайдер Гигачат, вызываем его API
	Если ВРег(ТипПровайдера) = "GIGACHAT" ИЛИ ВРег(ТипПровайдера) = "ГИГАЧАТ" ИЛИ ПустаяСтрока(ТипПровайдера) Тогда
		
		Результат = ИИА_Гигачат.ВызватьГигачат(ТипСообщения, ТекстПользователя, История, Настройки);
		
	Иначе
		
		// Для других провайдеров можно добавить аналогичную логику
		Результат.Текст = "Неподдерживаемый тип провайдера: " + ТипПровайдера;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Формирует промпт для ИИ с учетом контекста
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//
// Возвращаемое значение:
//  Структура - структура с сообщениями для ИИ
//
Функция СформироватьПромптДляИИ(ТипСообщения, ТекстПользователя, История) Экспорт
	
	// Функция перенесена в общий модуль ИИА_Промты
	// Оставлена для совместимости
	// Используем Агент как тип по умолчанию
	Возврат ИИА_Промты.СформироватьПромпт(Перечисления.ИИА_ТипДиалога.Агент, ТипСообщения, ТекстПользователя, История);
	
КонецФункции

// Извлекает DSL JSON из текста
//
// Параметры:
//  Текст - Строка - текст, из которого нужно извлечь JSON
//
// Возвращаемое значение:
//  Строка - извлеченный JSON или пустая строка, если не найден
//
Функция ИзвлечьDSLИзТекста(Текст) Экспорт
	
	Результат = "";
	
	// 1. Попытка найти блок кода JSON (```json ... ```)
	НачалоБлока = СтрНайти(Текст, "```json");
	Если НачалоБлока > 0 Тогда
		НачалоJSON = НачалоБлока + 7; // Длина "```json"
		
		// Ищем закрывающий блок, начиная с позиции после открывающего
		// Используем Сред для получения остатка строки и ищем в нем
		ОстатокТекста = Сред(Текст, НачалоJSON);
		КонецБлокаОтносительный = СтрНайти(ОстатокТекста, "```");
		
		Если КонецБлокаОтносительный = 0 Тогда
             // Если закрывающего блока нет, ищем до конца
             Результат = Сред(Текст, НачалоJSON);
        Иначе
             // Берем содержимое до закрывающего блока
             Результат = Лев(ОстатокТекста, КонецБлокаОтносительный - 1);
        КонецЕсли;
        
	Иначе
		// 2. Попытка найти просто блок кода (``` ... ```) и проверить, является ли он JSON
		НачалоБлока = СтрНайти(Текст, "```");
		Если НачалоБлока > 0 Тогда
			НачалоJSON = НачалоБлока + 3;
			
			ОстатокТекста = Сред(Текст, НачалоJSON);
			КонецБлокаОтносительный = СтрНайти(ОстатокТекста, "```");
			
			Если КонецБлокаОтносительный > 0 Тогда
				ПотенциальныйJSON = СокрЛП(Лев(ОстатокТекста, КонецБлокаОтносительный - 1));
				Если СтрНачинаетсяС(ПотенциальныйJSON, "{") Тогда
					Результат = ПотенциальныйJSON;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	// 3. Если не найдено в блоках, ищем просто JSON-объект в тексте (от первой { до последней })
	Если ПустаяСтрока(Результат) Тогда
		НачалоJSON = СтрНайти(Текст, "{");
		Если НачалоJSON > 0 Тогда
			
			// Ищем последнюю закрывающую скобку
			// Простой поиск с конца не работает корректно, если после JSON есть текст
			// Попробуем балансировку скобок
			
			СчетчикСкобок = 0;
			ВКавычках = Ложь;
			Для Позиция = НачалоJSON По СтрДлина(Текст) Цикл
				Символ = Сред(Текст, Позиция, 1);
				
				// Обработка кавычек для игнорирования скобок внутри строк
				Если Символ = """" Тогда
					// Проверяем, не экранирована ли кавычка (очень упрощенно)
					Если Позиция > 1 И Сред(Текст, Позиция - 1, 1) <> "\" Тогда
						ВКавычках = НЕ ВКавычках;
					КонецЕсли;
				КонецЕсли;
				
				Если НЕ ВКавычках Тогда
					Если Символ = "{" Тогда
						СчетчикСкобок = СчетчикСкобок + 1;
					ИначеЕсли Символ = "}" Тогда
						СчетчикСкобок = СчетчикСкобок - 1;
						
						// Если скобки сбалансированы, это конец JSON
						Если СчетчикСкобок = 0 Тогда
							Результат = Сред(Текст, НачалоJSON, Позиция - НачалоJSON + 1);
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
	КонецЕсли;
	
	// 4. Очистка и предобработка JSON
	Если НЕ ПустаяСтрока(Результат) Тогда
		Результат = СокрЛП(Результат);
		
		// Удаление комментариев // (если они на отдельной строке)
		// ИИ иногда добавляет комментарии, которые ломают стандартный парсер JSON
		МассивСтрок = СтрРазделить(Результат, Символы.ПС);
		РезультатБезКомментариев = "";
		Для Каждого СтрокаТекста Из МассивСтрок Цикл
			Если СтрНачинаетсяС(СокрЛП(СтрокаТекста), "//") Тогда
				Продолжить;
			КонецЕсли;
			РезультатБезКомментариев = РезультатБезКомментариев + СтрокаТекста + Символы.ПС;
		КонецЦикла;
		Результат = РезультатБезКомментариев;
		
		// Исправление частых ошибок ИИ с булевыми значениями
		// Заменяем ": истина" на ": true", ": ложь" на ": false"
		// Учитываем возможные пробелы и переводы строк, а также отсутствие пробела
		
		// Используем простой подход с заменой подстрок, так как регулярки недоступны
		// Варианты для истина
		Результат = СтрЗаменить(Результат, ": истина", ": true");
		Результат = СтрЗаменить(Результат, ":истина", ": true");
		Результат = СтрЗаменить(Результат, ": ""истина""", ": true");
		Результат = СтрЗаменить(Результат, ":""истина""", ": true");
		
		// Варианты для ложь
		Результат = СтрЗаменить(Результат, ": ложь", ": false");
		Результат = СтрЗаменить(Результат, ":ложь", ": false");
		Результат = СтрЗаменить(Результат, ": ""ложь""", ": false");
		Результат = СтрЗаменить(Результат, ":""ложь""", ": false");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Распознает ответ ИИ и определяет его тип
//
// Параметры:
//  ТекстОтветаИИ - Строка - текст ответа от ИИ
//  ТипСообщения - Строка - тип исходного сообщения
//
// Возвращаемое значение:
//  Структура - структура результата с распознанным типом и данными
//
Функция РаспознатьОтветИИ(ТекстОтветаИИ, ТипСообщения) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", ТекстОтветаИИ);
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	
	// 1. Пытаемся извлечь DSL
	DSL_JSON = ИзвлечьDSLИзТекста(ТекстОтветаИИ);
	
	Если НЕ ПустаяСтрока(DSL_JSON) Тогда
		Результат.ТипОтвета = "DSL";
		Результат.DSL = DSL_JSON;
		Результат.ВыполнитьDSL = Истина;
		Возврат Результат;
	КонецЕсли;
	
	// 2. Если это был запрос 1С (старая логика, оставляем для совместимости)
	Если ТипСообщения = "Запрос" ИЛИ СтрНайти(ВРег(ТекстОтветаИИ), "ВЫБРАТЬ") > 0 Тогда
		// Упрощенная проверка на код 1С
		Если СтрНачинаетсяС(ТекстОтветаИИ, "```bsl") ИЛИ СтрНачинаетсяС(ТекстОтветаИИ, "```1c") Тогда
			Результат.ТипОтвета = "Запрос"; // Или код
			Результат.Запрос = ТекстОтветаИИ;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти
