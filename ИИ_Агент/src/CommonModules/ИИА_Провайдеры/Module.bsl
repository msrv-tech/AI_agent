#Область ПрограммныйИнтерфейс

// Вызывает ИИ для получения ответа
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения ("Чат" или "Запрос")
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  Настройки - Структура - настройки пользователя
//
// Возвращаемое значение:
//  Структура - структура ответа:
//   * ТипОтвета - Строка ("Текст", "Запрос" или "DSL")
//   * Текст - Строка - текст ответа
//   * Запрос - Строка - текст запроса (для типа "Запрос")
//   * DSL - Строка - JSON с DSL-сценарием (для типа "DSL")
//   * ВыполнитьDSL - Булево - выполнить ли DSL сразу (для типа "DSL")
//   * Usage - Структура - информация об использовании токенов
//   * Ошибки - ОписаниеОшибки - информация об ошибках
//
Функция ВызватьИИ(ТипСообщения, ТекстПользователя, История, Настройки) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", "");
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	Результат.Вставить("Usage", Неопределено);
	Результат.Вставить("Ошибки", Неопределено);
	
	// Проверяем настройки подключения
	Если ПустаяСтрока(Настройки.Provider_ApiKey) ИЛИ ПустаяСтрока(Настройки.Provider_BaseUrl) Тогда
		
		Результат.Текст = "Не настроен API ключ или URL провайдера. Настройте подключение к ИИ провайдеру.";
		Возврат Результат;
		
	КонецЕсли;
	
	// Определяем тип провайдера
	ТипПровайдера = "";
	Если Настройки.Свойство("Provider_Type") Тогда
		ТипПровайдера = Настройки.Provider_Type;
	КонецЕсли;
	
	// Если провайдер Гигачат, вызываем его API
	Если ВРег(ТипПровайдера) = "GIGACHAT" ИЛИ ВРег(ТипПровайдера) = "ГИГАЧАТ" ИЛИ ПустаяСтрока(ТипПровайдера) Тогда
		
		Результат = ИИА_Гигачат.ВызватьГигачат(ТипСообщения, ТекстПользователя, История, Настройки);
		
	Иначе
		
		// Для других провайдеров можно добавить аналогичную логику
		Результат.Текст = "Неподдерживаемый тип провайдера: " + ТипПровайдера;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Получает метаданные конфигурации для передачи в ИИ
//
// Возвращаемое значение:
//  Структура - структура с метаданными
//
Функция ПолучитьМетаданныеДляИИ() Экспорт
	
	Результат = Новый Структура;
	
	// Получаем списки объектов
	Результат.Вставить("Справочники", ИИА_Метаданные.ПолучитьСписокСправочников());
	Результат.Вставить("Документы", ИИА_Метаданные.ПолучитьСписокДокументов());
	Результат.Вставить("РегистрыСведений", ИИА_Метаданные.ПолучитьСписокРегистровСведений());
	Результат.Вставить("РегистрыНакопления", ИИА_Метаданные.ПолучитьСписокРегистровНакопления());
	Результат.Вставить("РегистрыБухгалтерии", ИИА_Метаданные.ПолучитьСписокРегистровБухгалтерии());
	
	Возврат Результат;
	
КонецФункции

// Формирует промпт для ИИ с учетом контекста
//
// Параметры:
//  ТипСообщения - Строка - тип сообщения
//  ТекстПользователя - Строка - текст от пользователя
//  История - ТаблицаЗначений - история сообщений
//  МетаданныеКонтекст - Структура - метаданные конфигурации
//
// Возвращаемое значение:
//  Структура - структура с сообщениями для ИИ
//
Функция СформироватьПромптДляИИ(ТипСообщения, ТекстПользователя, История, МетаданныеКонтекст) Экспорт
	
	Результат = Новый Структура;
	Сообщения = Новый Массив;
	
	// Системный промпт
	СистемноеСообщение = Новый Структура;
	СистемноеСообщение.Вставить("role", "system");
	
	СистемныйПромпт = "Ты - ИИ-ассистент для работы с системой 1С:Предприятие. " + Символы.ПС +
		"Твоя задача - понимать команды пользователя и генерировать безопасные DSL-сценарии или запросы на языке запросов 1С." + Символы.ПС +
		Символы.ПС +
		"Доступные объекты конфигурации:" + Символы.ПС;
	
	// Добавляем информацию о справочниках
	Если МетаданныеКонтекст.Свойство("Справочники") Тогда
		СистемныйПромпт = СистемныйПромпт + "Справочники: ";
		Для Каждого Справочник Из МетаданныеКонтекст.Справочники Цикл
			СистемныйПромпт = СистемныйПромпт + Справочник.Имя + " (" + Справочник.Синоним + "), ";
		КонецЦикла;
		СистемныйПромпт = Лев(СистемныйПромпт, СтрДлина(СистемныйПромпт) - 2) + Символы.ПС;
	КонецЕсли;
	
	// Добавляем информацию о документах
	Если МетаданныеКонтекст.Свойство("Документы") Тогда
		СистемныйПромпт = СистемныйПромпт + "Документы: ";
		Для Каждого Документ Из МетаданныеКонтекст.Документы Цикл
			СистемныйПромпт = СистемныйПромпт + Документ.Имя + " (" + Документ.Синоним + "), ";
		КонецЦикла;
		СистемныйПромпт = Лев(СистемныйПромпт, СтрДлина(СистемныйПромпт) - 2) + Символы.ПС;
	КонецЕсли;
	
	СистемныйПромпт = СистемныйПромпт + Символы.ПС +
		"Формат DSL-сценария:" + Символы.ПС +
		"{""dsl_version"": 1, ""steps"": [{""action"": ""CreateReference"", ""object_name"": ""ИмяСправочника""}, ...]}" + Символы.ПС +
		"Доступные действия: CreateReference, CreateDocument, FindReferenceByName, SetField, Write, RunQuery, ShowInfo" + Символы.ПС +
		Символы.ПС +
		"Если пользователь просит создать или найти объект, генерируй DSL-сценарий в формате JSON." + Символы.ПС +
		"Если пользователь просит выполнить запрос, генерируй запрос на языке запросов 1С.";
	СистемноеСообщение.Вставить("content", СистемныйПромпт);
	Сообщения.Добавить(СистемноеСообщение);
	
	// Добавляем историю диалога (включая системные сообщения для понимания результатов выполнения)
	Для Каждого СтрокаИстории Из История Цикл
		
		Сообщение = Новый Структура;
		
		Если СтрокаИстории.Автор = Перечисления.ИИА_АвторСообщения.Пользователь Тогда
			Сообщение.Вставить("role", "user");
		ИначеЕсли СтрокаИстории.Автор = Перечисления.ИИА_АвторСообщения.ИИ Тогда
			Сообщение.Вставить("role", "assistant");
		ИначеЕсли СтрокаИстории.Автор = Перечисления.ИИА_АвторСообщения.Система Тогда
			// Системные сообщения передаем как сообщения от системы (role: "system")
			// Это позволяет ИИ видеть результаты выполнения DSL-сценариев
			Сообщение.Вставить("role", "system");
		Иначе
			// Пропускаем неизвестные типы авторов
			Продолжить;
		КонецЕсли;
		
		ТекстСообщения = СтрокаИстории.Текст;
		Если НЕ ПустаяСтрока(СтрокаИстории.ТекстКода) Тогда
			ТекстСообщения = ТекстСообщения + Символы.ПС + "```" + Символы.ПС + СтрокаИстории.ТекстКода + Символы.ПС + "```";
		КонецЕсли;
		
		Сообщение.Вставить("content", ТекстСообщения);
		Сообщения.Добавить(Сообщение);
		
	КонецЦикла;
	
	// Добавляем текущее сообщение пользователя
	ТекущееСообщение = Новый Структура;
	ТекущееСообщение.Вставить("role", "user");
	ТекущееСообщение.Вставить("content", ТекстПользователя);
	Сообщения.Добавить(ТекущееСообщение);
	
	Результат.Вставить("Сообщения", Сообщения);
	
	Возврат Результат;
	
КонецФункции

// Извлекает DSL JSON из текста
//
// Параметры:
//  Текст - Строка - текст, из которого нужно извлечь JSON
//
// Возвращаемое значение:
//  Строка - извлеченный JSON или пустая строка, если не найден
//
Функция ИзвлечьDSLИзТекста(Текст)
	
	Если ПустаяСтрока(Текст) Тогда
		Возврат "";
	КонецЕсли;
	
	ТекстДляПарсинга = СокрЛП(Текст);
	
	// Сначала проверяем, начинается ли текст с "{"
	Если Лев(ТекстДляПарсинга, 1) = "{" Тогда
		
		Попытка
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ТекстДляПарсинга);
			ПроверкаJSON = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			
			// Проверяем, что это DSL-сценарий
			Если ПроверкаJSON.Свойство("dsl_version") И ПроверкаJSON.Свойство("steps") Тогда
				Возврат ТекстДляПарсинга;
			КонецЕсли;
			
		Исключение
			// Не JSON или не DSL - продолжаем поиск
		КонецПопытки;
		
	КонецЕсли;
	
	// Если текст не начинается с "{", ищем JSON внутри текста
	НачалоОткрывающейСкобки = СтрНайти(Текст, "{");
	Если НачалоОткрывающейСкобки > 0 Тогда
		
		// Ищем закрывающую скобку с конца
		КонецЗакрывающейСкобки = СтрНайти(Текст, "}", НаправлениеПоиска.СКонца);
		Если КонецЗакрывающейСкобки > 0 И КонецЗакрывающейСкобки > НачалоОткрывающейСкобки Тогда
			
			ВозможныйJSON = Сред(Текст, НачалоОткрывающейСкобки, КонецЗакрывающейСкобки - НачалоОткрывающейСкобки + 1);
			
			Попытка
				ЧтениеJSON = Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(ВозможныйJSON);
				ПроверкаJSON = ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				
				// Проверяем, что это DSL-сценарий
				Если ПроверкаJSON.Свойство("dsl_version") И ПроверкаJSON.Свойство("steps") Тогда
					Возврат ВозможныйJSON;
				КонецЕсли;
				
			Исключение
				// Не JSON или не DSL
			КонецПопытки;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

// Распознает ответ ИИ и определяет его тип
//
// Параметры:
//  ТекстОтветаИИ - Строка - текст ответа от ИИ
//  ТипСообщения - Строка - тип исходного сообщения
//
// Возвращаемое значение:
//  Структура - структура результата с распознанным типом и данными
//
Функция РаспознатьОтветИИ(ТекстОтветаИИ, ТипСообщения) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОтвета", "Текст");
	Результат.Вставить("Текст", ТекстОтветаИИ);
	Результат.Вставить("Запрос", "");
	Результат.Вставить("DSL", "");
	Результат.Вставить("ВыполнитьDSL", Ложь);
	
	// Пытаемся найти JSON в ответе (DSL-сценарий)
	ИзвлеченныйDSL = ИзвлечьDSLИзТекста(ТекстОтветаИИ);
	
	Если НЕ ПустаяСтрока(ИзвлеченныйDSL) Тогда
		
		Результат.ТипОтвета = "DSL";
		Результат.DSL = ИзвлеченныйDSL;
		Результат.ВыполнитьDSL = Истина; // Выполняем DSL-сценарий автоматически
		
		// Извлекаем текст перед JSON (если есть)
		НачалоОткрывающейСкобки = СтрНайти(ТекстОтветаИИ, "{");
		Если НачалоОткрывающейСкобки > 1 Тогда
			ТекстПередJSON = СокрЛП(Лев(ТекстОтветаИИ, НачалоОткрывающейСкобки - 1));
			Если НЕ ПустаяСтрока(ТекстПередJSON) Тогда
				Результат.Текст = ТекстПередJSON;
			Иначе
				Результат.Текст = "Сгенерирован DSL-сценарий:";
			КонецЕсли;
		Иначе
			Результат.Текст = "Сгенерирован DSL-сценарий:";
		КонецЕсли;
		
		Возврат Результат;
		
	КонецЕсли;
	
	// Если тип сообщения "Запрос", пытаемся найти запрос в ответе
	Если ТипСообщения = "Запрос" Тогда
		
		// Ищем блок кода с запросом
		НачалоБлока = СтрНайти(ТекстОтветаИИ, "```");
		Если НачалоБлока > 0 Тогда
			
			// Ищем вторую тройку обратных кавычек после первой, начиная с позиции после первой
			КонецБлока = СтрНайти(ТекстОтветаИИ, "```", , НачалоБлока + 3);
			Если КонецБлока > 0 Тогда
				
				ТекстЗапроса = Сред(ТекстОтветаИИ, НачалоБлока + 3, КонецБлока - НачалоБлока - 3);
				ТекстЗапроса = СокрЛП(ТекстЗапроса);
				
				// Проверяем, что это похоже на запрос 1С
				Если СтрНайти(ВРег(ТекстЗапроса), "ВЫБРАТЬ") > 0 Тогда
					
					Результат.ТипОтвета = "Запрос";
					Результат.Запрос = ТекстЗапроса;
					Результат.Текст = "Сгенерирован запрос:";
					
					Возврат Результат;
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// По умолчанию возвращаем как текст
	Возврат Результат;
	
КонецФункции

// Исправляет DSL-сценарий через ИИ при ошибке выполнения
//
// Параметры:
//  DSLJSON - Строка - исходный DSL-сценарий с ошибкой
//  ТекстОшибки - Строка - текст ошибки выполнения
//  Настройки - Структура - настройки пользователя
//  НомерПопытки - Число - номер текущей попытки исправления (по умолчанию 1)
//  МаксимальноеКоличествоПопыток - Число - максимальное количество попыток исправления (по умолчанию 2)
//
// Возвращаемое значение:
//  Структура - структура результата:
//   * Успех - Булево
//   * Сообщение - Строка
//   * ИсправленныйDSL - Строка - исправленный DSL-сценарий
//
Функция ИсправитьDSLЧерезИИ(DSLJSON, ТекстОшибки, Настройки, НомерПопытки = 1, МаксимальноеКоличествоПопыток = 2) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Успех", Ложь);
	Результат.Вставить("Сообщение", "");
	Результат.Вставить("ИсправленныйDSL", "");
	
	// Проверяем, не превышен ли лимит попыток исправления
	Если НомерПопытки > МаксимальноеКоличествоПопыток Тогда
		Результат.Сообщение = "Достигнут лимит попыток исправления (" + Формат(МаксимальноеКоличествоПопыток, "ЧН=0") + "). Дальнейшие исправления отменены.";
		Возврат Результат;
	КонецЕсли;
	
	// Формируем промпт для исправления
	ПромптИсправления = "Исправь следующий DSL-сценарий, который вызвал ошибку:" + Символы.ПС +
		"Ошибка: " + ТекстОшибки + Символы.ПС +
		"Исходный DSL:" + Символы.ПС +
		DSLJSON + Символы.ПС +
		"Верни только исправленный JSON без дополнительных комментариев.";
	
	// Вызываем ИИ для исправления
	Попытка
		
		БазовыйURL = Настройки.Provider_BaseUrl;
		Если ПустаяСтрока(БазовыйURL) Тогда
			БазовыйURL = "https://gigachat.devices.sberbank.ru";
		КонецЕсли;
		
		URLПуть = "/api/v1/chat/completions";
		
		Сообщения = Новый Массив;
		Сообщение = Новый Структура;
		Сообщение.Вставить("role", "user");
		Сообщение.Вставить("content", ПромптИсправления);
		Сообщения.Добавить(Сообщение);
		
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("model", "GigaChat:latest");
		ТелоЗапроса.Вставить("messages", Сообщения);
		ТелоЗапроса.Вставить("temperature", 0.3); // Низкая температура для более точного исправления
		ТелоЗапроса.Вставить("max_tokens", 2000);
		
		ЗаписьJSON = Новый ЗаписьJSON;
		ЗаписьJSON.УстановитьСтроку();
		ЗаписатьJSON(ЗаписьJSON, ТелоЗапроса);
		JSONТело = ЗаписьJSON.Закрыть();
		
		// Получаем токен доступа (используем ту же логику, что и в ВызватьГигачат)
		ТокенДоступа = ИИА_Гигачат.ПолучитьТокенДоступа(Настройки);
		
		// Извлекаем домен из URL
		БазовыйДомен = БазовыйURL;
		Если СтрНайти(БазовыйДомен, "://") > 0 Тогда
			БазовыйДомен = СтрЗаменить(БазовыйДомен, "https://", "");
			БазовыйДомен = СтрЗаменить(БазовыйДомен, "http://", "");
		КонецЕсли;
		
		HTTPСоединение = Новый HTTPСоединение(БазовыйДомен, , , , , , Новый ЗащищенноеСоединениеOpenSSL());
		
		Заголовки = Новый Соответствие;
		Заголовки.Вставить("Content-Type", "application/json");
		Заголовки.Вставить("Accept", "application/json");
		Заголовки.Вставить("Cache-Control", "no-cache");
		Заголовки.Вставить("Authorization", "Bearer " + ТокенДоступа);
		
		HTTPЗапрос = Новый HTTPЗапрос(URLПуть, Заголовки);
		HTTPЗапрос.УстановитьТелоИзСтроки(JSONТело);
		
		HTTPОтвет = HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);
		
		Если HTTPОтвет.КодСостояния = 200 Тогда
			
			ТекстОтвета = HTTPОтвет.ПолучитьТелоКакСтроку();
			
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ТекстОтвета);
			ОтветJSON = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			
			Если ОтветJSON.Свойство("choices") И ОтветJSON.choices.Количество() > 0 Тогда
				
				Выбор = ОтветJSON.choices[0];
				Если Выбор.Свойство("message") И Выбор.message.Свойство("content") Тогда
					
					ТекстИсправления = Выбор.message.content;
					
					// Извлекаем JSON из ответа (используем общую функцию)
					ИсправленныйJSON = ИзвлечьDSLИзТекста(ТекстИсправления);
					
					// Если JSON найден, проверяем его
					Если НЕ ПустаяСтрока(ИсправленныйJSON) Тогда
						
						// Проверяем исправленный DSL
						РезультатПроверки = ИИА_Сервер.ПроверитьDSLСценарий(ИсправленныйJSON);
						Если РезультатПроверки.Успех Тогда
							
							Результат.Успех = Истина;
							Результат.ИсправленныйDSL = ИсправленныйJSON;
							Результат.Сообщение = "DSL-сценарий исправлен";
							
						Иначе
							
							Результат.Сообщение = "Исправленный DSL также содержит ошибки: " + РезультатПроверки.Сообщение;
							
						КонецЕсли;
						
					Иначе
						
						Результат.Сообщение = "Не удалось извлечь JSON из ответа ИИ. Ответ: " + ТекстИсправления;
						
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЕсли;
			
		Иначе
			
			Результат.Сообщение = "Ошибка API при исправлении: " + Формат(HTTPОтвет.КодСостояния, "ЧН=0");
			
		КонецЕсли;
		
	Исключение
		
		Результат.Сообщение = "Ошибка при исправлении DSL: " + ОписаниеОшибки();
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти
