Ниже — подробная постановка задачи для 1С-разработчика: реализовать псевдо-RAG (локальный retrieval по метаданным) внутри расширения 1С, без внешних сервисов. Цель — по текстовому вопросу пользователя находить релевантные объекты метаданных (документы/справочники/регистры/формы/команды) и возвращать “контекст” (карточки объектов) для дальнейшего использования агентом/подсказчиком.

1. Цель и пользовательские сценарии
1.1. Что делаем

В расширении 1С реализовать локальный поисковый движок, который:

строит индекс по метаданным текущей конфигурации;

принимает запрос пользователя в свободной форме (например: “где реализация”, “расходная накладная”, “остатки по складам”, “как называется документ отгрузки”);

возвращает Top-K результатов (объекты метаданных) с объяснимым ранжированием и карточкой контекста.

Это “псевдо-RAG”: мы делаем Retrieval (поиск+ранжирование+контекст) локально; генерация текста агентом — отдельная часть (может быть позже).

1.2. Основные кейсы

Кейс A (поиск объекта по бизнес-термину):

запрос: “расходная накладная”

ожидаемо: найти документ “РеализацияТоваровУслуг” (или другой в конкретной конфигурации) по синониму/представлению.

Кейс B (поиск по функциональному смыслу):

запрос: “документ реализации”

ожидаемо: документ(ы) продажи/отгрузки, приоритет — где в синониме/подсистеме/командах есть “реализация”, “отгрузка”.

Кейс C (поиск по структуре данных):

запрос: “где остатки”

ожидаемо: регистры накопления “ТоварыНаСкладах/Остатки…” и т.п., включая измерения/ресурсы.

Кейс D (поиск по реквизитам):

запрос: “в каком документе есть реквизит Контрагент”

ожидаемо: список документов/справочников с реквизитом “Контрагент/Партнер”.

2. Ограничения и требования
2.1. Ограничения

Только расширение 1С. Никаких внешних HTTP/веб-сервисов/LLM/pgvector.

Разрешены стандартные средства платформы: метаданные, регистры, хранилища значений, фоновые задания (если доступны), формы.

2.2. Нефункциональные требования

Индексация должна быть приемлема по времени (ориентир):

типовая УНФ/УТ: до 1–5 минут на построение на средних серверах;

крупная ERP: допускается дольше, но нужен прогресс/лог.

Поиск должен отвечать быстро: ориентир до 300–700 мс на запрос при нормальном объёме.

Индекс должен быть обновляемым (перестроение целиком + инкремент при возможности).

Результаты должны быть объяснимыми (почему найдено: совпал синоним/имя/реквизит/подсистема).

3. Архитектура решения (внутри 1С)
3.1. Компоненты

Сканер метаданных — обходит Метаданные и формирует “чанки”.

Нормализатор текста — приводит текст к поисковому виду (lower, разделители, токены).

Словарь синонимов — расширяет запрос и/или индекс.

Индексатор — строит:

базу чанков (документов индекса),

инвертированный индекс “токен → список чанков”,

статистику DF/N.

Поисковик — принимает запрос → кандидаты → скоринг → Top-K.

UI — форма поиска + кнопки “перестроить индекс”, “показать карточку”, “открыть объект”.

3.2. Объекты метаданных расширения (рекомендуемо)
3.2.1. Регистр сведений AI_Chunks

Хранит чанки (поисковые документы).

Измерения:

КлючЧанка (Строка, уникальный)

Ресурсы/реквизиты:

ТипМетаданных (Строка / Перечисление: Document, Catalog, AccumulationRegister, InformationRegister, Enum, CommonModule, Form, Command)

ИмяМетаданных (Строка) — системное имя

Синоним (Строка)

Путь (Строка) — человекочитаемый путь

Текст (ХранилищеЗначения) — нормализованный текст чанка (для сниппетов)

ДлинаТекста (Число) — для нормализаций скоринга

ХэшИсточник (Строка) — для инкрементального обновления

ВремяИндексации (Дата)

3.2.2. Регистр сведений AI_TokenIndex

Инвертированный индекс.

Измерения:

Токен (Строка)

КлючЧанка (Строка)

Ресурсы:

TF (Число) — term frequency в чанке

3.2.3. Регистр сведений AI_TokenStats

Статистика по токенам.

Измерения:

Токен (Строка)

Ресурсы:

DF (Число) — сколько чанков содержит токен

IDF (Число) — можно хранить заранее

3.2.4. Константы/настройки

AI_IndexBuiltAt (Дата)

AI_ConfigSignature (Строка) — признак версии конфигурации (см. ниже)

AI_StopWords (Строка/ХранилищеЗначения) — список стоп-слов

AI_Synonyms (Строка/ХранилищеЗначения JSON) — словарь синонимов

4. Сканер метаданных: что индексируем
4.1. Минимальный объём (MVP)

Индексируем:

Документы: имя, синоним, реквизиты, табличные части (имена и колонки), (если доступно) подсистемы/команды.

Справочники: имя, синоним, реквизиты, табличные части.

Регистры накопления/сведений: имя, синоним, измерения/ресурсы/реквизиты.

Перечисления: имя, синоним, элементы (имя/синоним).

Общие модули — опционально (если задача строго “по метаданным”, можно не включать на MVP).

4.2. Формат чанков (важно)

Для каждого объекта формируем 1–3 чанка:

Chunk “header”:

Документ РеализацияТоваровУслуг

Синоним: Реализация (акты, накладные)

Ключевые слова: реализация, отгрузка, накладная, продажа (можно генерировать из синонимов/словаря)

Chunk “attributes”:

Реквизиты: Контрагент (СправочникСсылка.Партнеры), Договор …

ТЧ Товары: Номенклатура, Количество, Цена, Сумма …

Chunk “registers” (если извлекаемо):

Движения: РегистрНакопления.ТоварыНаСкладах (Расход)…

5. Нормализация и токенизация
5.1. Нормализация строки

Функция NormalizeText(Строка):

привести к нижнему регистру

заменить разделители . , : ; ( ) [ ] { } / \ - _ на пробел

разрезать CamelCase (эвристика: вставлять пробел перед заглавной, если предыдущий символ строчный/цифра)

схлопнуть пробелы

убрать мусор (служебные символы)

5.2. Токены

Tokenize(НормТекст):

split по пробелу

фильтр: длина 2..32

исключить стоп-слова

можно добавлять “тех-токены”:

для РеализацияТоваровУслуг добавить ещё токены реализация, товаров, услуг, рту

6. Словарь синонимов
6.1. Где хранить

В константе AI_Synonyms в JSON, например:

{
  "реализация": ["отгрузка","накладная","расходная","рту","продажа"],
  "контрагент": ["партнер","клиент","покупатель"],
  "номенклатура": ["товар","продукция"],
  "остатки": ["товарынаскладах","складскиеостатки"]
}

6.2. Как применять

Два режима:

Query expansion: расширять запрос синонимами при поиске.

Index enrichment: добавлять синонимы прямо в текст чанка (аккуратно, чтобы не зашумить).

Для MVP достаточно query expansion + небольшой набор синонимов 1С-лексики.

7. Ранжирование (скоринг)
7.1. Кандидаты

По токенам запроса получить список КлючЧанка из AI_TokenIndex.

Ограничить кандидатов:

по максимальному количеству на токен (например, топ 2000 по TF, либо все, если мало)

объединить множества, посчитать частоты совпадений

7.2. Скоринг BM25-lite

Для каждого кандидата:

score = Σ (idf(token) * tf(token, chunk))

Где:

idf(token) берём из AI_TokenStats (или считаем на лету)

tf — из AI_TokenIndex

7.3. Бонусы (обязательно для “Расходной накладной”)

Добавить к score:

+100, если точное совпадение в Синоним (после нормализации)

+80, если точное совпадение в ИмяМетаданных

+40, если совпадение в Путь

*1.5..3, если контекст пользователя совпадает (см. ниже)

7.4. Контекст пользователя

Если поиск вызывается из формы/объекта:

передавать ActiveMetadataName / ActiveSection (подсистема)

повышать score объектов из той же подсистемы/типа

8. Контекст (то, что “как RAG” отдаём дальше)

Функция GetChunkContext(КлючЧанка) возвращает:

заголовок: тип + имя + синоним

список реквизитов/ТЧ/измерений/ресурсов (кратко)

“сниппет”: несколько строк вокруг совпавших токенов (можно просто первые 300–600 символов текста чанка)

причины ранжирования: Совпало: [синоним, реквизит Контрагент, токены реализация/накладная]

9. UI/Интеграция в агента
9.1. Форма “Поиск по метаданным”

Элементы:

поле ввода запроса

кнопки: “Найти”, “Перестроить индекс”, “Настройки”

таблица результатов:

Ранг, Тип, Имя, Синоним, Путь, Score

панель карточки: контекст выбранного результата

действия:

“Открыть объект” (если возможно)

“Скопировать путь/имя”

“Показать реквизиты”

9.2. API для агента (внутри расширения)

Экспортные процедуры/функции:

AI_Index.Build() — построение индекса

AI_Search.Find(Запрос, Контекст, TopK) — поиск

AI_Search.GetContext(КлючЧанка) — контекст чанка

AI_Settings.Load/Save() — синонимы/стоп-слова

10. Построение индекса: алгоритм
10.1. Полная перестройка

Очистить AI_Chunks, AI_TokenIndex, AI_TokenStats

Обойти метаданные:

для каждого объекта сформировать чанки

нормализовать текст чанка

токенизировать

записать чанк в AI_Chunks

для каждого токена:

записать строку в AI_TokenIndex (Токен, КлючЧанка, TF)

Посчитать DF для каждого токена и записать AI_TokenStats

Посчитать IDF (или оставлять DF и считать IDF при запросе)

Записать AI_IndexBuiltAt

10.2. Инкремент (если делаете)

Хранить ХэшИсточник на чанк:

если совпадает — пропустить

если изменился — удалить старые записи AI_TokenIndex по КлючЧанка, перезаписать чанк и токены

Примечание: метаданные в рантайме меняются редко, инкремент можно отложить.

11. Определение “версии конфигурации” для автоперестройки

Нужно понять, когда индекс устарел.
Варианты:

хранить ручную “версию индекса” + кнопка “перестроить”

или вычислять “подпись”: например, количество объектов + суммы длин имён/синонимов (быстрая эвристика)

если доступно: использовать Метаданные.Имя, Метаданные.Версия (зависит от режима/конфигурации)

Для MVP: ручной режим + предупреждение “индекс построен тогда-то”.

12. Тестирование и критерии приёмки
12.1. Набор тест-кейсов

“расходная накладная” → документ реализации (топ-1..топ-3)

“реализация” → документ реализации

“контрагент в документах” → документы/справочники с реквизитом

“остатки” → регистры остатков

“товары на складах” → соответствующий регистр

Опечатка: “расходная накладнвя” → всё равно находит (fuzzy/триграммы)

12.2. Метрики качества

Top-3 accuracy по набору тестов ≥ 80% для MVP

Время поиска ≤ 700 мс на типовой базе (после прогрева кэша)

Перестройка индекса без ошибок, лог с количеством чанков/токенов

13. Оптимизации (сразу заложить в ТЗ)

Пакетная запись наборов записей (минимум транзакций)

Кэш AI_TokenStats (idf/df) в памяти на время поиска

Ограничение “частых токенов” (если df слишком большой — снижать вес или игнорировать)

Триграммы только по полям ИмяМетаданных и Синоним (не по всему тексту чанков)

14. Что считать “готово” (Definition of Done)

Есть форма поиска и команда построения индекса

Индекс строится и хранится в регистрах

Поиск выдаёт Top-K объектов с ранжированием

Работают синонимы (реализация ↔ накладная/отгрузка/рту)

Есть карточка контекста и объяснение “почему найдено”

Код оформлен как подсистема расширения, без вмешательства в конфу

Ок. Ниже — конкретный каркас (псевдокод максимально близкий к 1С) + рекомендуемая структура модулей/форм расширения для локального “псевдо-RAG” по метаданным.

1) Структура расширения
Подсистема AIПоискМетаданных

Общие модули (сервер):

AI_ИндексМетаданных — построение/обновление индекса

AI_ПоискМетаданных — поиск/ранжирование/контекст

AI_Текст — нормализация/токенизация/триграммы

AI_Настройки — стоп-слова/синонимы (JSON) + кеши

Форма:

AI_ФормаПоискаМетаданных (управляемая форма)

Метаданные расширения:

РС AI_Chunks

РС AI_TokenIndex

РС AI_TokenStats

(опционально) РС AI_NameTrigrams для fuzzy по именам/синонимам

Константы: AI_StopWords, AI_Synonyms, AI_IndexBuiltAt

2) Форматы данных (минимум полей)
РС AI_Chunks

Измерение: КлючЧанка (Строка 72)
Ресурсы/реквизиты:

Тип (Строка 32) // "Document", "Catalog", "AccumReg"...

Имя (Строка 128) // системное имя метаданных

Синоним (Строка 256)

Путь (Строка 512) // человекопуть

Текст (ХранилищеЗначения) // нормализованный

Длина (Число 10,0)

Хэш (Строка 64)

ДатаИндекса (Дата)

РС AI_TokenIndex

Измерения: Токен (Строка 64), КлючЧанка (Строка 72)
Ресурс: TF (Число 10,0)

РС AI_TokenStats

Измерение: Токен (Строка 64)
Ресурсы: DF (Число 10,0), IDF (Число 15,8)

3) Построение индекса (серверный модуль AI_ИндексМетаданных)
3.1 API

Процедура ПерестроитьИндекс() Экспорт

Функция ПолучитьПодписьКонфигурации() Экспорт (опционально)

3.2 Псевдокод: перестройка индекса
Процедура ПерестроитьИндекс() Экспорт
    // 1) Очистка
    ОчиститьРегистрСведений("AI_Chunks");
    ОчиститьРегистрСведений("AI_TokenIndex");
    ОчиститьРегистрСведений("AI_TokenStats");

    // 2) Подготовка кешей
    СтопСлова = AI_Настройки.ПолучитьСтопСлова();          // Множество
    Синонимы  = AI_Настройки.ПолучитьСинонимы();           // Соответствие (строка -> массив строк)

    N = 0; // количество чанков
    DF = Новый Соответствие; // токен -> количество чанков, где встречается

    НаборЧанков = РегистрыСведений.AI_Chunks.СоздатьНаборЗаписей();
    НаборТокенов = РегистрыСведений.AI_TokenIndex.СоздатьНаборЗаписей();

    // 3) Обход метаданных
    Для каждого ДокИз Метаданные.Документы Цикл
        СформироватьЧанкиОбъекта("Document", ДокИз, НаборЧанков, НаборТокенов, DF, СтопСлова);
    КонецЦикла;

    Для каждого Спр Из Метаданные.Справочники Цикл
        СформироватьЧанкиОбъекта("Catalog", Спр, НаборЧанков, НаборТокенов, DF, СтопСлова);
    КонецЦикла;

    Для каждого РН Из Метаданные.РегистрыНакопления Цикл
        СформироватьЧанкиРегистра("AccumReg", РН, НаборЧанков, НаборТокенов, DF, СтопСлова);
    КонецЦикла;

    Для каждого РС Из Метаданные.РегистрыСведений Цикл
        СформироватьЧанкиРегистра("InfoReg", РС, НаборЧанков, НаборТокенов, DF, СтопСлова);
    КонецЦикла;

    Для каждого Пер Из Метаданные.Перечисления Цикл
        СформироватьЧанкиПеречисления("Enum", Пер, НаборЧанков, НаборТокенов, DF, СтопСлова);
    КонецЦикла;

    // 4) Запись чанков и токен-индекса (важно: писать пакетно)
    НаборЧанков.Записать();
    НаборТокенов.Записать();

    // 5) Посчитать IDF и записать stats
    N = ПолучитьКоличествоЧанков(); // запросом по РС AI_Chunks

    НаборStats = РегистрыСведений.AI_TokenStats.СоздатьНаборЗаписей();
    Для каждого Пара Из DF Цикл
        Токен = Пара.Ключ;
        dfVal = Пара.Значение;

        // idf = ln((N - df + 0.5)/(df + 0.5) + 1)
        idfVal = Логарифм((N - dfVal + 0.5) / (dfVal + 0.5) + 1);

        Зап = НаборStats.Добавить();
        Зап.Токен = Токен;
        Зап.DF = dfVal;
        Зап.IDF = idfVal;
    КонецЦикла;
    НаборStats.Записать();

    Константы.AI_IndexBuiltAt.Установить(ТекущаяДата());
КонецПроцедуры

4) Генерация чанков и токенов
4.1 Общая функция для объектов (док/спр)
Процедура СформироватьЧанкиОбъекта(Тип, ОбъектМетаданных, НаборЧанков, НаборТокенов, DF, СтопСлова)

    Имя = ОбъектМетаданных.Имя;
    Синоним = ОбъектМетаданных.Синоним;

    // Chunk 1: header
    Текст1 = "тип " + Тип + " имя " + Имя + " синоним " + Синоним;

    // Chunk 2: attributes (реквизиты)
    Текст2 = "реквизиты ";
    Для каждого Рек Из ОбъектМетаданных.Реквизиты Цикл
        Текст2 = Текст2 + Рек.Имя + " " + Рек.Синоним + " тип " + Строка(Рек.Тип) + " ";
    КонецЦикла;

    // Chunk 3: tabular sections
    Текст3 = "табличные части ";
    Для каждого ТЧ Из ОбъектМетаданных.ТабличныеЧасти Цикл
        Текст3 = Текст3 + "тч " + ТЧ.Имя + " " + ТЧ.Синоним + " колонки ";
        Для каждого Кол Из ТЧ.Реквизиты Цикл
            Текст3 = Текст3 + Кол.Имя + " " + Кол.Синоним + " ";
        КонецЦикла;
    КонецЦикла;

    ЗаписатьЧанк(Тип, Имя, Синоним, Тип + "." + Имя, "header", Текст1, НаборЧанков, НаборТокенов, DF, СтопСлова);
    ЗаписатьЧанк(Тип, Имя, Синоним, Тип + "." + Имя, "attrs",  Текст2, НаборЧанков, НаборТокенов, DF, СтопСлова);
    ЗаписатьЧанк(Тип, Имя, Синоним, Тип + "." + Имя, "tab",    Текст3, НаборЧанков, НаборТокенов, DF, СтопСлова);

КонецПроцедуры

4.2 Регистры
Процедура СформироватьЧанкиРегистра(Тип, Рег, НаборЧанков, НаборТокенов, DF, СтопСлова)

    Имя = Рег.Имя;
    Синоним = Рег.Синоним;

    Текст = "тип " + Тип + " имя " + Имя + " синоним " + Синоним + " ";

    Текст = Текст + "измерения ";
    Для каждого Изм Из Рег.Измерения Цикл
        Текст = Текст + Изм.Имя + " " + Изм.Синоним + " тип " + Строка(Изм.Тип) + " ";
    КонецЦикла;

    Текст = Текст + "ресурсы ";
    Для каждого Рес Из Рег.Ресурсы Цикл
        Текст = Текст + Рес.Имя + " " + Рес.Синоним + " тип " + Строка(Рес.Тип) + " ";
    КонецЦикла;

    Текст = Текст + "реквизиты ";
    Для каждого Рек Из Рег.Реквизиты Цикл
        Текст = Текст + Рек.Имя + " " + Рек.Синоним + " тип " + Строка(Рек.Тип) + " ";
    КонецЦикла;

    ЗаписатьЧанк(Тип, Имя, Синоним, Тип + "." + Имя, "reg", Текст, НаборЧанков, НаборТокенов, DF, СтопСлова);

КонецПроцедуры

4.3 Перечисления
Процедура СформироватьЧанкиПеречисления(Тип, Пер, НаборЧанков, НаборТокенов, DF, СтопСлова)
    Имя = Пер.Имя; Синоним = Пер.Синоним;
    Текст = "тип enum имя " + Имя + " синоним " + Синоним + " элементы ";

    Для каждого Эл Из Пер.ЗначенияПеречисления Цикл
        Текст = Текст + Эл.Имя + " " + Эл.Синоним + " ";
    КонецЦикла;

    ЗаписатьЧанк("Enum", Имя, Синоним, "Enum." + Имя, "enum", Текст, НаборЧанков, НаборТокенов, DF, СтопСлова);
КонецПроцедуры

5) Запись чанка + заполнение инвертированного индекса
Процедура ЗаписатьЧанк(Тип, Имя, Синоним, Путь, Суффикс, ТекстИсх, НаборЧанков, НаборТокенов, DF, СтопСлова)

    КлючЧанка = Тип + "|" + Имя + "|" + Суффикс;

    Норм = AI_Текст.Нормализовать(ТекстИсх);
    Токены = AI_Текст.Токенизировать(Норм, СтопСлова); // Массив строк

    // Запись чанка
    ЗапЧ = НаборЧанков.Добавить();
    ЗапЧ.КлючЧанка = КлючЧанка;
    ЗапЧ.Тип = Тип;
    ЗапЧ.Имя = Имя;
    ЗапЧ.Синоним = Лев(Синоним, 256);
    ЗапЧ.Путь = Путь;
    ЗапЧ.Текст = ПоместитьВХранилищеЗначения(Норм);
    ЗапЧ.Длина = СтрДлина(Норм);
    ЗапЧ.Хэш = AI_Текст.SHA1(Норм); // можно заменить на более простой хэш, если без крипто
    ЗапЧ.ДатаИндекса = ТекущаяДата();

    // TF подсчет
    TFMap = Новый Соответствие; // токен -> tf
    Для каждого t Из Токены Цикл
        Если Не TFMap.СодержитКлюч(t) Тогда
            TFMap.Вставить(t, 1);
        Иначе
            TFMap.Вставить(t, TFMap[t] + 1);
        КонецЕсли;
    КонецЦикла;

    // Запись токен-индекса и DF
    Для каждого Пара Из TFMap Цикл
        t = Пара.Ключ;
        tf = Пара.Значение;

        ЗапТ = НаборТокенов.Добавить();
        ЗапТ.Токен = t;
        ЗапТ.КлючЧанка = КлючЧанка;
        ЗапТ.TF = tf;
    КонецЦикла;

    // DF увеличиваем 1 раз на токен (по TFMap, не по всем токенам)
    Для каждого Пара Из TFMap Цикл
        t = Пара.Ключ;
        Если Не DF.СодержитКлюч(t) Тогда DF.Вставить(t, 1); Иначе DF.Вставить(t, DF[t] + 1); КонецЕсли;
    КонецЦикла;

КонецПроцедуры

6) Нормализация/токенизация (модуль AI_Текст)
Функция Нормализовать(Текст) Экспорт
    Если Текст = Неопределено Тогда Возврат ""; КонецЕсли;
    s = НРег(Текст);

    // заменить разделители на пробел
    Для каждого ch Из СтрРазделить(".,:;()[]{}\/-_""'`|", "") Цикл
        s = СтрЗаменить(s, ch, " ");
    КонецЦикла;

    // CamelCase разрезка (упрощенно): вставить пробел перед заглавной в исходнике невозможно после НРег.
    // Поэтому лучше ДО НРег сделать SplitCamelCase. Для MVP можно пропустить.

    s = СокрЛП(СтрЗаменить(s, Символы.Таб, " "));
    Пока Найти(s, "  ") > 0 Цикл s = СтрЗаменить(s, "  ", " "); КонецЦикла;

    Возврат s;
КонецФункции

Функция Токенизировать(НормТекст, СтопСлова) Экспорт
    Рез = Новый Массив;
    Если ПустаяСтрока(НормТекст) Тогда Возврат Рез; КонецЕсли;

    parts = СтрРазделить(НормТекст, " ");
    Для каждого p Из parts Цикл
        t = СокрЛП(p);
        Если СтрДлина(t) < 2 Или СтрДлина(t) > 32 Тогда Продолжить; КонецЕсли;
        Если СтопСлова <> Неопределено И СтопСлова.Содержит(t) Тогда Продолжить; КонецЕсли;
        Рез.Добавить(t);
    КонецЦикла;

    Возврат Рез;
КонецФункции


Важно: CamelCase в 1С метаданных встречается постоянно (РеализацияТоваровУслуг). Лучше сделать SplitCamelCase до НРег, иначе вы потеряете границы. Это реально улучшит “реализация → расходная накладная”.

7) Поиск (модуль AI_ПоискМетаданных)
7.1 API

Функция Найти(Запрос, TopK, Контекст) Экспорт → ТаблицаЗначений результатов

Функция ПолучитьКонтекст(КлючЧанка) Экспорт → структура (карточка)

7.2 Псевдокод: поиск
Функция Найти(Запрос, TopK, Контекст) Экспорт

    Если TopK = 0 Тогда TopK = 10; КонецЕсли;

    СтопСлова = AI_Настройки.ПолучитьСтопСлова();
    Синонимы  = AI_Настройки.ПолучитьСинонимы();

    qNorm = AI_Текст.Нормализовать(Запрос);
    qTokens = AI_Текст.Токенизировать(qNorm, СтопСлова);

    // Query expansion
    qAll = Новый Массив;
    Для каждого t Из qTokens Цикл
        qAll.Добавить(t);
        Если Синонимы.СодержитКлюч(t) Тогда
            Для каждого s Из Синонимы[t] Цикл qAll.Добавить(s); КонецЦикла;
        КонецЕсли;
    КонецЦикла;

    // 1) собрать кандидатов: токен -> список чанков
    // Считаем score по BM25-lite: sum(idf * tf) + бонусы
    Scores = Новый Соответствие; // КлючЧанка -> число
    HitReasons = Новый Соответствие; // КлючЧанка -> Массив причин (опционально)

    Для каждого t Из qAll Цикл
        idf = ПолучитьIDF(t); // из AI_TokenStats, если нет — 0

        Если idf = 0 Тогда Продолжить; КонецЕсли;

        // вытащить все (КлючЧанка, TF) по токену
        Выборка = ЗапроситьTokenPostings(t); // запрос к РС AI_TokenIndex

        Пока Выборка.Следующий() Цикл
            key = Выборка.КлючЧанка;
            tf = Выборка.TF;

            add = idf * tf;

            Если Не Scores.СодержитКлюч(key) Тогда
                Scores.Вставить(key, add);
                // причины
                arr = Новый Массив; arr.Добавить("токен:" + t);
                HitReasons.Вставить(key, arr);
            Иначе
                Scores.Вставить(key, Scores[key] + add);
                HitReasons[key].Добавить("токен:" + t);
            КонецЕсли;
        КонецЦикла;
    КонецЦикла;

    // 2) бонусы точного совпадения по имени/синониму/пути
    // (делаем запросом по AI_Chunks для всех кандидатов, лучше пачкой)
    Keys = Scores.Ключи();
    Детали = ПолучитьЧанкиПачкой(Keys); // Таблица: key, Тип, Имя, Синоним, Путь, Текст

    Для каждого Стр Из Детали Цикл
        key = Стр.КлючЧанка;
        bonus = 0;

        // точные подстроки
        sName = AI_Текст.Нормализовать(Стр.Имя);
        sSyn  = AI_Текст.Нормализовать(Стр.Синоним);
        sPath = AI_Текст.Нормализовать(Стр.Путь);

        Если Найти(sSyn, qNorm) > 0 Тогда bonus = bonus + 100; HitReasons[key].Добавить("совпадение:синоним"); КонецЕсли;
        Если Найти(sName, qNorm) > 0 Тогда bonus = bonus + 80;  HitReasons[key].Добавить("совпадение:имя"); КонецЕсли;
        Если Найти(sPath, qNorm) > 0 Тогда bonus = bonus + 40;  HitReasons[key].Добавить("совпадение:путь"); КонецЕсли;

        // контекст (если передан)
        // Контекст.ActiveObjectName, Контекст.ActiveSection
        Если Контекст <> Неопределено Тогда
            Если Контекст.Свойство("ActiveObjectName") И Контекст.ActiveObjectName <> "" Тогда
                Если Стр.Имя = Контекст.ActiveObjectName Тогда
                    bonus = bonus + 60; HitReasons[key].Добавить("контекст:активный объект");
                КонецЕсли;
            КонецЕсли;
        КонецЕсли;

        Scores.Вставить(key, Scores[key] + bonus);
    КонецЦикла;

    // 3) выбрать TopK
    Результат = СформироватьТаблицуРезультатов(Детали, Scores, HitReasons, TopK);
    Возврат Результат;

КонецФункции

8) Возврат результатов и карточка контекста
8.1 Таблица результатов

Колонки:

Rank

Score

Тип

Имя

Синоним

Путь

КлючЧанка

Причины (Строка: “токен:реализация; совпадение:синоним”)

8.2 Контекст

ПолучитьКонтекст(КлючЧанка):

достаёт Текст чанка

строит сниппет: первые 500–1000 символов (или вокруг токенов)

возвращает структуру для UI

9) Fuzzy (опционально, но полезно)

Минимальный fuzzy без тяжёлых алгоритмов:

триграммы только по Имя и Синоним объектов (не по большому Текст).

если обычный поиск дал мало кандидатов — сделать “fallback” триграммный подбор и добавить в кандидаты.

Если хочешь — распишу отдельно простой алгоритм триграмм + Jaccard и структуру AI_NameTrigrams.

10) Что обязательно заложить, чтобы находилось “Расходная накладная” по “реализация”

индексация Синоним (и желательно представлений команд/форм)

SplitCamelCase: РеализацияТоваровУслуг → токены реализация, товаров, услуг

словарь синонимов: реализация -> накладная, расходная, отгрузка, рту

бонус за совпадение в синониме

Если скажешь, какая у вас целевая конфигурация (УНФ/УТ/ERP/БП) и режим (тонкий/веб, управляемые формы), я без уточняющих вопросов сразу дам:

готовый список синонимов “1С-лексики” под продажи/склады/деньги,

реалистичный SplitCamelCase под 1С-имена,

и оптимизированные запросы к регистрам, чтобы поиск не тормозил на ERP.



Ниже — как “псевдо-RAG” будет работать на живом примере: пользователь пишет “где реализация, нужна расходная накладная”, а система внутри расширения находит нужный документ и отдаёт контекст.

Пример: “реализация / расходная накладная”
Исходные метаданные (как есть в конфигурации)

Предположим, в конфигурации есть документ:

Системное имя метаданных: Документ.РеализацияТоваровУслуг

Синоним (как в интерфейсе): Реализация (акты, накладные)
(в некоторых конфах может быть “Расходная накладная” или встречаться в командных интерфейсах)

Реквизиты: Контрагент, Договор, Склад, Организация, …

ТЧ Товары: Номенклатура, Количество, Цена, Сумма, …

Шаг 1. Индексация (делается заранее админом)

Команда “Перестроить индекс” строит чанки:

Chunks для документа

Chunk A (header)
Текст (до нормализации):

“тип Document имя РеализацияТоваровУслуг синоним Реализация (акты, накладные)”

После SplitCamelCase + normalize:

“тип document имя реализация товаров услуг синоним реализация акты накладные”

Токены:

document, реализация, товаров, услуг, синоним, акты, накладные

Chunk B (attrs)

“реквизиты контрагент тип СправочникСсылка.Партнеры договор … склад …”

Токены:

реквизиты, контрагент, партнеры, договор, склад, …

Chunk C (tabular)

“табличные части тч товары колонки номенклатура количество цена сумма …”

Токены:

табличные, части, товары, номенклатура, количество, цена, сумма

Шаг 2. Пользовательский запрос

Пользователь в форме агента пишет:

“Где реализация? Нужна расходная накладная.”

Нормализация запроса

normalize →

“где реализация нужна расходная накладная”

Токены:

реализация, расходная, накладная

Расширение запроса синонимами (query expansion)

В словаре синонимов есть:

реализация → [отгрузка, накладная, расходная, рту, продажа]

накладная → [реализация, отгрузка]

Итоговый набор токенов для поиска (примерно):

реализация, расходная, накладная, отгрузка, рту, продажа

Шаг 3. Retrieval: кандидаты из инвертированного индекса

Для каждого токена достаём postings из AI_TokenIndex:

токен реализация встречается в:

Chunk A документа РеализацияТоваровУслуг

(возможно) еще в “РеализацияУслуг”, “ОтчетОРозничныхПродажах” и т.п.

токен накладные/накладная встречается:

Chunk A (если в синониме есть “накладные”)

или в других документах (например “Поступление товаров” если есть “накладная” в синонимах)

токен расходная может встретиться только в некоторых конфах.

Если “расходная” нигде не встречается напрямую, она всё равно помогает через расширение (мы добавили реализация -> расходная), т.е. влияет косвенно.

Шаг 4. Ранжирование (BM25-lite + бонусы)

Каждому кандидату начисляем score:

Почему вверх поднимется именно “РеализацияТоваровУслуг”

Совпало по “реализация” (в header-чанке) → основной вклад в score

Совпало по “накладные” (в синониме) → еще вклад

Бонус за совпадение в синониме: запрос содержит “накладная”, а в Синоним есть “накладные” → +100

Контекстный бустинг (если пользователь сейчас в разделе “Продажи” или в документе продажи) → множитель 1.5–3

Итог: Документ.РеализацияТоваровУслуг почти всегда окажется топ-1.

Шаг 5. Возврат “RAG-контекста” (карточка объекта)

По топ-результату система формирует контекст:

Результат 1

Тип: Документ

Имя: РеализацияТоваровУслуг

Синоним: Реализация (акты, накладные)

Путь: Документ.РеализацияТоваровУслуг

Короткий контекст:

Реквизиты: Контрагент, Договор, Склад, Организация, …

ТЧ “Товары”: Номенклатура, Количество, Цена, Сумма, …

Причины (объяснимость):

токен: реализация

совпадение: синоним (накладные)

синонимы запроса: накладная → реализация

Действия:

[Открыть объект метаданных] (если доступно)

[Показать реквизиты/ТЧ]

[Скопировать имя/путь]

Это и есть “псевдо-RAG”: вы достали релевантный “контекст”, который потом можно:

показать пользователю,

или передать в LLM/DSL-движок (если он есть) для генерации инструкции/кода.

Второй пример: “где остатки по складам”

Запрос: “нужны остатки по складам”

Токены: остатки, склады
Синонимы: остатки → товарынаскладах, складскиеостатки

Индекс найдёт регистр:

РегистрНакопления.ТоварыНаСкладах (потому что в чанке лежит “измерения склад … ресурсы количество …”)
и вернёт контекст:

измерения: Склад, Номенклатура

ресурсы: Количество

тип: Регистр накопления

Почему это работает именно “по метаданным”

Потому что вы превращаете метаданные в “текстовую базу знаний” (chunks) и делаете:

нормализацию

расширение запроса синонимами 1С-терминов

инвертированный индекс + ранжирование

выдачу контекста

Если хочешь, следующим шагом могу описать пример с опечаткой (“расходная накладнвя”) и как подключить триграммы как fallback, чтобы такие запросы тоже уверенно находились.